// Copyright 2024 The langsvr Authors
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

////////////////////////////////////////////////////////////////////////////////
// File generated by 'tools/cmd/gen' using the template:
//   src/lsp/lsp.cc.tmpl
//
// To regenerate run: 'go run ./tools/cmd/gen'
//
//                       Do not modify this file directly
////////////////////////////////////////////////////////////////////////////////
#include "langsvr/lsp/lsp.h"

#include <utility>

#include "langsvr/lsp/decode.h"

namespace langsvr::lsp {

namespace {

using V = const json::Value;

Result<SuccessType> MatchKind(V& v, std::string_view want) {
    auto got = v.Get<json::String>("kind");
    if (got != Success) {
        return got.Failure();
    }
    if (got.Get() != want) {
        return Failure{"'kind' mismatch.\nGot '" + got.Get() +
                       "'\nexpected ' + std:string(want) +'"};
    }
    return Success;
}

}  // namespace

Result<SuccessType> Decode(V& v, SemanticTokenTypes& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "namespace") {
        out = SemanticTokenTypes::kNamespace;
        return Success;
    }
    if (val == "type") {
        out = SemanticTokenTypes::kType;
        return Success;
    }
    if (val == "class") {
        out = SemanticTokenTypes::kClass;
        return Success;
    }
    if (val == "enum") {
        out = SemanticTokenTypes::kEnum;
        return Success;
    }
    if (val == "interface") {
        out = SemanticTokenTypes::kInterface;
        return Success;
    }
    if (val == "struct") {
        out = SemanticTokenTypes::kStruct;
        return Success;
    }
    if (val == "typeParameter") {
        out = SemanticTokenTypes::kTypeParameter;
        return Success;
    }
    if (val == "parameter") {
        out = SemanticTokenTypes::kParameter;
        return Success;
    }
    if (val == "variable") {
        out = SemanticTokenTypes::kVariable;
        return Success;
    }
    if (val == "property") {
        out = SemanticTokenTypes::kProperty;
        return Success;
    }
    if (val == "enumMember") {
        out = SemanticTokenTypes::kEnumMember;
        return Success;
    }
    if (val == "event") {
        out = SemanticTokenTypes::kEvent;
        return Success;
    }
    if (val == "function") {
        out = SemanticTokenTypes::kFunction;
        return Success;
    }
    if (val == "method") {
        out = SemanticTokenTypes::kMethod;
        return Success;
    }
    if (val == "macro") {
        out = SemanticTokenTypes::kMacro;
        return Success;
    }
    if (val == "keyword") {
        out = SemanticTokenTypes::kKeyword;
        return Success;
    }
    if (val == "modifier") {
        out = SemanticTokenTypes::kModifier;
        return Success;
    }
    if (val == "comment") {
        out = SemanticTokenTypes::kComment;
        return Success;
    }
    if (val == "string") {
        out = SemanticTokenTypes::kString;
        return Success;
    }
    if (val == "number") {
        out = SemanticTokenTypes::kNumber;
        return Success;
    }
    if (val == "regexp") {
        out = SemanticTokenTypes::kRegexp;
        return Success;
    }
    if (val == "operator") {
        out = SemanticTokenTypes::kOperator;
        return Success;
    }
    if (val == "decorator") {
        out = SemanticTokenTypes::kDecorator;
        return Success;
    }
    return Failure{"invalid value for enum SemanticTokenTypes"};
}

Result<const json::Value*> Encode(SemanticTokenTypes in, json::Builder& b) {
    switch (in) {
        case SemanticTokenTypes::kNamespace:
            return b.Create("namespace");

        case SemanticTokenTypes::kType:
            return b.Create("type");

        case SemanticTokenTypes::kClass:
            return b.Create("class");

        case SemanticTokenTypes::kEnum:
            return b.Create("enum");

        case SemanticTokenTypes::kInterface:
            return b.Create("interface");

        case SemanticTokenTypes::kStruct:
            return b.Create("struct");

        case SemanticTokenTypes::kTypeParameter:
            return b.Create("typeParameter");

        case SemanticTokenTypes::kParameter:
            return b.Create("parameter");

        case SemanticTokenTypes::kVariable:
            return b.Create("variable");

        case SemanticTokenTypes::kProperty:
            return b.Create("property");

        case SemanticTokenTypes::kEnumMember:
            return b.Create("enumMember");

        case SemanticTokenTypes::kEvent:
            return b.Create("event");

        case SemanticTokenTypes::kFunction:
            return b.Create("function");

        case SemanticTokenTypes::kMethod:
            return b.Create("method");

        case SemanticTokenTypes::kMacro:
            return b.Create("macro");

        case SemanticTokenTypes::kKeyword:
            return b.Create("keyword");

        case SemanticTokenTypes::kModifier:
            return b.Create("modifier");

        case SemanticTokenTypes::kComment:
            return b.Create("comment");

        case SemanticTokenTypes::kString:
            return b.Create("string");

        case SemanticTokenTypes::kNumber:
            return b.Create("number");

        case SemanticTokenTypes::kRegexp:
            return b.Create("regexp");

        case SemanticTokenTypes::kOperator:
            return b.Create("operator");

        case SemanticTokenTypes::kDecorator:
            return b.Create("decorator");
    }
    return Failure{"invalid value for enum SemanticTokenTypes"};
}

Result<SuccessType> Decode(V& v, SemanticTokenModifiers& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "declaration") {
        out = SemanticTokenModifiers::kDeclaration;
        return Success;
    }
    if (val == "definition") {
        out = SemanticTokenModifiers::kDefinition;
        return Success;
    }
    if (val == "readonly") {
        out = SemanticTokenModifiers::kReadonly;
        return Success;
    }
    if (val == "static") {
        out = SemanticTokenModifiers::kStatic;
        return Success;
    }
    if (val == "deprecated") {
        out = SemanticTokenModifiers::kDeprecated;
        return Success;
    }
    if (val == "abstract") {
        out = SemanticTokenModifiers::kAbstract;
        return Success;
    }
    if (val == "async") {
        out = SemanticTokenModifiers::kAsync;
        return Success;
    }
    if (val == "modification") {
        out = SemanticTokenModifiers::kModification;
        return Success;
    }
    if (val == "documentation") {
        out = SemanticTokenModifiers::kDocumentation;
        return Success;
    }
    if (val == "defaultLibrary") {
        out = SemanticTokenModifiers::kDefaultLibrary;
        return Success;
    }
    return Failure{"invalid value for enum SemanticTokenModifiers"};
}

Result<const json::Value*> Encode(SemanticTokenModifiers in, json::Builder& b) {
    switch (in) {
        case SemanticTokenModifiers::kDeclaration:
            return b.Create("declaration");

        case SemanticTokenModifiers::kDefinition:
            return b.Create("definition");

        case SemanticTokenModifiers::kReadonly:
            return b.Create("readonly");

        case SemanticTokenModifiers::kStatic:
            return b.Create("static");

        case SemanticTokenModifiers::kDeprecated:
            return b.Create("deprecated");

        case SemanticTokenModifiers::kAbstract:
            return b.Create("abstract");

        case SemanticTokenModifiers::kAsync:
            return b.Create("async");

        case SemanticTokenModifiers::kModification:
            return b.Create("modification");

        case SemanticTokenModifiers::kDocumentation:
            return b.Create("documentation");

        case SemanticTokenModifiers::kDefaultLibrary:
            return b.Create("defaultLibrary");
    }
    return Failure{"invalid value for enum SemanticTokenModifiers"};
}

Result<SuccessType> Decode(V& v, DocumentDiagnosticReportKind& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "full") {
        out = DocumentDiagnosticReportKind::kFull;
        return Success;
    }
    if (val == "unchanged") {
        out = DocumentDiagnosticReportKind::kUnchanged;
        return Success;
    }
    return Failure{"invalid value for enum DocumentDiagnosticReportKind"};
}

Result<const json::Value*> Encode(DocumentDiagnosticReportKind in, json::Builder& b) {
    switch (in) {
        case DocumentDiagnosticReportKind::kFull:
            return b.Create("full");

        case DocumentDiagnosticReportKind::kUnchanged:
            return b.Create("unchanged");
    }
    return Failure{"invalid value for enum DocumentDiagnosticReportKind"};
}

Result<SuccessType> Decode(V& v, ErrorCodes& out) {
    Integer val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == -32700) {
        out = ErrorCodes::kParseError;
        return Success;
    }
    if (val == -32600) {
        out = ErrorCodes::kInvalidRequest;
        return Success;
    }
    if (val == -32601) {
        out = ErrorCodes::kMethodNotFound;
        return Success;
    }
    if (val == -32602) {
        out = ErrorCodes::kInvalidParams;
        return Success;
    }
    if (val == -32603) {
        out = ErrorCodes::kInternalError;
        return Success;
    }
    if (val == -32002) {
        out = ErrorCodes::kServerNotInitialized;
        return Success;
    }
    if (val == -32001) {
        out = ErrorCodes::kUnknownErrorCode;
        return Success;
    }
    return Failure{"invalid value for enum ErrorCodes"};
}

Result<const json::Value*> Encode(ErrorCodes in, json::Builder& b) {
    switch (in) {
        case ErrorCodes::kParseError:
            return b.Create(-32700);

        case ErrorCodes::kInvalidRequest:
            return b.Create(-32600);

        case ErrorCodes::kMethodNotFound:
            return b.Create(-32601);

        case ErrorCodes::kInvalidParams:
            return b.Create(-32602);

        case ErrorCodes::kInternalError:
            return b.Create(-32603);

        case ErrorCodes::kServerNotInitialized:
            return b.Create(-32002);

        case ErrorCodes::kUnknownErrorCode:
            return b.Create(-32001);
    }
    return Failure{"invalid value for enum ErrorCodes"};
}

Result<SuccessType> Decode(V& v, LSPErrorCodes& out) {
    Integer val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == -32803) {
        out = LSPErrorCodes::kRequestFailed;
        return Success;
    }
    if (val == -32802) {
        out = LSPErrorCodes::kServerCancelled;
        return Success;
    }
    if (val == -32801) {
        out = LSPErrorCodes::kContentModified;
        return Success;
    }
    if (val == -32800) {
        out = LSPErrorCodes::kRequestCancelled;
        return Success;
    }
    return Failure{"invalid value for enum LSPErrorCodes"};
}

Result<const json::Value*> Encode(LSPErrorCodes in, json::Builder& b) {
    switch (in) {
        case LSPErrorCodes::kRequestFailed:
            return b.Create(-32803);

        case LSPErrorCodes::kServerCancelled:
            return b.Create(-32802);

        case LSPErrorCodes::kContentModified:
            return b.Create(-32801);

        case LSPErrorCodes::kRequestCancelled:
            return b.Create(-32800);
    }
    return Failure{"invalid value for enum LSPErrorCodes"};
}

Result<SuccessType> Decode(V& v, FoldingRangeKind& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "comment") {
        out = FoldingRangeKind::kComment;
        return Success;
    }
    if (val == "imports") {
        out = FoldingRangeKind::kImports;
        return Success;
    }
    if (val == "region") {
        out = FoldingRangeKind::kRegion;
        return Success;
    }
    return Failure{"invalid value for enum FoldingRangeKind"};
}

Result<const json::Value*> Encode(FoldingRangeKind in, json::Builder& b) {
    switch (in) {
        case FoldingRangeKind::kComment:
            return b.Create("comment");

        case FoldingRangeKind::kImports:
            return b.Create("imports");

        case FoldingRangeKind::kRegion:
            return b.Create("region");
    }
    return Failure{"invalid value for enum FoldingRangeKind"};
}

Result<SuccessType> Decode(V& v, SymbolKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = SymbolKind::kFile;
        return Success;
    }
    if (val == 2) {
        out = SymbolKind::kModule;
        return Success;
    }
    if (val == 3) {
        out = SymbolKind::kNamespace;
        return Success;
    }
    if (val == 4) {
        out = SymbolKind::kPackage;
        return Success;
    }
    if (val == 5) {
        out = SymbolKind::kClass;
        return Success;
    }
    if (val == 6) {
        out = SymbolKind::kMethod;
        return Success;
    }
    if (val == 7) {
        out = SymbolKind::kProperty;
        return Success;
    }
    if (val == 8) {
        out = SymbolKind::kField;
        return Success;
    }
    if (val == 9) {
        out = SymbolKind::kConstructor;
        return Success;
    }
    if (val == 10) {
        out = SymbolKind::kEnum;
        return Success;
    }
    if (val == 11) {
        out = SymbolKind::kInterface;
        return Success;
    }
    if (val == 12) {
        out = SymbolKind::kFunction;
        return Success;
    }
    if (val == 13) {
        out = SymbolKind::kVariable;
        return Success;
    }
    if (val == 14) {
        out = SymbolKind::kConstant;
        return Success;
    }
    if (val == 15) {
        out = SymbolKind::kString;
        return Success;
    }
    if (val == 16) {
        out = SymbolKind::kNumber;
        return Success;
    }
    if (val == 17) {
        out = SymbolKind::kBoolean;
        return Success;
    }
    if (val == 18) {
        out = SymbolKind::kArray;
        return Success;
    }
    if (val == 19) {
        out = SymbolKind::kObject;
        return Success;
    }
    if (val == 20) {
        out = SymbolKind::kKey;
        return Success;
    }
    if (val == 21) {
        out = SymbolKind::kNull;
        return Success;
    }
    if (val == 22) {
        out = SymbolKind::kEnumMember;
        return Success;
    }
    if (val == 23) {
        out = SymbolKind::kStruct;
        return Success;
    }
    if (val == 24) {
        out = SymbolKind::kEvent;
        return Success;
    }
    if (val == 25) {
        out = SymbolKind::kOperator;
        return Success;
    }
    if (val == 26) {
        out = SymbolKind::kTypeParameter;
        return Success;
    }
    return Failure{"invalid value for enum SymbolKind"};
}

Result<const json::Value*> Encode(SymbolKind in, json::Builder& b) {
    switch (in) {
        case SymbolKind::kFile:
            return b.Create(1);

        case SymbolKind::kModule:
            return b.Create(2);

        case SymbolKind::kNamespace:
            return b.Create(3);

        case SymbolKind::kPackage:
            return b.Create(4);

        case SymbolKind::kClass:
            return b.Create(5);

        case SymbolKind::kMethod:
            return b.Create(6);

        case SymbolKind::kProperty:
            return b.Create(7);

        case SymbolKind::kField:
            return b.Create(8);

        case SymbolKind::kConstructor:
            return b.Create(9);

        case SymbolKind::kEnum:
            return b.Create(10);

        case SymbolKind::kInterface:
            return b.Create(11);

        case SymbolKind::kFunction:
            return b.Create(12);

        case SymbolKind::kVariable:
            return b.Create(13);

        case SymbolKind::kConstant:
            return b.Create(14);

        case SymbolKind::kString:
            return b.Create(15);

        case SymbolKind::kNumber:
            return b.Create(16);

        case SymbolKind::kBoolean:
            return b.Create(17);

        case SymbolKind::kArray:
            return b.Create(18);

        case SymbolKind::kObject:
            return b.Create(19);

        case SymbolKind::kKey:
            return b.Create(20);

        case SymbolKind::kNull:
            return b.Create(21);

        case SymbolKind::kEnumMember:
            return b.Create(22);

        case SymbolKind::kStruct:
            return b.Create(23);

        case SymbolKind::kEvent:
            return b.Create(24);

        case SymbolKind::kOperator:
            return b.Create(25);

        case SymbolKind::kTypeParameter:
            return b.Create(26);
    }
    return Failure{"invalid value for enum SymbolKind"};
}

Result<SuccessType> Decode(V& v, SymbolTag& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = SymbolTag::kDeprecated;
        return Success;
    }
    return Failure{"invalid value for enum SymbolTag"};
}

Result<const json::Value*> Encode(SymbolTag in, json::Builder& b) {
    switch (in) {
        case SymbolTag::kDeprecated:
            return b.Create(1);
    }
    return Failure{"invalid value for enum SymbolTag"};
}

Result<SuccessType> Decode(V& v, UniquenessLevel& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "document") {
        out = UniquenessLevel::kDocument;
        return Success;
    }
    if (val == "project") {
        out = UniquenessLevel::kProject;
        return Success;
    }
    if (val == "group") {
        out = UniquenessLevel::kGroup;
        return Success;
    }
    if (val == "scheme") {
        out = UniquenessLevel::kScheme;
        return Success;
    }
    if (val == "global") {
        out = UniquenessLevel::kGlobal;
        return Success;
    }
    return Failure{"invalid value for enum UniquenessLevel"};
}

Result<const json::Value*> Encode(UniquenessLevel in, json::Builder& b) {
    switch (in) {
        case UniquenessLevel::kDocument:
            return b.Create("document");

        case UniquenessLevel::kProject:
            return b.Create("project");

        case UniquenessLevel::kGroup:
            return b.Create("group");

        case UniquenessLevel::kScheme:
            return b.Create("scheme");

        case UniquenessLevel::kGlobal:
            return b.Create("global");
    }
    return Failure{"invalid value for enum UniquenessLevel"};
}

Result<SuccessType> Decode(V& v, MonikerKind& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "import") {
        out = MonikerKind::kImport;
        return Success;
    }
    if (val == "export") {
        out = MonikerKind::kExport;
        return Success;
    }
    if (val == "local") {
        out = MonikerKind::kLocal;
        return Success;
    }
    return Failure{"invalid value for enum MonikerKind"};
}

Result<const json::Value*> Encode(MonikerKind in, json::Builder& b) {
    switch (in) {
        case MonikerKind::kImport:
            return b.Create("import");

        case MonikerKind::kExport:
            return b.Create("export");

        case MonikerKind::kLocal:
            return b.Create("local");
    }
    return Failure{"invalid value for enum MonikerKind"};
}

Result<SuccessType> Decode(V& v, InlayHintKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = InlayHintKind::kType;
        return Success;
    }
    if (val == 2) {
        out = InlayHintKind::kParameter;
        return Success;
    }
    return Failure{"invalid value for enum InlayHintKind"};
}

Result<const json::Value*> Encode(InlayHintKind in, json::Builder& b) {
    switch (in) {
        case InlayHintKind::kType:
            return b.Create(1);

        case InlayHintKind::kParameter:
            return b.Create(2);
    }
    return Failure{"invalid value for enum InlayHintKind"};
}

Result<SuccessType> Decode(V& v, MessageType& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = MessageType::kError;
        return Success;
    }
    if (val == 2) {
        out = MessageType::kWarning;
        return Success;
    }
    if (val == 3) {
        out = MessageType::kInfo;
        return Success;
    }
    if (val == 4) {
        out = MessageType::kLog;
        return Success;
    }
    if (val == 5) {
        out = MessageType::kDebug;
        return Success;
    }
    return Failure{"invalid value for enum MessageType"};
}

Result<const json::Value*> Encode(MessageType in, json::Builder& b) {
    switch (in) {
        case MessageType::kError:
            return b.Create(1);

        case MessageType::kWarning:
            return b.Create(2);

        case MessageType::kInfo:
            return b.Create(3);

        case MessageType::kLog:
            return b.Create(4);

        case MessageType::kDebug:
            return b.Create(5);
    }
    return Failure{"invalid value for enum MessageType"};
}

Result<SuccessType> Decode(V& v, TextDocumentSyncKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 0) {
        out = TextDocumentSyncKind::kNone;
        return Success;
    }
    if (val == 1) {
        out = TextDocumentSyncKind::kFull;
        return Success;
    }
    if (val == 2) {
        out = TextDocumentSyncKind::kIncremental;
        return Success;
    }
    return Failure{"invalid value for enum TextDocumentSyncKind"};
}

Result<const json::Value*> Encode(TextDocumentSyncKind in, json::Builder& b) {
    switch (in) {
        case TextDocumentSyncKind::kNone:
            return b.Create(0);

        case TextDocumentSyncKind::kFull:
            return b.Create(1);

        case TextDocumentSyncKind::kIncremental:
            return b.Create(2);
    }
    return Failure{"invalid value for enum TextDocumentSyncKind"};
}

Result<SuccessType> Decode(V& v, TextDocumentSaveReason& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = TextDocumentSaveReason::kManual;
        return Success;
    }
    if (val == 2) {
        out = TextDocumentSaveReason::kAfterDelay;
        return Success;
    }
    if (val == 3) {
        out = TextDocumentSaveReason::kFocusOut;
        return Success;
    }
    return Failure{"invalid value for enum TextDocumentSaveReason"};
}

Result<const json::Value*> Encode(TextDocumentSaveReason in, json::Builder& b) {
    switch (in) {
        case TextDocumentSaveReason::kManual:
            return b.Create(1);

        case TextDocumentSaveReason::kAfterDelay:
            return b.Create(2);

        case TextDocumentSaveReason::kFocusOut:
            return b.Create(3);
    }
    return Failure{"invalid value for enum TextDocumentSaveReason"};
}

Result<SuccessType> Decode(V& v, CompletionItemKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = CompletionItemKind::kText;
        return Success;
    }
    if (val == 2) {
        out = CompletionItemKind::kMethod;
        return Success;
    }
    if (val == 3) {
        out = CompletionItemKind::kFunction;
        return Success;
    }
    if (val == 4) {
        out = CompletionItemKind::kConstructor;
        return Success;
    }
    if (val == 5) {
        out = CompletionItemKind::kField;
        return Success;
    }
    if (val == 6) {
        out = CompletionItemKind::kVariable;
        return Success;
    }
    if (val == 7) {
        out = CompletionItemKind::kClass;
        return Success;
    }
    if (val == 8) {
        out = CompletionItemKind::kInterface;
        return Success;
    }
    if (val == 9) {
        out = CompletionItemKind::kModule;
        return Success;
    }
    if (val == 10) {
        out = CompletionItemKind::kProperty;
        return Success;
    }
    if (val == 11) {
        out = CompletionItemKind::kUnit;
        return Success;
    }
    if (val == 12) {
        out = CompletionItemKind::kValue;
        return Success;
    }
    if (val == 13) {
        out = CompletionItemKind::kEnum;
        return Success;
    }
    if (val == 14) {
        out = CompletionItemKind::kKeyword;
        return Success;
    }
    if (val == 15) {
        out = CompletionItemKind::kSnippet;
        return Success;
    }
    if (val == 16) {
        out = CompletionItemKind::kColor;
        return Success;
    }
    if (val == 17) {
        out = CompletionItemKind::kFile;
        return Success;
    }
    if (val == 18) {
        out = CompletionItemKind::kReference;
        return Success;
    }
    if (val == 19) {
        out = CompletionItemKind::kFolder;
        return Success;
    }
    if (val == 20) {
        out = CompletionItemKind::kEnumMember;
        return Success;
    }
    if (val == 21) {
        out = CompletionItemKind::kConstant;
        return Success;
    }
    if (val == 22) {
        out = CompletionItemKind::kStruct;
        return Success;
    }
    if (val == 23) {
        out = CompletionItemKind::kEvent;
        return Success;
    }
    if (val == 24) {
        out = CompletionItemKind::kOperator;
        return Success;
    }
    if (val == 25) {
        out = CompletionItemKind::kTypeParameter;
        return Success;
    }
    return Failure{"invalid value for enum CompletionItemKind"};
}

Result<const json::Value*> Encode(CompletionItemKind in, json::Builder& b) {
    switch (in) {
        case CompletionItemKind::kText:
            return b.Create(1);

        case CompletionItemKind::kMethod:
            return b.Create(2);

        case CompletionItemKind::kFunction:
            return b.Create(3);

        case CompletionItemKind::kConstructor:
            return b.Create(4);

        case CompletionItemKind::kField:
            return b.Create(5);

        case CompletionItemKind::kVariable:
            return b.Create(6);

        case CompletionItemKind::kClass:
            return b.Create(7);

        case CompletionItemKind::kInterface:
            return b.Create(8);

        case CompletionItemKind::kModule:
            return b.Create(9);

        case CompletionItemKind::kProperty:
            return b.Create(10);

        case CompletionItemKind::kUnit:
            return b.Create(11);

        case CompletionItemKind::kValue:
            return b.Create(12);

        case CompletionItemKind::kEnum:
            return b.Create(13);

        case CompletionItemKind::kKeyword:
            return b.Create(14);

        case CompletionItemKind::kSnippet:
            return b.Create(15);

        case CompletionItemKind::kColor:
            return b.Create(16);

        case CompletionItemKind::kFile:
            return b.Create(17);

        case CompletionItemKind::kReference:
            return b.Create(18);

        case CompletionItemKind::kFolder:
            return b.Create(19);

        case CompletionItemKind::kEnumMember:
            return b.Create(20);

        case CompletionItemKind::kConstant:
            return b.Create(21);

        case CompletionItemKind::kStruct:
            return b.Create(22);

        case CompletionItemKind::kEvent:
            return b.Create(23);

        case CompletionItemKind::kOperator:
            return b.Create(24);

        case CompletionItemKind::kTypeParameter:
            return b.Create(25);
    }
    return Failure{"invalid value for enum CompletionItemKind"};
}

Result<SuccessType> Decode(V& v, CompletionItemTag& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = CompletionItemTag::kDeprecated;
        return Success;
    }
    return Failure{"invalid value for enum CompletionItemTag"};
}

Result<const json::Value*> Encode(CompletionItemTag in, json::Builder& b) {
    switch (in) {
        case CompletionItemTag::kDeprecated:
            return b.Create(1);
    }
    return Failure{"invalid value for enum CompletionItemTag"};
}

Result<SuccessType> Decode(V& v, InsertTextFormat& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = InsertTextFormat::kPlainText;
        return Success;
    }
    if (val == 2) {
        out = InsertTextFormat::kSnippet;
        return Success;
    }
    return Failure{"invalid value for enum InsertTextFormat"};
}

Result<const json::Value*> Encode(InsertTextFormat in, json::Builder& b) {
    switch (in) {
        case InsertTextFormat::kPlainText:
            return b.Create(1);

        case InsertTextFormat::kSnippet:
            return b.Create(2);
    }
    return Failure{"invalid value for enum InsertTextFormat"};
}

Result<SuccessType> Decode(V& v, InsertTextMode& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = InsertTextMode::kAsIs;
        return Success;
    }
    if (val == 2) {
        out = InsertTextMode::kAdjustIndentation;
        return Success;
    }
    return Failure{"invalid value for enum InsertTextMode"};
}

Result<const json::Value*> Encode(InsertTextMode in, json::Builder& b) {
    switch (in) {
        case InsertTextMode::kAsIs:
            return b.Create(1);

        case InsertTextMode::kAdjustIndentation:
            return b.Create(2);
    }
    return Failure{"invalid value for enum InsertTextMode"};
}

Result<SuccessType> Decode(V& v, DocumentHighlightKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = DocumentHighlightKind::kText;
        return Success;
    }
    if (val == 2) {
        out = DocumentHighlightKind::kRead;
        return Success;
    }
    if (val == 3) {
        out = DocumentHighlightKind::kWrite;
        return Success;
    }
    return Failure{"invalid value for enum DocumentHighlightKind"};
}

Result<const json::Value*> Encode(DocumentHighlightKind in, json::Builder& b) {
    switch (in) {
        case DocumentHighlightKind::kText:
            return b.Create(1);

        case DocumentHighlightKind::kRead:
            return b.Create(2);

        case DocumentHighlightKind::kWrite:
            return b.Create(3);
    }
    return Failure{"invalid value for enum DocumentHighlightKind"};
}

Result<SuccessType> Decode(V& v, CodeActionKind& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "") {
        out = CodeActionKind::kEmpty;
        return Success;
    }
    if (val == "quickfix") {
        out = CodeActionKind::kQuickFix;
        return Success;
    }
    if (val == "refactor") {
        out = CodeActionKind::kRefactor;
        return Success;
    }
    if (val == "refactor.extract") {
        out = CodeActionKind::kRefactorExtract;
        return Success;
    }
    if (val == "refactor.inline") {
        out = CodeActionKind::kRefactorInline;
        return Success;
    }
    if (val == "refactor.rewrite") {
        out = CodeActionKind::kRefactorRewrite;
        return Success;
    }
    if (val == "source") {
        out = CodeActionKind::kSource;
        return Success;
    }
    if (val == "source.organizeImports") {
        out = CodeActionKind::kSourceOrganizeImports;
        return Success;
    }
    if (val == "source.fixAll") {
        out = CodeActionKind::kSourceFixAll;
        return Success;
    }
    return Failure{"invalid value for enum CodeActionKind"};
}

Result<const json::Value*> Encode(CodeActionKind in, json::Builder& b) {
    switch (in) {
        case CodeActionKind::kEmpty:
            return b.Create("");

        case CodeActionKind::kQuickFix:
            return b.Create("quickfix");

        case CodeActionKind::kRefactor:
            return b.Create("refactor");

        case CodeActionKind::kRefactorExtract:
            return b.Create("refactor.extract");

        case CodeActionKind::kRefactorInline:
            return b.Create("refactor.inline");

        case CodeActionKind::kRefactorRewrite:
            return b.Create("refactor.rewrite");

        case CodeActionKind::kSource:
            return b.Create("source");

        case CodeActionKind::kSourceOrganizeImports:
            return b.Create("source.organizeImports");

        case CodeActionKind::kSourceFixAll:
            return b.Create("source.fixAll");
    }
    return Failure{"invalid value for enum CodeActionKind"};
}

Result<SuccessType> Decode(V& v, TraceValues& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "off") {
        out = TraceValues::kOff;
        return Success;
    }
    if (val == "messages") {
        out = TraceValues::kMessages;
        return Success;
    }
    if (val == "verbose") {
        out = TraceValues::kVerbose;
        return Success;
    }
    return Failure{"invalid value for enum TraceValues"};
}

Result<const json::Value*> Encode(TraceValues in, json::Builder& b) {
    switch (in) {
        case TraceValues::kOff:
            return b.Create("off");

        case TraceValues::kMessages:
            return b.Create("messages");

        case TraceValues::kVerbose:
            return b.Create("verbose");
    }
    return Failure{"invalid value for enum TraceValues"};
}

Result<SuccessType> Decode(V& v, MarkupKind& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "plaintext") {
        out = MarkupKind::kPlainText;
        return Success;
    }
    if (val == "markdown") {
        out = MarkupKind::kMarkdown;
        return Success;
    }
    return Failure{"invalid value for enum MarkupKind"};
}

Result<const json::Value*> Encode(MarkupKind in, json::Builder& b) {
    switch (in) {
        case MarkupKind::kPlainText:
            return b.Create("plaintext");

        case MarkupKind::kMarkdown:
            return b.Create("markdown");
    }
    return Failure{"invalid value for enum MarkupKind"};
}

Result<SuccessType> Decode(V& v, InlineCompletionTriggerKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 0) {
        out = InlineCompletionTriggerKind::kInvoked;
        return Success;
    }
    if (val == 1) {
        out = InlineCompletionTriggerKind::kAutomatic;
        return Success;
    }
    return Failure{"invalid value for enum InlineCompletionTriggerKind"};
}

Result<const json::Value*> Encode(InlineCompletionTriggerKind in, json::Builder& b) {
    switch (in) {
        case InlineCompletionTriggerKind::kInvoked:
            return b.Create(0);

        case InlineCompletionTriggerKind::kAutomatic:
            return b.Create(1);
    }
    return Failure{"invalid value for enum InlineCompletionTriggerKind"};
}

Result<SuccessType> Decode(V& v, PositionEncodingKind& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "utf-8") {
        out = PositionEncodingKind::kUTF8;
        return Success;
    }
    if (val == "utf-16") {
        out = PositionEncodingKind::kUTF16;
        return Success;
    }
    if (val == "utf-32") {
        out = PositionEncodingKind::kUTF32;
        return Success;
    }
    return Failure{"invalid value for enum PositionEncodingKind"};
}

Result<const json::Value*> Encode(PositionEncodingKind in, json::Builder& b) {
    switch (in) {
        case PositionEncodingKind::kUTF8:
            return b.Create("utf-8");

        case PositionEncodingKind::kUTF16:
            return b.Create("utf-16");

        case PositionEncodingKind::kUTF32:
            return b.Create("utf-32");
    }
    return Failure{"invalid value for enum PositionEncodingKind"};
}

Result<SuccessType> Decode(V& v, FileChangeType& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = FileChangeType::kCreated;
        return Success;
    }
    if (val == 2) {
        out = FileChangeType::kChanged;
        return Success;
    }
    if (val == 3) {
        out = FileChangeType::kDeleted;
        return Success;
    }
    return Failure{"invalid value for enum FileChangeType"};
}

Result<const json::Value*> Encode(FileChangeType in, json::Builder& b) {
    switch (in) {
        case FileChangeType::kCreated:
            return b.Create(1);

        case FileChangeType::kChanged:
            return b.Create(2);

        case FileChangeType::kDeleted:
            return b.Create(3);
    }
    return Failure{"invalid value for enum FileChangeType"};
}

Result<SuccessType> Decode(V& v, WatchKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = WatchKind::kCreate;
        return Success;
    }
    if (val == 2) {
        out = WatchKind::kChange;
        return Success;
    }
    if (val == 4) {
        out = WatchKind::kDelete;
        return Success;
    }
    return Failure{"invalid value for enum WatchKind"};
}

Result<const json::Value*> Encode(WatchKind in, json::Builder& b) {
    switch (in) {
        case WatchKind::kCreate:
            return b.Create(1);

        case WatchKind::kChange:
            return b.Create(2);

        case WatchKind::kDelete:
            return b.Create(4);
    }
    return Failure{"invalid value for enum WatchKind"};
}

Result<SuccessType> Decode(V& v, DiagnosticSeverity& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = DiagnosticSeverity::kError;
        return Success;
    }
    if (val == 2) {
        out = DiagnosticSeverity::kWarning;
        return Success;
    }
    if (val == 3) {
        out = DiagnosticSeverity::kInformation;
        return Success;
    }
    if (val == 4) {
        out = DiagnosticSeverity::kHint;
        return Success;
    }
    return Failure{"invalid value for enum DiagnosticSeverity"};
}

Result<const json::Value*> Encode(DiagnosticSeverity in, json::Builder& b) {
    switch (in) {
        case DiagnosticSeverity::kError:
            return b.Create(1);

        case DiagnosticSeverity::kWarning:
            return b.Create(2);

        case DiagnosticSeverity::kInformation:
            return b.Create(3);

        case DiagnosticSeverity::kHint:
            return b.Create(4);
    }
    return Failure{"invalid value for enum DiagnosticSeverity"};
}

Result<SuccessType> Decode(V& v, DiagnosticTag& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = DiagnosticTag::kUnnecessary;
        return Success;
    }
    if (val == 2) {
        out = DiagnosticTag::kDeprecated;
        return Success;
    }
    return Failure{"invalid value for enum DiagnosticTag"};
}

Result<const json::Value*> Encode(DiagnosticTag in, json::Builder& b) {
    switch (in) {
        case DiagnosticTag::kUnnecessary:
            return b.Create(1);

        case DiagnosticTag::kDeprecated:
            return b.Create(2);
    }
    return Failure{"invalid value for enum DiagnosticTag"};
}

Result<SuccessType> Decode(V& v, CompletionTriggerKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = CompletionTriggerKind::kInvoked;
        return Success;
    }
    if (val == 2) {
        out = CompletionTriggerKind::kTriggerCharacter;
        return Success;
    }
    if (val == 3) {
        out = CompletionTriggerKind::kTriggerForIncompleteCompletions;
        return Success;
    }
    return Failure{"invalid value for enum CompletionTriggerKind"};
}

Result<const json::Value*> Encode(CompletionTriggerKind in, json::Builder& b) {
    switch (in) {
        case CompletionTriggerKind::kInvoked:
            return b.Create(1);

        case CompletionTriggerKind::kTriggerCharacter:
            return b.Create(2);

        case CompletionTriggerKind::kTriggerForIncompleteCompletions:
            return b.Create(3);
    }
    return Failure{"invalid value for enum CompletionTriggerKind"};
}

Result<SuccessType> Decode(V& v, SignatureHelpTriggerKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = SignatureHelpTriggerKind::kInvoked;
        return Success;
    }
    if (val == 2) {
        out = SignatureHelpTriggerKind::kTriggerCharacter;
        return Success;
    }
    if (val == 3) {
        out = SignatureHelpTriggerKind::kContentChange;
        return Success;
    }
    return Failure{"invalid value for enum SignatureHelpTriggerKind"};
}

Result<const json::Value*> Encode(SignatureHelpTriggerKind in, json::Builder& b) {
    switch (in) {
        case SignatureHelpTriggerKind::kInvoked:
            return b.Create(1);

        case SignatureHelpTriggerKind::kTriggerCharacter:
            return b.Create(2);

        case SignatureHelpTriggerKind::kContentChange:
            return b.Create(3);
    }
    return Failure{"invalid value for enum SignatureHelpTriggerKind"};
}

Result<SuccessType> Decode(V& v, CodeActionTriggerKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = CodeActionTriggerKind::kInvoked;
        return Success;
    }
    if (val == 2) {
        out = CodeActionTriggerKind::kAutomatic;
        return Success;
    }
    return Failure{"invalid value for enum CodeActionTriggerKind"};
}

Result<const json::Value*> Encode(CodeActionTriggerKind in, json::Builder& b) {
    switch (in) {
        case CodeActionTriggerKind::kInvoked:
            return b.Create(1);

        case CodeActionTriggerKind::kAutomatic:
            return b.Create(2);
    }
    return Failure{"invalid value for enum CodeActionTriggerKind"};
}

Result<SuccessType> Decode(V& v, FileOperationPatternKind& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "file") {
        out = FileOperationPatternKind::kFile;
        return Success;
    }
    if (val == "folder") {
        out = FileOperationPatternKind::kFolder;
        return Success;
    }
    return Failure{"invalid value for enum FileOperationPatternKind"};
}

Result<const json::Value*> Encode(FileOperationPatternKind in, json::Builder& b) {
    switch (in) {
        case FileOperationPatternKind::kFile:
            return b.Create("file");

        case FileOperationPatternKind::kFolder:
            return b.Create("folder");
    }
    return Failure{"invalid value for enum FileOperationPatternKind"};
}

Result<SuccessType> Decode(V& v, NotebookCellKind& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = NotebookCellKind::kMarkup;
        return Success;
    }
    if (val == 2) {
        out = NotebookCellKind::kCode;
        return Success;
    }
    return Failure{"invalid value for enum NotebookCellKind"};
}

Result<const json::Value*> Encode(NotebookCellKind in, json::Builder& b) {
    switch (in) {
        case NotebookCellKind::kMarkup:
            return b.Create(1);

        case NotebookCellKind::kCode:
            return b.Create(2);
    }
    return Failure{"invalid value for enum NotebookCellKind"};
}

Result<SuccessType> Decode(V& v, ResourceOperationKind& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "create") {
        out = ResourceOperationKind::kCreate;
        return Success;
    }
    if (val == "rename") {
        out = ResourceOperationKind::kRename;
        return Success;
    }
    if (val == "delete") {
        out = ResourceOperationKind::kDelete;
        return Success;
    }
    return Failure{"invalid value for enum ResourceOperationKind"};
}

Result<const json::Value*> Encode(ResourceOperationKind in, json::Builder& b) {
    switch (in) {
        case ResourceOperationKind::kCreate:
            return b.Create("create");

        case ResourceOperationKind::kRename:
            return b.Create("rename");

        case ResourceOperationKind::kDelete:
            return b.Create("delete");
    }
    return Failure{"invalid value for enum ResourceOperationKind"};
}

Result<SuccessType> Decode(V& v, FailureHandlingKind& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "abort") {
        out = FailureHandlingKind::kAbort;
        return Success;
    }
    if (val == "transactional") {
        out = FailureHandlingKind::kTransactional;
        return Success;
    }
    if (val == "textOnlyTransactional") {
        out = FailureHandlingKind::kTextOnlyTransactional;
        return Success;
    }
    if (val == "undo") {
        out = FailureHandlingKind::kUndo;
        return Success;
    }
    return Failure{"invalid value for enum FailureHandlingKind"};
}

Result<const json::Value*> Encode(FailureHandlingKind in, json::Builder& b) {
    switch (in) {
        case FailureHandlingKind::kAbort:
            return b.Create("abort");

        case FailureHandlingKind::kTransactional:
            return b.Create("transactional");

        case FailureHandlingKind::kTextOnlyTransactional:
            return b.Create("textOnlyTransactional");

        case FailureHandlingKind::kUndo:
            return b.Create("undo");
    }
    return Failure{"invalid value for enum FailureHandlingKind"};
}

Result<SuccessType> Decode(V& v, PrepareSupportDefaultBehavior& out) {
    Uinteger val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == 1) {
        out = PrepareSupportDefaultBehavior::kIdentifier;
        return Success;
    }
    return Failure{"invalid value for enum PrepareSupportDefaultBehavior"};
}

Result<const json::Value*> Encode(PrepareSupportDefaultBehavior in, json::Builder& b) {
    switch (in) {
        case PrepareSupportDefaultBehavior::kIdentifier:
            return b.Create(1);
    }
    return Failure{"invalid value for enum PrepareSupportDefaultBehavior"};
}

Result<SuccessType> Decode(V& v, TokenFormat& out) {
    String val;
    auto res = Decode(v, val);
    if (res != Success) {
        return res.Failure();
    }

    if (val == "relative") {
        out = TokenFormat::kRelative;
        return Success;
    }
    return Failure{"invalid value for enum TokenFormat"};
}

Result<const json::Value*> Encode(TokenFormat in, json::Builder& b) {
    switch (in) {
        case TokenFormat::kRelative:
            return b.Create("relative");
    }
    return Failure{"invalid value for enum TokenFormat"};
}

bool operator==(const TextDocumentIdentifier& lhs, const TextDocumentIdentifier& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentIdentifier& lhs, const TextDocumentIdentifier& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TextDocumentIdentifier& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentIdentifier& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentIdentifier& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Position& lhs, const Position& rhs) {
    if (lhs.line != rhs.line) {
        return false;
    }
    if (lhs.character != rhs.character) {
        return false;
    }
    return true;
}

bool operator!=(const Position& lhs, const Position& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Position& out) {
    {
        auto member = v.Get("line");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.line); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("character");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.character); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Position& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.line, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"line", res.Get()});
    }
    {
        auto res = Encode(in.character, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"character", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Position& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentPositionParams& lhs, const TextDocumentPositionParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.position != rhs.position) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentPositionParams& lhs, const TextDocumentPositionParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TextDocumentPositionParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("position");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.position); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentPositionParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.position, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"position", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentPositionParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ImplementationParams& lhs, const ImplementationParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const ImplementationParams& lhs, const ImplementationParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ImplementationParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ImplementationParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ImplementationParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Range& lhs, const Range& rhs) {
    if (lhs.start != rhs.start) {
        return false;
    }
    if (lhs.end != rhs.end) {
        return false;
    }
    return true;
}

bool operator!=(const Range& lhs, const Range& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Range& out) {
    {
        auto member = v.Get("start");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.start); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("end");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.end); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Range& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.start, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"start", res.Get()});
    }
    {
        auto res = Encode(in.end, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"end", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Range& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Location& lhs, const Location& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    return true;
}

bool operator!=(const Location& lhs, const Location& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Location& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Location& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Location& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentRegistrationOptions& lhs,
                const TextDocumentRegistrationOptions& rhs) {
    if (lhs.document_selector != rhs.document_selector) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentRegistrationOptions& lhs,
                const TextDocumentRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TextDocumentRegistrationOptions& out) {
    {
        auto member = v.Get("documentSelector");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.document_selector); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.document_selector, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentSelector", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ImplementationOptions& lhs, const ImplementationOptions& rhs) {
    return true;
}

bool operator!=(const ImplementationOptions& lhs, const ImplementationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ImplementationOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ImplementationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ImplementationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ImplementationRegistrationOptions& lhs,
                const ImplementationRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const ImplementationOptions&>(lhs) !=
        static_cast<const ImplementationOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const ImplementationRegistrationOptions& lhs,
                const ImplementationRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ImplementationRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<ImplementationOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ImplementationRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const ImplementationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ImplementationRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeDefinitionParams& lhs, const TypeDefinitionParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const TypeDefinitionParams& lhs, const TypeDefinitionParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TypeDefinitionParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeDefinitionParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeDefinitionParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeDefinitionOptions& lhs, const TypeDefinitionOptions& rhs) {
    return true;
}

bool operator!=(const TypeDefinitionOptions& lhs, const TypeDefinitionOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TypeDefinitionOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeDefinitionOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeDefinitionOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeDefinitionRegistrationOptions& lhs,
                const TypeDefinitionRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const TypeDefinitionOptions&>(lhs) !=
        static_cast<const TypeDefinitionOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const TypeDefinitionRegistrationOptions& lhs,
                const TypeDefinitionRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TypeDefinitionRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<TypeDefinitionOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeDefinitionRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const TypeDefinitionOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeDefinitionRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceFolder& lhs, const WorkspaceFolder& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.name != rhs.name) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceFolder& lhs, const WorkspaceFolder& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkspaceFolder& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("name");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.name); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceFolder& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"name", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceFolder& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceFoldersChangeEvent& lhs, const WorkspaceFoldersChangeEvent& rhs) {
    if (lhs.added != rhs.added) {
        return false;
    }
    if (lhs.removed != rhs.removed) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceFoldersChangeEvent& lhs, const WorkspaceFoldersChangeEvent& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceFoldersChangeEvent& out) {
    {
        auto member = v.Get("added");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.added); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("removed");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.removed); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceFoldersChangeEvent& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.added, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"added", res.Get()});
    }
    {
        auto res = Encode(in.removed, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"removed", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceFoldersChangeEvent& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidChangeWorkspaceFoldersParams& lhs,
                const DidChangeWorkspaceFoldersParams& rhs) {
    if (lhs.event != rhs.event) {
        return false;
    }
    return true;
}

bool operator!=(const DidChangeWorkspaceFoldersParams& lhs,
                const DidChangeWorkspaceFoldersParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidChangeWorkspaceFoldersParams& out) {
    {
        auto member = v.Get("event");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.event); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidChangeWorkspaceFoldersParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.event, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"event", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidChangeWorkspaceFoldersParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ConfigurationItem& lhs, const ConfigurationItem& rhs) {
    if (lhs.scope_uri != rhs.scope_uri) {
        return false;
    }
    if (lhs.section != rhs.section) {
        return false;
    }
    return true;
}

bool operator!=(const ConfigurationItem& lhs, const ConfigurationItem& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ConfigurationItem& out) {
    if (v.Has("scopeUri")) {
        Uri val;
        auto member = v.Get("scopeUri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.scope_uri = std::move(val);
    }
    if (v.Has("section")) {
        String val;
        auto member = v.Get("section");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.section = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ConfigurationItem& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.scope_uri) {
        auto res = Encode(*in.scope_uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"scopeUri", res.Get()});
    }
    if (in.section) {
        auto res = Encode(*in.section, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"section", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ConfigurationItem& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ConfigurationParams& lhs, const ConfigurationParams& rhs) {
    if (lhs.items != rhs.items) {
        return false;
    }
    return true;
}

bool operator!=(const ConfigurationParams& lhs, const ConfigurationParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ConfigurationParams& out) {
    {
        auto member = v.Get("items");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.items); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ConfigurationParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.items, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"items", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ConfigurationParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentColorParams& lhs, const DocumentColorParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentColorParams& lhs, const DocumentColorParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentColorParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentColorParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentColorParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Color& lhs, const Color& rhs) {
    if (lhs.red != rhs.red) {
        return false;
    }
    if (lhs.green != rhs.green) {
        return false;
    }
    if (lhs.blue != rhs.blue) {
        return false;
    }
    if (lhs.alpha != rhs.alpha) {
        return false;
    }
    return true;
}

bool operator!=(const Color& lhs, const Color& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Color& out) {
    {
        auto member = v.Get("red");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.red); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("green");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.green); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("blue");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.blue); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("alpha");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.alpha); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Color& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.red, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"red", res.Get()});
    }
    {
        auto res = Encode(in.green, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"green", res.Get()});
    }
    {
        auto res = Encode(in.blue, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"blue", res.Get()});
    }
    {
        auto res = Encode(in.alpha, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"alpha", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Color& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ColorInformation& lhs, const ColorInformation& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.color != rhs.color) {
        return false;
    }
    return true;
}

bool operator!=(const ColorInformation& lhs, const ColorInformation& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ColorInformation& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("color");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.color); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ColorInformation& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.color, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"color", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ColorInformation& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentColorOptions& lhs, const DocumentColorOptions& rhs) {
    return true;
}

bool operator!=(const DocumentColorOptions& lhs, const DocumentColorOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentColorOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentColorOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentColorOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentColorRegistrationOptions& lhs,
                const DocumentColorRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const DocumentColorOptions&>(lhs) !=
        static_cast<const DocumentColorOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentColorRegistrationOptions& lhs,
                const DocumentColorRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentColorRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<DocumentColorOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentColorRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const DocumentColorOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentColorRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ColorPresentationParams& lhs, const ColorPresentationParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.color != rhs.color) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    return true;
}

bool operator!=(const ColorPresentationParams& lhs, const ColorPresentationParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ColorPresentationParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("color");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.color); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ColorPresentationParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.color, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"color", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ColorPresentationParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextEdit& lhs, const TextEdit& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.new_text != rhs.new_text) {
        return false;
    }
    return true;
}

bool operator!=(const TextEdit& lhs, const TextEdit& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TextEdit& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("newText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.new_text); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextEdit& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.new_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"newText", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextEdit& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ColorPresentation& lhs, const ColorPresentation& rhs) {
    if (lhs.label != rhs.label) {
        return false;
    }
    if (lhs.text_edit != rhs.text_edit) {
        return false;
    }
    if (lhs.additional_text_edits != rhs.additional_text_edits) {
        return false;
    }
    return true;
}

bool operator!=(const ColorPresentation& lhs, const ColorPresentation& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ColorPresentation& out) {
    {
        auto member = v.Get("label");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.label); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("textEdit")) {
        lsp::TextEdit val;
        auto member = v.Get("textEdit");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.text_edit = std::move(val);
    }
    if (v.Has("additionalTextEdits")) {
        std::vector<lsp::TextEdit> val;
        auto member = v.Get("additionalTextEdits");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.additional_text_edits = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ColorPresentation& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.label, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"label", res.Get()});
    }
    if (in.text_edit) {
        auto res = Encode(*in.text_edit, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textEdit", res.Get()});
    }
    if (in.additional_text_edits) {
        auto res = Encode(*in.additional_text_edits, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"additionalTextEdits", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ColorPresentation& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkDoneProgressOptions& lhs, const WorkDoneProgressOptions& rhs) {
    if (lhs.work_done_progress != rhs.work_done_progress) {
        return false;
    }
    return true;
}

bool operator!=(const WorkDoneProgressOptions& lhs, const WorkDoneProgressOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkDoneProgressOptions& out) {
    if (v.Has("workDoneProgress")) {
        Boolean val;
        auto member = v.Get("workDoneProgress");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.work_done_progress = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkDoneProgressOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.work_done_progress) {
        auto res = Encode(*in.work_done_progress, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workDoneProgress", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkDoneProgressOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FoldingRangeParams& lhs, const FoldingRangeParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    return true;
}

bool operator!=(const FoldingRangeParams& lhs, const FoldingRangeParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FoldingRangeParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FoldingRangeParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FoldingRangeParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FoldingRange& lhs, const FoldingRange& rhs) {
    if (lhs.start_line != rhs.start_line) {
        return false;
    }
    if (lhs.start_character != rhs.start_character) {
        return false;
    }
    if (lhs.end_line != rhs.end_line) {
        return false;
    }
    if (lhs.end_character != rhs.end_character) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.collapsed_text != rhs.collapsed_text) {
        return false;
    }
    return true;
}

bool operator!=(const FoldingRange& lhs, const FoldingRange& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FoldingRange& out) {
    {
        auto member = v.Get("startLine");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.start_line); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("startCharacter")) {
        Uinteger val;
        auto member = v.Get("startCharacter");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.start_character = std::move(val);
    }
    {
        auto member = v.Get("endLine");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.end_line); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("endCharacter")) {
        Uinteger val;
        auto member = v.Get("endCharacter");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.end_character = std::move(val);
    }
    if (v.Has("kind")) {
        lsp::FoldingRangeKind val;
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.kind = std::move(val);
    }
    if (v.Has("collapsedText")) {
        String val;
        auto member = v.Get("collapsedText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.collapsed_text = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FoldingRange& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(6);
    {
        auto res = Encode(in.start_line, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"startLine", res.Get()});
    }
    if (in.start_character) {
        auto res = Encode(*in.start_character, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"startCharacter", res.Get()});
    }
    {
        auto res = Encode(in.end_line, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"endLine", res.Get()});
    }
    if (in.end_character) {
        auto res = Encode(*in.end_character, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"endCharacter", res.Get()});
    }
    if (in.kind) {
        auto res = Encode(*in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    if (in.collapsed_text) {
        auto res = Encode(*in.collapsed_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"collapsedText", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FoldingRange& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FoldingRangeOptions& lhs, const FoldingRangeOptions& rhs) {
    return true;
}

bool operator!=(const FoldingRangeOptions& lhs, const FoldingRangeOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FoldingRangeOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FoldingRangeOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FoldingRangeOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FoldingRangeRegistrationOptions& lhs,
                const FoldingRangeRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const FoldingRangeOptions&>(lhs) !=
        static_cast<const FoldingRangeOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const FoldingRangeRegistrationOptions& lhs,
                const FoldingRangeRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] FoldingRangeRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<FoldingRangeOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FoldingRangeRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const FoldingRangeOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FoldingRangeRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DeclarationParams& lhs, const DeclarationParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DeclarationParams& lhs, const DeclarationParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DeclarationParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DeclarationParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DeclarationParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DeclarationOptions& lhs, const DeclarationOptions& rhs) {
    return true;
}

bool operator!=(const DeclarationOptions& lhs, const DeclarationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DeclarationOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DeclarationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DeclarationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DeclarationRegistrationOptions& lhs,
                const DeclarationRegistrationOptions& rhs) {
    if (static_cast<const DeclarationOptions&>(lhs) !=
        static_cast<const DeclarationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DeclarationRegistrationOptions& lhs,
                const DeclarationRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DeclarationRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<DeclarationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DeclarationRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const DeclarationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DeclarationRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SelectionRangeParams& lhs, const SelectionRangeParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.positions != rhs.positions) {
        return false;
    }
    return true;
}

bool operator!=(const SelectionRangeParams& lhs, const SelectionRangeParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SelectionRangeParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("positions");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.positions); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SelectionRangeParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.positions, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"positions", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SelectionRangeParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SelectionRange& lhs, const SelectionRange& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.parent != rhs.parent) {
        return false;
    }
    return true;
}

bool operator!=(const SelectionRange& lhs, const SelectionRange& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SelectionRange& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("parent")) {
        lsp::SelectionRange val;
        auto member = v.Get("parent");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.parent = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SelectionRange& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.parent) {
        auto res = Encode(*in.parent, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"parent", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SelectionRange& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SelectionRangeOptions& lhs, const SelectionRangeOptions& rhs) {
    return true;
}

bool operator!=(const SelectionRangeOptions& lhs, const SelectionRangeOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SelectionRangeOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SelectionRangeOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SelectionRangeOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SelectionRangeRegistrationOptions& lhs,
                const SelectionRangeRegistrationOptions& rhs) {
    if (static_cast<const SelectionRangeOptions&>(lhs) !=
        static_cast<const SelectionRangeOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const SelectionRangeRegistrationOptions& lhs,
                const SelectionRangeRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SelectionRangeRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<SelectionRangeOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SelectionRangeRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const SelectionRangeOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SelectionRangeRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkDoneProgressCreateParams& lhs, const WorkDoneProgressCreateParams& rhs) {
    if (lhs.token != rhs.token) {
        return false;
    }
    return true;
}

bool operator!=(const WorkDoneProgressCreateParams& lhs, const WorkDoneProgressCreateParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkDoneProgressCreateParams& out) {
    {
        auto member = v.Get("token");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.token); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkDoneProgressCreateParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.token, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"token", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkDoneProgressCreateParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkDoneProgressCancelParams& lhs, const WorkDoneProgressCancelParams& rhs) {
    if (lhs.token != rhs.token) {
        return false;
    }
    return true;
}

bool operator!=(const WorkDoneProgressCancelParams& lhs, const WorkDoneProgressCancelParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkDoneProgressCancelParams& out) {
    {
        auto member = v.Get("token");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.token); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkDoneProgressCancelParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.token, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"token", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkDoneProgressCancelParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CallHierarchyPrepareParams& lhs, const CallHierarchyPrepareParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const CallHierarchyPrepareParams& lhs, const CallHierarchyPrepareParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CallHierarchyPrepareParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CallHierarchyPrepareParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CallHierarchyPrepareParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CallHierarchyItem& lhs, const CallHierarchyItem& rhs) {
    if (lhs.name != rhs.name) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.tags != rhs.tags) {
        return false;
    }
    if (lhs.detail != rhs.detail) {
        return false;
    }
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.selection_range != rhs.selection_range) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const CallHierarchyItem& lhs, const CallHierarchyItem& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CallHierarchyItem& out) {
    {
        auto member = v.Get("name");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.name); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.kind); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("tags")) {
        std::vector<lsp::SymbolTag> val;
        auto member = v.Get("tags");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tags = std::move(val);
    }
    if (v.Has("detail")) {
        String val;
        auto member = v.Get("detail");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.detail = std::move(val);
    }
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("selectionRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.selection_range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CallHierarchyItem& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(8);
    {
        auto res = Encode(in.name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"name", res.Get()});
    }
    {
        auto res = Encode(in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    if (in.tags) {
        auto res = Encode(*in.tags, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tags", res.Get()});
    }
    if (in.detail) {
        auto res = Encode(*in.detail, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"detail", res.Get()});
    }
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.selection_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"selectionRange", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CallHierarchyItem& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CallHierarchyOptions& lhs, const CallHierarchyOptions& rhs) {
    return true;
}

bool operator!=(const CallHierarchyOptions& lhs, const CallHierarchyOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CallHierarchyOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CallHierarchyOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CallHierarchyOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CallHierarchyRegistrationOptions& lhs,
                const CallHierarchyRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const CallHierarchyOptions&>(lhs) !=
        static_cast<const CallHierarchyOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const CallHierarchyRegistrationOptions& lhs,
                const CallHierarchyRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CallHierarchyRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<CallHierarchyOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CallHierarchyRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const CallHierarchyOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CallHierarchyRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CallHierarchyIncomingCallsParams& lhs,
                const CallHierarchyIncomingCallsParams& rhs) {
    if (lhs.item != rhs.item) {
        return false;
    }
    return true;
}

bool operator!=(const CallHierarchyIncomingCallsParams& lhs,
                const CallHierarchyIncomingCallsParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CallHierarchyIncomingCallsParams& out) {
    {
        auto member = v.Get("item");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.item); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CallHierarchyIncomingCallsParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.item, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"item", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CallHierarchyIncomingCallsParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CallHierarchyIncomingCall& lhs, const CallHierarchyIncomingCall& rhs) {
    if (lhs.from != rhs.from) {
        return false;
    }
    if (lhs.from_ranges != rhs.from_ranges) {
        return false;
    }
    return true;
}

bool operator!=(const CallHierarchyIncomingCall& lhs, const CallHierarchyIncomingCall& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CallHierarchyIncomingCall& out) {
    {
        auto member = v.Get("from");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.from); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("fromRanges");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.from_ranges); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CallHierarchyIncomingCall& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.from, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"from", res.Get()});
    }
    {
        auto res = Encode(in.from_ranges, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"fromRanges", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CallHierarchyIncomingCall& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CallHierarchyOutgoingCallsParams& lhs,
                const CallHierarchyOutgoingCallsParams& rhs) {
    if (lhs.item != rhs.item) {
        return false;
    }
    return true;
}

bool operator!=(const CallHierarchyOutgoingCallsParams& lhs,
                const CallHierarchyOutgoingCallsParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CallHierarchyOutgoingCallsParams& out) {
    {
        auto member = v.Get("item");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.item); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CallHierarchyOutgoingCallsParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.item, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"item", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CallHierarchyOutgoingCallsParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CallHierarchyOutgoingCall& lhs, const CallHierarchyOutgoingCall& rhs) {
    if (lhs.to != rhs.to) {
        return false;
    }
    if (lhs.from_ranges != rhs.from_ranges) {
        return false;
    }
    return true;
}

bool operator!=(const CallHierarchyOutgoingCall& lhs, const CallHierarchyOutgoingCall& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CallHierarchyOutgoingCall& out) {
    {
        auto member = v.Get("to");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.to); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("fromRanges");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.from_ranges); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CallHierarchyOutgoingCall& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.to, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"to", res.Get()});
    }
    {
        auto res = Encode(in.from_ranges, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"fromRanges", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CallHierarchyOutgoingCall& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensParams& lhs, const SemanticTokensParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensParams& lhs, const SemanticTokensParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SemanticTokensParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokens& lhs, const SemanticTokens& rhs) {
    if (lhs.result_id != rhs.result_id) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokens& lhs, const SemanticTokens& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SemanticTokens& out) {
    if (v.Has("resultId")) {
        String val;
        auto member = v.Get("resultId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.result_id = std::move(val);
    }
    {
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.data); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokens& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.result_id) {
        auto res = Encode(*in.result_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resultId", res.Get()});
    }
    {
        auto res = Encode(in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokens& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensPartialResult& lhs, const SemanticTokensPartialResult& rhs) {
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensPartialResult& lhs, const SemanticTokensPartialResult& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SemanticTokensPartialResult& out) {
    {
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.data); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensPartialResult& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensPartialResult& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensLegend& lhs, const SemanticTokensLegend& rhs) {
    if (lhs.token_types != rhs.token_types) {
        return false;
    }
    if (lhs.token_modifiers != rhs.token_modifiers) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensLegend& lhs, const SemanticTokensLegend& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SemanticTokensLegend& out) {
    {
        auto member = v.Get("tokenTypes");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.token_types); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("tokenModifiers");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.token_modifiers); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensLegend& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.token_types, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tokenTypes", res.Get()});
    }
    {
        auto res = Encode(in.token_modifiers, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tokenModifiers", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensLegend& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensFullDelta& lhs, const SemanticTokensFullDelta& rhs) {
    if (lhs.delta != rhs.delta) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensFullDelta& lhs, const SemanticTokensFullDelta& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SemanticTokensFullDelta& out) {
    if (v.Has("delta")) {
        Boolean val;
        auto member = v.Get("delta");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.delta = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensFullDelta& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.delta) {
        auto res = Encode(*in.delta, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"delta", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensFullDelta& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensOptions& lhs, const SemanticTokensOptions& rhs) {
    if (lhs.legend != rhs.legend) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.full != rhs.full) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensOptions& lhs, const SemanticTokensOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SemanticTokensOptions& out) {
    {
        auto member = v.Get("legend");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.legend); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("range")) {
        OneOf<Boolean, lsp::SemanticTokensOptions::Range> val;
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.range = std::move(val);
    }
    if (v.Has("full")) {
        OneOf<Boolean, lsp::SemanticTokensFullDelta> val;
        auto member = v.Get("full");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.full = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.legend, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"legend", res.Get()});
    }
    if (in.range) {
        auto res = Encode(*in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.full) {
        auto res = Encode(*in.full, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"full", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}
bool operator==(const SemanticTokensOptions::Range& lhs, const SemanticTokensOptions::Range& rhs) {
    return true;
}

bool operator!=(const SemanticTokensOptions::Range& lhs, const SemanticTokensOptions::Range& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SemanticTokensOptions::Range& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensOptions::Range& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensOptions::Range& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensRegistrationOptions& lhs,
                const SemanticTokensRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const SemanticTokensOptions&>(lhs) !=
        static_cast<const SemanticTokensOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensRegistrationOptions& lhs,
                const SemanticTokensRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SemanticTokensRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<SemanticTokensOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const SemanticTokensOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensDeltaParams& lhs, const SemanticTokensDeltaParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.previous_result_id != rhs.previous_result_id) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensDeltaParams& lhs, const SemanticTokensDeltaParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SemanticTokensDeltaParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("previousResultId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.previous_result_id); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensDeltaParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.previous_result_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"previousResultId", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensDeltaParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensEdit& lhs, const SemanticTokensEdit& rhs) {
    if (lhs.start != rhs.start) {
        return false;
    }
    if (lhs.delete_count != rhs.delete_count) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensEdit& lhs, const SemanticTokensEdit& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SemanticTokensEdit& out) {
    {
        auto member = v.Get("start");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.start); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("deleteCount");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.delete_count); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("data")) {
        std::vector<Uinteger> val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensEdit& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.start, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"start", res.Get()});
    }
    {
        auto res = Encode(in.delete_count, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"deleteCount", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensEdit& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensDelta& lhs, const SemanticTokensDelta& rhs) {
    if (lhs.result_id != rhs.result_id) {
        return false;
    }
    if (lhs.edits != rhs.edits) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensDelta& lhs, const SemanticTokensDelta& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SemanticTokensDelta& out) {
    if (v.Has("resultId")) {
        String val;
        auto member = v.Get("resultId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.result_id = std::move(val);
    }
    {
        auto member = v.Get("edits");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.edits); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensDelta& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.result_id) {
        auto res = Encode(*in.result_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resultId", res.Get()});
    }
    {
        auto res = Encode(in.edits, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"edits", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensDelta& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensDeltaPartialResult& lhs,
                const SemanticTokensDeltaPartialResult& rhs) {
    if (lhs.edits != rhs.edits) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensDeltaPartialResult& lhs,
                const SemanticTokensDeltaPartialResult& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SemanticTokensDeltaPartialResult& out) {
    {
        auto member = v.Get("edits");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.edits); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensDeltaPartialResult& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.edits, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"edits", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensDeltaPartialResult& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensRangeParams& lhs, const SemanticTokensRangeParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensRangeParams& lhs, const SemanticTokensRangeParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SemanticTokensRangeParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensRangeParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensRangeParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ShowDocumentParams& lhs, const ShowDocumentParams& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.external != rhs.external) {
        return false;
    }
    if (lhs.take_focus != rhs.take_focus) {
        return false;
    }
    if (lhs.selection != rhs.selection) {
        return false;
    }
    return true;
}

bool operator!=(const ShowDocumentParams& lhs, const ShowDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ShowDocumentParams& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("external")) {
        Boolean val;
        auto member = v.Get("external");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.external = std::move(val);
    }
    if (v.Has("takeFocus")) {
        Boolean val;
        auto member = v.Get("takeFocus");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.take_focus = std::move(val);
    }
    if (v.Has("selection")) {
        lsp::Range val;
        auto member = v.Get("selection");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.selection = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ShowDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    if (in.external) {
        auto res = Encode(*in.external, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"external", res.Get()});
    }
    if (in.take_focus) {
        auto res = Encode(*in.take_focus, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"takeFocus", res.Get()});
    }
    if (in.selection) {
        auto res = Encode(*in.selection, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"selection", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ShowDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ShowDocumentResult& lhs, const ShowDocumentResult& rhs) {
    if (lhs.success != rhs.success) {
        return false;
    }
    return true;
}

bool operator!=(const ShowDocumentResult& lhs, const ShowDocumentResult& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ShowDocumentResult& out) {
    {
        auto member = v.Get("success");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.success); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ShowDocumentResult& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.success, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"success", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ShowDocumentResult& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const LinkedEditingRangeParams& lhs, const LinkedEditingRangeParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const LinkedEditingRangeParams& lhs, const LinkedEditingRangeParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] LinkedEditingRangeParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const LinkedEditingRangeParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const LinkedEditingRangeParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const LinkedEditingRanges& lhs, const LinkedEditingRanges& rhs) {
    if (lhs.ranges != rhs.ranges) {
        return false;
    }
    if (lhs.word_pattern != rhs.word_pattern) {
        return false;
    }
    return true;
}

bool operator!=(const LinkedEditingRanges& lhs, const LinkedEditingRanges& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] LinkedEditingRanges& out) {
    {
        auto member = v.Get("ranges");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.ranges); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("wordPattern")) {
        String val;
        auto member = v.Get("wordPattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.word_pattern = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const LinkedEditingRanges& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.ranges, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"ranges", res.Get()});
    }
    if (in.word_pattern) {
        auto res = Encode(*in.word_pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"wordPattern", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const LinkedEditingRanges& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const LinkedEditingRangeOptions& lhs, const LinkedEditingRangeOptions& rhs) {
    return true;
}

bool operator!=(const LinkedEditingRangeOptions& lhs, const LinkedEditingRangeOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] LinkedEditingRangeOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const LinkedEditingRangeOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const LinkedEditingRangeOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const LinkedEditingRangeRegistrationOptions& lhs,
                const LinkedEditingRangeRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const LinkedEditingRangeOptions&>(lhs) !=
        static_cast<const LinkedEditingRangeOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const LinkedEditingRangeRegistrationOptions& lhs,
                const LinkedEditingRangeRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] LinkedEditingRangeRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<LinkedEditingRangeOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const LinkedEditingRangeRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const LinkedEditingRangeOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const LinkedEditingRangeRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileCreate& lhs, const FileCreate& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    return true;
}

bool operator!=(const FileCreate& lhs, const FileCreate& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FileCreate& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileCreate& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileCreate& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CreateFilesParams& lhs, const CreateFilesParams& rhs) {
    if (lhs.files != rhs.files) {
        return false;
    }
    return true;
}

bool operator!=(const CreateFilesParams& lhs, const CreateFilesParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CreateFilesParams& out) {
    {
        auto member = v.Get("files");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.files); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CreateFilesParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.files, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"files", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CreateFilesParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ResourceOperation& lhs, const ResourceOperation& rhs) {
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.annotation_id != rhs.annotation_id) {
        return false;
    }
    return true;
}

bool operator!=(const ResourceOperation& lhs, const ResourceOperation& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ResourceOperation& out) {
    {
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.kind); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("annotationId")) {
        lsp::ChangeAnnotationIdentifier val;
        auto member = v.Get("annotationId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.annotation_id = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ResourceOperation& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    if (in.annotation_id) {
        auto res = Encode(*in.annotation_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"annotationId", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ResourceOperation& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DeleteFileOptions& lhs, const DeleteFileOptions& rhs) {
    if (lhs.recursive != rhs.recursive) {
        return false;
    }
    if (lhs.ignore_if_not_exists != rhs.ignore_if_not_exists) {
        return false;
    }
    return true;
}

bool operator!=(const DeleteFileOptions& lhs, const DeleteFileOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DeleteFileOptions& out) {
    if (v.Has("recursive")) {
        Boolean val;
        auto member = v.Get("recursive");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.recursive = std::move(val);
    }
    if (v.Has("ignoreIfNotExists")) {
        Boolean val;
        auto member = v.Get("ignoreIfNotExists");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.ignore_if_not_exists = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DeleteFileOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.recursive) {
        auto res = Encode(*in.recursive, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"recursive", res.Get()});
    }
    if (in.ignore_if_not_exists) {
        auto res = Encode(*in.ignore_if_not_exists, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"ignoreIfNotExists", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DeleteFileOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DeleteFile& lhs, const DeleteFile& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.options != rhs.options) {
        return false;
    }
    if (static_cast<const ResourceOperation&>(lhs) != static_cast<const ResourceOperation&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DeleteFile& lhs, const DeleteFile& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DeleteFile& out) {
    if (auto res = MatchKind(v, "delete"); res != Success) {
        return res.Failure();
    }
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("options")) {
        lsp::DeleteFileOptions val;
        auto member = v.Get("options");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.options = std::move(val);
    }
    if (auto res = Decode(v, static_cast<ResourceOperation&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DeleteFile& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    members.push_back(json::Builder::Member{"kind", b.String("delete")});
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    if (in.options) {
        auto res = Encode(*in.options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"options", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const ResourceOperation&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DeleteFile& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RenameFileOptions& lhs, const RenameFileOptions& rhs) {
    if (lhs.overwrite != rhs.overwrite) {
        return false;
    }
    if (lhs.ignore_if_exists != rhs.ignore_if_exists) {
        return false;
    }
    return true;
}

bool operator!=(const RenameFileOptions& lhs, const RenameFileOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] RenameFileOptions& out) {
    if (v.Has("overwrite")) {
        Boolean val;
        auto member = v.Get("overwrite");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.overwrite = std::move(val);
    }
    if (v.Has("ignoreIfExists")) {
        Boolean val;
        auto member = v.Get("ignoreIfExists");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.ignore_if_exists = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RenameFileOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.overwrite) {
        auto res = Encode(*in.overwrite, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"overwrite", res.Get()});
    }
    if (in.ignore_if_exists) {
        auto res = Encode(*in.ignore_if_exists, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"ignoreIfExists", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RenameFileOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RenameFile& lhs, const RenameFile& rhs) {
    if (lhs.old_uri != rhs.old_uri) {
        return false;
    }
    if (lhs.new_uri != rhs.new_uri) {
        return false;
    }
    if (lhs.options != rhs.options) {
        return false;
    }
    if (static_cast<const ResourceOperation&>(lhs) != static_cast<const ResourceOperation&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const RenameFile& lhs, const RenameFile& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] RenameFile& out) {
    if (auto res = MatchKind(v, "rename"); res != Success) {
        return res.Failure();
    }
    {
        auto member = v.Get("oldUri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.old_uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("newUri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.new_uri); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("options")) {
        lsp::RenameFileOptions val;
        auto member = v.Get("options");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.options = std::move(val);
    }
    if (auto res = Decode(v, static_cast<ResourceOperation&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RenameFile& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    members.push_back(json::Builder::Member{"kind", b.String("rename")});
    {
        auto res = Encode(in.old_uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"oldUri", res.Get()});
    }
    {
        auto res = Encode(in.new_uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"newUri", res.Get()});
    }
    if (in.options) {
        auto res = Encode(*in.options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"options", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const ResourceOperation&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RenameFile& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CreateFileOptions& lhs, const CreateFileOptions& rhs) {
    if (lhs.overwrite != rhs.overwrite) {
        return false;
    }
    if (lhs.ignore_if_exists != rhs.ignore_if_exists) {
        return false;
    }
    return true;
}

bool operator!=(const CreateFileOptions& lhs, const CreateFileOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CreateFileOptions& out) {
    if (v.Has("overwrite")) {
        Boolean val;
        auto member = v.Get("overwrite");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.overwrite = std::move(val);
    }
    if (v.Has("ignoreIfExists")) {
        Boolean val;
        auto member = v.Get("ignoreIfExists");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.ignore_if_exists = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CreateFileOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.overwrite) {
        auto res = Encode(*in.overwrite, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"overwrite", res.Get()});
    }
    if (in.ignore_if_exists) {
        auto res = Encode(*in.ignore_if_exists, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"ignoreIfExists", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CreateFileOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CreateFile& lhs, const CreateFile& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.options != rhs.options) {
        return false;
    }
    if (static_cast<const ResourceOperation&>(lhs) != static_cast<const ResourceOperation&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const CreateFile& lhs, const CreateFile& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CreateFile& out) {
    if (auto res = MatchKind(v, "create"); res != Success) {
        return res.Failure();
    }
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("options")) {
        lsp::CreateFileOptions val;
        auto member = v.Get("options");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.options = std::move(val);
    }
    if (auto res = Decode(v, static_cast<ResourceOperation&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CreateFile& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    members.push_back(json::Builder::Member{"kind", b.String("create")});
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    if (in.options) {
        auto res = Encode(*in.options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"options", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const ResourceOperation&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CreateFile& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const OptionalVersionedTextDocumentIdentifier& lhs,
                const OptionalVersionedTextDocumentIdentifier& rhs) {
    if (lhs.version != rhs.version) {
        return false;
    }
    if (static_cast<const TextDocumentIdentifier&>(lhs) !=
        static_cast<const TextDocumentIdentifier&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const OptionalVersionedTextDocumentIdentifier& lhs,
                const OptionalVersionedTextDocumentIdentifier& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] OptionalVersionedTextDocumentIdentifier& out) {
    {
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.version); res != Success) {
            return res.Failure();
        }
    }
    if (auto res = Decode(v, static_cast<TextDocumentIdentifier&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const OptionalVersionedTextDocumentIdentifier& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const TextDocumentIdentifier&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const OptionalVersionedTextDocumentIdentifier& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const AnnotatedTextEdit& lhs, const AnnotatedTextEdit& rhs) {
    if (lhs.annotation_id != rhs.annotation_id) {
        return false;
    }
    if (static_cast<const TextEdit&>(lhs) != static_cast<const TextEdit&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const AnnotatedTextEdit& lhs, const AnnotatedTextEdit& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] AnnotatedTextEdit& out) {
    {
        auto member = v.Get("annotationId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.annotation_id); res != Success) {
            return res.Failure();
        }
    }
    if (auto res = Decode(v, static_cast<TextEdit&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const AnnotatedTextEdit& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.annotation_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"annotationId", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const TextEdit&>(in), b, members); res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const AnnotatedTextEdit& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentEdit& lhs, const TextDocumentEdit& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.edits != rhs.edits) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentEdit& lhs, const TextDocumentEdit& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TextDocumentEdit& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("edits");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.edits); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentEdit& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.edits, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"edits", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentEdit& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ChangeAnnotation& lhs, const ChangeAnnotation& rhs) {
    if (lhs.label != rhs.label) {
        return false;
    }
    if (lhs.needs_confirmation != rhs.needs_confirmation) {
        return false;
    }
    if (lhs.description != rhs.description) {
        return false;
    }
    return true;
}

bool operator!=(const ChangeAnnotation& lhs, const ChangeAnnotation& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ChangeAnnotation& out) {
    {
        auto member = v.Get("label");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.label); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("needsConfirmation")) {
        Boolean val;
        auto member = v.Get("needsConfirmation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.needs_confirmation = std::move(val);
    }
    if (v.Has("description")) {
        String val;
        auto member = v.Get("description");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.description = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ChangeAnnotation& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.label, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"label", res.Get()});
    }
    if (in.needs_confirmation) {
        auto res = Encode(*in.needs_confirmation, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"needsConfirmation", res.Get()});
    }
    if (in.description) {
        auto res = Encode(*in.description, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"description", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ChangeAnnotation& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceEdit& lhs, const WorkspaceEdit& rhs) {
    if (lhs.changes != rhs.changes) {
        return false;
    }
    if (lhs.document_changes != rhs.document_changes) {
        return false;
    }
    if (lhs.change_annotations != rhs.change_annotations) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceEdit& lhs, const WorkspaceEdit& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkspaceEdit& out) {
    if (v.Has("changes")) {
        std::unordered_map<DocumentUri, std::vector<lsp::TextEdit>> val;
        auto member = v.Get("changes");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.changes = std::move(val);
    }
    if (v.Has("documentChanges")) {
        std::vector<OneOf<lsp::TextDocumentEdit, lsp::CreateFile, lsp::RenameFile, lsp::DeleteFile>>
            val;
        auto member = v.Get("documentChanges");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_changes = std::move(val);
    }
    if (v.Has("changeAnnotations")) {
        std::unordered_map<lsp::ChangeAnnotationIdentifier, lsp::ChangeAnnotation> val;
        auto member = v.Get("changeAnnotations");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.change_annotations = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceEdit& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.changes) {
        auto res = Encode(*in.changes, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"changes", res.Get()});
    }
    if (in.document_changes) {
        auto res = Encode(*in.document_changes, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentChanges", res.Get()});
    }
    if (in.change_annotations) {
        auto res = Encode(*in.change_annotations, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"changeAnnotations", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceEdit& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileOperationPatternOptions& lhs, const FileOperationPatternOptions& rhs) {
    if (lhs.ignore_case != rhs.ignore_case) {
        return false;
    }
    return true;
}

bool operator!=(const FileOperationPatternOptions& lhs, const FileOperationPatternOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] FileOperationPatternOptions& out) {
    if (v.Has("ignoreCase")) {
        Boolean val;
        auto member = v.Get("ignoreCase");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.ignore_case = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileOperationPatternOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.ignore_case) {
        auto res = Encode(*in.ignore_case, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"ignoreCase", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileOperationPatternOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileOperationPattern& lhs, const FileOperationPattern& rhs) {
    if (lhs.glob != rhs.glob) {
        return false;
    }
    if (lhs.matches != rhs.matches) {
        return false;
    }
    if (lhs.options != rhs.options) {
        return false;
    }
    return true;
}

bool operator!=(const FileOperationPattern& lhs, const FileOperationPattern& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FileOperationPattern& out) {
    {
        auto member = v.Get("glob");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.glob); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("matches")) {
        lsp::FileOperationPatternKind val;
        auto member = v.Get("matches");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.matches = std::move(val);
    }
    if (v.Has("options")) {
        lsp::FileOperationPatternOptions val;
        auto member = v.Get("options");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.options = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileOperationPattern& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.glob, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"glob", res.Get()});
    }
    if (in.matches) {
        auto res = Encode(*in.matches, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"matches", res.Get()});
    }
    if (in.options) {
        auto res = Encode(*in.options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"options", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileOperationPattern& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileOperationFilter& lhs, const FileOperationFilter& rhs) {
    if (lhs.scheme != rhs.scheme) {
        return false;
    }
    if (lhs.pattern != rhs.pattern) {
        return false;
    }
    return true;
}

bool operator!=(const FileOperationFilter& lhs, const FileOperationFilter& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FileOperationFilter& out) {
    if (v.Has("scheme")) {
        String val;
        auto member = v.Get("scheme");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.scheme = std::move(val);
    }
    {
        auto member = v.Get("pattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.pattern); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileOperationFilter& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.scheme) {
        auto res = Encode(*in.scheme, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"scheme", res.Get()});
    }
    {
        auto res = Encode(in.pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"pattern", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileOperationFilter& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileOperationRegistrationOptions& lhs,
                const FileOperationRegistrationOptions& rhs) {
    if (lhs.filters != rhs.filters) {
        return false;
    }
    return true;
}

bool operator!=(const FileOperationRegistrationOptions& lhs,
                const FileOperationRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] FileOperationRegistrationOptions& out) {
    {
        auto member = v.Get("filters");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.filters); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileOperationRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.filters, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"filters", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileOperationRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileRename& lhs, const FileRename& rhs) {
    if (lhs.old_uri != rhs.old_uri) {
        return false;
    }
    if (lhs.new_uri != rhs.new_uri) {
        return false;
    }
    return true;
}

bool operator!=(const FileRename& lhs, const FileRename& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FileRename& out) {
    {
        auto member = v.Get("oldUri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.old_uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("newUri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.new_uri); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileRename& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.old_uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"oldUri", res.Get()});
    }
    {
        auto res = Encode(in.new_uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"newUri", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileRename& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RenameFilesParams& lhs, const RenameFilesParams& rhs) {
    if (lhs.files != rhs.files) {
        return false;
    }
    return true;
}

bool operator!=(const RenameFilesParams& lhs, const RenameFilesParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] RenameFilesParams& out) {
    {
        auto member = v.Get("files");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.files); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RenameFilesParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.files, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"files", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RenameFilesParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileDelete& lhs, const FileDelete& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    return true;
}

bool operator!=(const FileDelete& lhs, const FileDelete& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FileDelete& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileDelete& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileDelete& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DeleteFilesParams& lhs, const DeleteFilesParams& rhs) {
    if (lhs.files != rhs.files) {
        return false;
    }
    return true;
}

bool operator!=(const DeleteFilesParams& lhs, const DeleteFilesParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DeleteFilesParams& out) {
    {
        auto member = v.Get("files");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.files); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DeleteFilesParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.files, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"files", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DeleteFilesParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const MonikerParams& lhs, const MonikerParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const MonikerParams& lhs, const MonikerParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] MonikerParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const MonikerParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const MonikerParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Moniker& lhs, const Moniker& rhs) {
    if (lhs.scheme != rhs.scheme) {
        return false;
    }
    if (lhs.identifier != rhs.identifier) {
        return false;
    }
    if (lhs.unique != rhs.unique) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    return true;
}

bool operator!=(const Moniker& lhs, const Moniker& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Moniker& out) {
    {
        auto member = v.Get("scheme");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.scheme); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("identifier");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.identifier); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("unique");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.unique); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("kind")) {
        lsp::MonikerKind val;
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.kind = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Moniker& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.scheme, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"scheme", res.Get()});
    }
    {
        auto res = Encode(in.identifier, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"identifier", res.Get()});
    }
    {
        auto res = Encode(in.unique, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"unique", res.Get()});
    }
    if (in.kind) {
        auto res = Encode(*in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Moniker& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const MonikerOptions& lhs, const MonikerOptions& rhs) {
    return true;
}

bool operator!=(const MonikerOptions& lhs, const MonikerOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] MonikerOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const MonikerOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const MonikerOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const MonikerRegistrationOptions& lhs, const MonikerRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const MonikerOptions&>(lhs) != static_cast<const MonikerOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const MonikerRegistrationOptions& lhs, const MonikerRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] MonikerRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<MonikerOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const MonikerRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const MonikerOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const MonikerRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeHierarchyPrepareParams& lhs, const TypeHierarchyPrepareParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const TypeHierarchyPrepareParams& lhs, const TypeHierarchyPrepareParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TypeHierarchyPrepareParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeHierarchyPrepareParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeHierarchyPrepareParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeHierarchyItem& lhs, const TypeHierarchyItem& rhs) {
    if (lhs.name != rhs.name) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.tags != rhs.tags) {
        return false;
    }
    if (lhs.detail != rhs.detail) {
        return false;
    }
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.selection_range != rhs.selection_range) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const TypeHierarchyItem& lhs, const TypeHierarchyItem& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TypeHierarchyItem& out) {
    {
        auto member = v.Get("name");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.name); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.kind); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("tags")) {
        std::vector<lsp::SymbolTag> val;
        auto member = v.Get("tags");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tags = std::move(val);
    }
    if (v.Has("detail")) {
        String val;
        auto member = v.Get("detail");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.detail = std::move(val);
    }
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("selectionRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.selection_range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeHierarchyItem& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(8);
    {
        auto res = Encode(in.name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"name", res.Get()});
    }
    {
        auto res = Encode(in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    if (in.tags) {
        auto res = Encode(*in.tags, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tags", res.Get()});
    }
    if (in.detail) {
        auto res = Encode(*in.detail, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"detail", res.Get()});
    }
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.selection_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"selectionRange", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeHierarchyItem& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeHierarchyOptions& lhs, const TypeHierarchyOptions& rhs) {
    return true;
}

bool operator!=(const TypeHierarchyOptions& lhs, const TypeHierarchyOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TypeHierarchyOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeHierarchyOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeHierarchyOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeHierarchyRegistrationOptions& lhs,
                const TypeHierarchyRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const TypeHierarchyOptions&>(lhs) !=
        static_cast<const TypeHierarchyOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const TypeHierarchyRegistrationOptions& lhs,
                const TypeHierarchyRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TypeHierarchyRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<TypeHierarchyOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeHierarchyRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const TypeHierarchyOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeHierarchyRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeHierarchySupertypesParams& lhs,
                const TypeHierarchySupertypesParams& rhs) {
    if (lhs.item != rhs.item) {
        return false;
    }
    return true;
}

bool operator!=(const TypeHierarchySupertypesParams& lhs,
                const TypeHierarchySupertypesParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TypeHierarchySupertypesParams& out) {
    {
        auto member = v.Get("item");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.item); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeHierarchySupertypesParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.item, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"item", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeHierarchySupertypesParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeHierarchySubtypesParams& lhs, const TypeHierarchySubtypesParams& rhs) {
    if (lhs.item != rhs.item) {
        return false;
    }
    return true;
}

bool operator!=(const TypeHierarchySubtypesParams& lhs, const TypeHierarchySubtypesParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TypeHierarchySubtypesParams& out) {
    {
        auto member = v.Get("item");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.item); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeHierarchySubtypesParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.item, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"item", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeHierarchySubtypesParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineValueContext& lhs, const InlineValueContext& rhs) {
    if (lhs.frame_id != rhs.frame_id) {
        return false;
    }
    if (lhs.stopped_location != rhs.stopped_location) {
        return false;
    }
    return true;
}

bool operator!=(const InlineValueContext& lhs, const InlineValueContext& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineValueContext& out) {
    {
        auto member = v.Get("frameId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.frame_id); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("stoppedLocation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.stopped_location); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineValueContext& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.frame_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"frameId", res.Get()});
    }
    {
        auto res = Encode(in.stopped_location, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"stoppedLocation", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineValueContext& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineValueParams& lhs, const InlineValueParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.context != rhs.context) {
        return false;
    }
    return true;
}

bool operator!=(const InlineValueParams& lhs, const InlineValueParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineValueParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("context");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.context); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineValueParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.context, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"context", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineValueParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineValueOptions& lhs, const InlineValueOptions& rhs) {
    return true;
}

bool operator!=(const InlineValueOptions& lhs, const InlineValueOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineValueOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineValueOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineValueOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineValueRegistrationOptions& lhs,
                const InlineValueRegistrationOptions& rhs) {
    if (static_cast<const InlineValueOptions&>(lhs) !=
        static_cast<const InlineValueOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const InlineValueRegistrationOptions& lhs,
                const InlineValueRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] InlineValueRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<InlineValueOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineValueRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const InlineValueOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineValueRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlayHintParams& lhs, const InlayHintParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    return true;
}

bool operator!=(const InlayHintParams& lhs, const InlayHintParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlayHintParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlayHintParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlayHintParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const MarkupContent& lhs, const MarkupContent& rhs) {
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.value != rhs.value) {
        return false;
    }
    return true;
}

bool operator!=(const MarkupContent& lhs, const MarkupContent& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] MarkupContent& out) {
    {
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.kind); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("value");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const MarkupContent& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    {
        auto res = Encode(in.value, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"value", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const MarkupContent& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Command& lhs, const Command& rhs) {
    if (lhs.title != rhs.title) {
        return false;
    }
    if (lhs.command != rhs.command) {
        return false;
    }
    if (lhs.arguments != rhs.arguments) {
        return false;
    }
    return true;
}

bool operator!=(const Command& lhs, const Command& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Command& out) {
    {
        auto member = v.Get("title");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.title); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("command");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.command); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("arguments")) {
        std::vector<lsp::LSPAny> val;
        auto member = v.Get("arguments");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.arguments = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Command& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.title, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"title", res.Get()});
    }
    {
        auto res = Encode(in.command, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"command", res.Get()});
    }
    if (in.arguments) {
        auto res = Encode(*in.arguments, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"arguments", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Command& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlayHintLabelPart& lhs, const InlayHintLabelPart& rhs) {
    if (lhs.value != rhs.value) {
        return false;
    }
    if (lhs.tooltip != rhs.tooltip) {
        return false;
    }
    if (lhs.location != rhs.location) {
        return false;
    }
    if (lhs.command != rhs.command) {
        return false;
    }
    return true;
}

bool operator!=(const InlayHintLabelPart& lhs, const InlayHintLabelPart& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlayHintLabelPart& out) {
    {
        auto member = v.Get("value");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("tooltip")) {
        OneOf<String, lsp::MarkupContent> val;
        auto member = v.Get("tooltip");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tooltip = std::move(val);
    }
    if (v.Has("location")) {
        lsp::Location val;
        auto member = v.Get("location");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.location = std::move(val);
    }
    if (v.Has("command")) {
        lsp::Command val;
        auto member = v.Get("command");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.command = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlayHintLabelPart& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.value, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"value", res.Get()});
    }
    if (in.tooltip) {
        auto res = Encode(*in.tooltip, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tooltip", res.Get()});
    }
    if (in.location) {
        auto res = Encode(*in.location, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"location", res.Get()});
    }
    if (in.command) {
        auto res = Encode(*in.command, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"command", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlayHintLabelPart& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlayHint& lhs, const InlayHint& rhs) {
    if (lhs.position != rhs.position) {
        return false;
    }
    if (lhs.label != rhs.label) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.text_edits != rhs.text_edits) {
        return false;
    }
    if (lhs.tooltip != rhs.tooltip) {
        return false;
    }
    if (lhs.padding_left != rhs.padding_left) {
        return false;
    }
    if (lhs.padding_right != rhs.padding_right) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const InlayHint& lhs, const InlayHint& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlayHint& out) {
    {
        auto member = v.Get("position");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.position); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("label");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.label); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("kind")) {
        lsp::InlayHintKind val;
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.kind = std::move(val);
    }
    if (v.Has("textEdits")) {
        std::vector<lsp::TextEdit> val;
        auto member = v.Get("textEdits");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.text_edits = std::move(val);
    }
    if (v.Has("tooltip")) {
        OneOf<String, lsp::MarkupContent> val;
        auto member = v.Get("tooltip");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tooltip = std::move(val);
    }
    if (v.Has("paddingLeft")) {
        Boolean val;
        auto member = v.Get("paddingLeft");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.padding_left = std::move(val);
    }
    if (v.Has("paddingRight")) {
        Boolean val;
        auto member = v.Get("paddingRight");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.padding_right = std::move(val);
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlayHint& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(8);
    {
        auto res = Encode(in.position, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"position", res.Get()});
    }
    {
        auto res = Encode(in.label, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"label", res.Get()});
    }
    if (in.kind) {
        auto res = Encode(*in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    if (in.text_edits) {
        auto res = Encode(*in.text_edits, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textEdits", res.Get()});
    }
    if (in.tooltip) {
        auto res = Encode(*in.tooltip, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tooltip", res.Get()});
    }
    if (in.padding_left) {
        auto res = Encode(*in.padding_left, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"paddingLeft", res.Get()});
    }
    if (in.padding_right) {
        auto res = Encode(*in.padding_right, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"paddingRight", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlayHint& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlayHintOptions& lhs, const InlayHintOptions& rhs) {
    if (lhs.resolve_provider != rhs.resolve_provider) {
        return false;
    }
    return true;
}

bool operator!=(const InlayHintOptions& lhs, const InlayHintOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlayHintOptions& out) {
    if (v.Has("resolveProvider")) {
        Boolean val;
        auto member = v.Get("resolveProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_provider = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlayHintOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.resolve_provider) {
        auto res = Encode(*in.resolve_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveProvider", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlayHintOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlayHintRegistrationOptions& lhs, const InlayHintRegistrationOptions& rhs) {
    if (static_cast<const InlayHintOptions&>(lhs) != static_cast<const InlayHintOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const InlayHintRegistrationOptions& lhs, const InlayHintRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] InlayHintRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<InlayHintOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlayHintRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const InlayHintOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlayHintRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentDiagnosticParams& lhs, const DocumentDiagnosticParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.identifier != rhs.identifier) {
        return false;
    }
    if (lhs.previous_result_id != rhs.previous_result_id) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentDiagnosticParams& lhs, const DocumentDiagnosticParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentDiagnosticParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("identifier")) {
        String val;
        auto member = v.Get("identifier");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.identifier = std::move(val);
    }
    if (v.Has("previousResultId")) {
        String val;
        auto member = v.Get("previousResultId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.previous_result_id = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentDiagnosticParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    if (in.identifier) {
        auto res = Encode(*in.identifier, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"identifier", res.Get()});
    }
    if (in.previous_result_id) {
        auto res = Encode(*in.previous_result_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"previousResultId", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentDiagnosticParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const UnchangedDocumentDiagnosticReport& lhs,
                const UnchangedDocumentDiagnosticReport& rhs) {
    if (lhs.result_id != rhs.result_id) {
        return false;
    }
    return true;
}

bool operator!=(const UnchangedDocumentDiagnosticReport& lhs,
                const UnchangedDocumentDiagnosticReport& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] UnchangedDocumentDiagnosticReport& out) {
    if (auto res = MatchKind(v, "unchanged"); res != Success) {
        return res.Failure();
    }
    {
        auto member = v.Get("resultId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.result_id); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const UnchangedDocumentDiagnosticReport& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    members.push_back(json::Builder::Member{"kind", b.String("unchanged")});
    {
        auto res = Encode(in.result_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resultId", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const UnchangedDocumentDiagnosticReport& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeDescription& lhs, const CodeDescription& rhs) {
    if (lhs.href != rhs.href) {
        return false;
    }
    return true;
}

bool operator!=(const CodeDescription& lhs, const CodeDescription& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CodeDescription& out) {
    {
        auto member = v.Get("href");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.href); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeDescription& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.href, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"href", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeDescription& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DiagnosticRelatedInformation& lhs, const DiagnosticRelatedInformation& rhs) {
    if (lhs.location != rhs.location) {
        return false;
    }
    if (lhs.message != rhs.message) {
        return false;
    }
    return true;
}

bool operator!=(const DiagnosticRelatedInformation& lhs, const DiagnosticRelatedInformation& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DiagnosticRelatedInformation& out) {
    {
        auto member = v.Get("location");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.location); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("message");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.message); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DiagnosticRelatedInformation& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.location, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"location", res.Get()});
    }
    {
        auto res = Encode(in.message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"message", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DiagnosticRelatedInformation& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Diagnostic& lhs, const Diagnostic& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.severity != rhs.severity) {
        return false;
    }
    if (lhs.code != rhs.code) {
        return false;
    }
    if (lhs.code_description != rhs.code_description) {
        return false;
    }
    if (lhs.source != rhs.source) {
        return false;
    }
    if (lhs.message != rhs.message) {
        return false;
    }
    if (lhs.tags != rhs.tags) {
        return false;
    }
    if (lhs.related_information != rhs.related_information) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const Diagnostic& lhs, const Diagnostic& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Diagnostic& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("severity")) {
        lsp::DiagnosticSeverity val;
        auto member = v.Get("severity");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.severity = std::move(val);
    }
    if (v.Has("code")) {
        OneOf<Integer, String> val;
        auto member = v.Get("code");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code = std::move(val);
    }
    if (v.Has("codeDescription")) {
        lsp::CodeDescription val;
        auto member = v.Get("codeDescription");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code_description = std::move(val);
    }
    if (v.Has("source")) {
        String val;
        auto member = v.Get("source");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.source = std::move(val);
    }
    {
        auto member = v.Get("message");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.message); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("tags")) {
        std::vector<lsp::DiagnosticTag> val;
        auto member = v.Get("tags");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tags = std::move(val);
    }
    if (v.Has("relatedInformation")) {
        std::vector<lsp::DiagnosticRelatedInformation> val;
        auto member = v.Get("relatedInformation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.related_information = std::move(val);
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Diagnostic& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(9);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.severity) {
        auto res = Encode(*in.severity, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"severity", res.Get()});
    }
    if (in.code) {
        auto res = Encode(*in.code, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"code", res.Get()});
    }
    if (in.code_description) {
        auto res = Encode(*in.code_description, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeDescription", res.Get()});
    }
    if (in.source) {
        auto res = Encode(*in.source, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"source", res.Get()});
    }
    {
        auto res = Encode(in.message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"message", res.Get()});
    }
    if (in.tags) {
        auto res = Encode(*in.tags, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tags", res.Get()});
    }
    if (in.related_information) {
        auto res = Encode(*in.related_information, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"relatedInformation", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Diagnostic& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FullDocumentDiagnosticReport& lhs, const FullDocumentDiagnosticReport& rhs) {
    if (lhs.result_id != rhs.result_id) {
        return false;
    }
    if (lhs.items != rhs.items) {
        return false;
    }
    return true;
}

bool operator!=(const FullDocumentDiagnosticReport& lhs, const FullDocumentDiagnosticReport& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] FullDocumentDiagnosticReport& out) {
    if (auto res = MatchKind(v, "full"); res != Success) {
        return res.Failure();
    }
    if (v.Has("resultId")) {
        String val;
        auto member = v.Get("resultId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.result_id = std::move(val);
    }
    {
        auto member = v.Get("items");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.items); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FullDocumentDiagnosticReport& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    members.push_back(json::Builder::Member{"kind", b.String("full")});
    if (in.result_id) {
        auto res = Encode(*in.result_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resultId", res.Get()});
    }
    {
        auto res = Encode(in.items, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"items", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FullDocumentDiagnosticReport& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentDiagnosticReportPartialResult& lhs,
                const DocumentDiagnosticReportPartialResult& rhs) {
    if (lhs.related_documents != rhs.related_documents) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentDiagnosticReportPartialResult& lhs,
                const DocumentDiagnosticReportPartialResult& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentDiagnosticReportPartialResult& out) {
    {
        auto member = v.Get("relatedDocuments");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.related_documents); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentDiagnosticReportPartialResult& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.related_documents, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"relatedDocuments", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentDiagnosticReportPartialResult& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DiagnosticServerCancellationData& lhs,
                const DiagnosticServerCancellationData& rhs) {
    if (lhs.retrigger_request != rhs.retrigger_request) {
        return false;
    }
    return true;
}

bool operator!=(const DiagnosticServerCancellationData& lhs,
                const DiagnosticServerCancellationData& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DiagnosticServerCancellationData& out) {
    {
        auto member = v.Get("retriggerRequest");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.retrigger_request); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DiagnosticServerCancellationData& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.retrigger_request, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"retriggerRequest", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DiagnosticServerCancellationData& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DiagnosticOptions& lhs, const DiagnosticOptions& rhs) {
    if (lhs.identifier != rhs.identifier) {
        return false;
    }
    if (lhs.inter_file_dependencies != rhs.inter_file_dependencies) {
        return false;
    }
    if (lhs.workspace_diagnostics != rhs.workspace_diagnostics) {
        return false;
    }
    return true;
}

bool operator!=(const DiagnosticOptions& lhs, const DiagnosticOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DiagnosticOptions& out) {
    if (v.Has("identifier")) {
        String val;
        auto member = v.Get("identifier");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.identifier = std::move(val);
    }
    {
        auto member = v.Get("interFileDependencies");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.inter_file_dependencies); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("workspaceDiagnostics");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.workspace_diagnostics); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DiagnosticOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.identifier) {
        auto res = Encode(*in.identifier, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"identifier", res.Get()});
    }
    {
        auto res = Encode(in.inter_file_dependencies, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"interFileDependencies", res.Get()});
    }
    {
        auto res = Encode(in.workspace_diagnostics, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workspaceDiagnostics", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DiagnosticOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DiagnosticRegistrationOptions& lhs,
                const DiagnosticRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const DiagnosticOptions&>(lhs) != static_cast<const DiagnosticOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DiagnosticRegistrationOptions& lhs,
                const DiagnosticRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DiagnosticRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<DiagnosticOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DiagnosticRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const DiagnosticOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DiagnosticRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const PreviousResultId& lhs, const PreviousResultId& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.value != rhs.value) {
        return false;
    }
    return true;
}

bool operator!=(const PreviousResultId& lhs, const PreviousResultId& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] PreviousResultId& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("value");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const PreviousResultId& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.value, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"value", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const PreviousResultId& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceDiagnosticParams& lhs, const WorkspaceDiagnosticParams& rhs) {
    if (lhs.identifier != rhs.identifier) {
        return false;
    }
    if (lhs.previous_result_ids != rhs.previous_result_ids) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceDiagnosticParams& lhs, const WorkspaceDiagnosticParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkspaceDiagnosticParams& out) {
    if (v.Has("identifier")) {
        String val;
        auto member = v.Get("identifier");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.identifier = std::move(val);
    }
    {
        auto member = v.Get("previousResultIds");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.previous_result_ids); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceDiagnosticParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.identifier) {
        auto res = Encode(*in.identifier, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"identifier", res.Get()});
    }
    {
        auto res = Encode(in.previous_result_ids, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"previousResultIds", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceDiagnosticParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceDiagnosticReport& lhs, const WorkspaceDiagnosticReport& rhs) {
    if (lhs.items != rhs.items) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceDiagnosticReport& lhs, const WorkspaceDiagnosticReport& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkspaceDiagnosticReport& out) {
    {
        auto member = v.Get("items");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.items); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceDiagnosticReport& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.items, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"items", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceDiagnosticReport& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceDiagnosticReportPartialResult& lhs,
                const WorkspaceDiagnosticReportPartialResult& rhs) {
    if (lhs.items != rhs.items) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceDiagnosticReportPartialResult& lhs,
                const WorkspaceDiagnosticReportPartialResult& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceDiagnosticReportPartialResult& out) {
    {
        auto member = v.Get("items");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.items); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceDiagnosticReportPartialResult& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.items, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"items", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceDiagnosticReportPartialResult& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ExecutionSummary& lhs, const ExecutionSummary& rhs) {
    if (lhs.execution_order != rhs.execution_order) {
        return false;
    }
    if (lhs.success != rhs.success) {
        return false;
    }
    return true;
}

bool operator!=(const ExecutionSummary& lhs, const ExecutionSummary& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ExecutionSummary& out) {
    {
        auto member = v.Get("executionOrder");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.execution_order); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("success")) {
        Boolean val;
        auto member = v.Get("success");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.success = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ExecutionSummary& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.execution_order, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"executionOrder", res.Get()});
    }
    if (in.success) {
        auto res = Encode(*in.success, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"success", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ExecutionSummary& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookCell& lhs, const NotebookCell& rhs) {
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.document != rhs.document) {
        return false;
    }
    if (lhs.metadata != rhs.metadata) {
        return false;
    }
    if (lhs.execution_summary != rhs.execution_summary) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookCell& lhs, const NotebookCell& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] NotebookCell& out) {
    {
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.kind); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("document");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.document); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("metadata")) {
        lsp::LSPObject val;
        auto member = v.Get("metadata");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.metadata = std::move(val);
    }
    if (v.Has("executionSummary")) {
        lsp::ExecutionSummary val;
        auto member = v.Get("executionSummary");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.execution_summary = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookCell& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    {
        auto res = Encode(in.document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"document", res.Get()});
    }
    if (in.metadata) {
        auto res = Encode(*in.metadata, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"metadata", res.Get()});
    }
    if (in.execution_summary) {
        auto res = Encode(*in.execution_summary, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"executionSummary", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookCell& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocument& lhs, const NotebookDocument& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.notebook_type != rhs.notebook_type) {
        return false;
    }
    if (lhs.version != rhs.version) {
        return false;
    }
    if (lhs.metadata != rhs.metadata) {
        return false;
    }
    if (lhs.cells != rhs.cells) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocument& lhs, const NotebookDocument& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] NotebookDocument& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("notebookType");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.notebook_type); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.version); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("metadata")) {
        lsp::LSPObject val;
        auto member = v.Get("metadata");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.metadata = std::move(val);
    }
    {
        auto member = v.Get("cells");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.cells); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocument& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(5);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.notebook_type, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookType", res.Get()});
    }
    {
        auto res = Encode(in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    if (in.metadata) {
        auto res = Encode(*in.metadata, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"metadata", res.Get()});
    }
    {
        auto res = Encode(in.cells, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cells", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocument& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentItem& lhs, const TextDocumentItem& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.language_id != rhs.language_id) {
        return false;
    }
    if (lhs.version != rhs.version) {
        return false;
    }
    if (lhs.text != rhs.text) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentItem& lhs, const TextDocumentItem& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TextDocumentItem& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("languageId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.language_id); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.version); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("text");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentItem& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.language_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"languageId", res.Get()});
    }
    {
        auto res = Encode(in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    {
        auto res = Encode(in.text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"text", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentItem& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidOpenNotebookDocumentParams& lhs,
                const DidOpenNotebookDocumentParams& rhs) {
    if (lhs.notebook_document != rhs.notebook_document) {
        return false;
    }
    if (lhs.cell_text_documents != rhs.cell_text_documents) {
        return false;
    }
    return true;
}

bool operator!=(const DidOpenNotebookDocumentParams& lhs,
                const DidOpenNotebookDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidOpenNotebookDocumentParams& out) {
    {
        auto member = v.Get("notebookDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.notebook_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("cellTextDocuments");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.cell_text_documents); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidOpenNotebookDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.notebook_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookDocument", res.Get()});
    }
    {
        auto res = Encode(in.cell_text_documents, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cellTextDocuments", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidOpenNotebookDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const VersionedNotebookDocumentIdentifier& lhs,
                const VersionedNotebookDocumentIdentifier& rhs) {
    if (lhs.version != rhs.version) {
        return false;
    }
    if (lhs.uri != rhs.uri) {
        return false;
    }
    return true;
}

bool operator!=(const VersionedNotebookDocumentIdentifier& lhs,
                const VersionedNotebookDocumentIdentifier& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] VersionedNotebookDocumentIdentifier& out) {
    {
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.version); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const VersionedNotebookDocumentIdentifier& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const VersionedNotebookDocumentIdentifier& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookCellArrayChange& lhs, const NotebookCellArrayChange& rhs) {
    if (lhs.start != rhs.start) {
        return false;
    }
    if (lhs.delete_count != rhs.delete_count) {
        return false;
    }
    if (lhs.cells != rhs.cells) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookCellArrayChange& lhs, const NotebookCellArrayChange& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] NotebookCellArrayChange& out) {
    {
        auto member = v.Get("start");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.start); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("deleteCount");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.delete_count); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("cells")) {
        std::vector<lsp::NotebookCell> val;
        auto member = v.Get("cells");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.cells = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookCellArrayChange& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.start, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"start", res.Get()});
    }
    {
        auto res = Encode(in.delete_count, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"deleteCount", res.Get()});
    }
    if (in.cells) {
        auto res = Encode(*in.cells, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cells", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookCellArrayChange& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentCellChangeStructure& lhs,
                const NotebookDocumentCellChangeStructure& rhs) {
    if (lhs.array != rhs.array) {
        return false;
    }
    if (lhs.did_open != rhs.did_open) {
        return false;
    }
    if (lhs.did_close != rhs.did_close) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentCellChangeStructure& lhs,
                const NotebookDocumentCellChangeStructure& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentCellChangeStructure& out) {
    {
        auto member = v.Get("array");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.array); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("didOpen")) {
        std::vector<lsp::TextDocumentItem> val;
        auto member = v.Get("didOpen");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_open = std::move(val);
    }
    if (v.Has("didClose")) {
        std::vector<lsp::TextDocumentIdentifier> val;
        auto member = v.Get("didClose");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_close = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentCellChangeStructure& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.array, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"array", res.Get()});
    }
    if (in.did_open) {
        auto res = Encode(*in.did_open, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didOpen", res.Get()});
    }
    if (in.did_close) {
        auto res = Encode(*in.did_close, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didClose", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentCellChangeStructure& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const VersionedTextDocumentIdentifier& lhs,
                const VersionedTextDocumentIdentifier& rhs) {
    if (lhs.version != rhs.version) {
        return false;
    }
    if (static_cast<const TextDocumentIdentifier&>(lhs) !=
        static_cast<const TextDocumentIdentifier&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const VersionedTextDocumentIdentifier& lhs,
                const VersionedTextDocumentIdentifier& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] VersionedTextDocumentIdentifier& out) {
    {
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.version); res != Success) {
            return res.Failure();
        }
    }
    if (auto res = Decode(v, static_cast<TextDocumentIdentifier&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const VersionedTextDocumentIdentifier& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const TextDocumentIdentifier&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const VersionedTextDocumentIdentifier& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentCellContentChanges& lhs,
                const NotebookDocumentCellContentChanges& rhs) {
    if (lhs.document != rhs.document) {
        return false;
    }
    if (lhs.changes != rhs.changes) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentCellContentChanges& lhs,
                const NotebookDocumentCellContentChanges& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentCellContentChanges& out) {
    {
        auto member = v.Get("document");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("changes");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.changes); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentCellContentChanges& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"document", res.Get()});
    }
    {
        auto res = Encode(in.changes, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"changes", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentCellContentChanges& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentCellChanges& lhs, const NotebookDocumentCellChanges& rhs) {
    if (lhs.structure != rhs.structure) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    if (lhs.text_content != rhs.text_content) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentCellChanges& lhs, const NotebookDocumentCellChanges& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentCellChanges& out) {
    if (v.Has("structure")) {
        lsp::NotebookDocumentCellChangeStructure val;
        auto member = v.Get("structure");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.structure = std::move(val);
    }
    if (v.Has("data")) {
        std::vector<lsp::NotebookCell> val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }
    if (v.Has("textContent")) {
        std::vector<lsp::NotebookDocumentCellContentChanges> val;
        auto member = v.Get("textContent");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.text_content = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentCellChanges& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.structure) {
        auto res = Encode(*in.structure, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"structure", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    if (in.text_content) {
        auto res = Encode(*in.text_content, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textContent", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentCellChanges& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentChangeEvent& lhs, const NotebookDocumentChangeEvent& rhs) {
    if (lhs.metadata != rhs.metadata) {
        return false;
    }
    if (lhs.cells != rhs.cells) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentChangeEvent& lhs, const NotebookDocumentChangeEvent& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentChangeEvent& out) {
    if (v.Has("metadata")) {
        lsp::LSPObject val;
        auto member = v.Get("metadata");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.metadata = std::move(val);
    }
    if (v.Has("cells")) {
        lsp::NotebookDocumentCellChanges val;
        auto member = v.Get("cells");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.cells = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentChangeEvent& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.metadata) {
        auto res = Encode(*in.metadata, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"metadata", res.Get()});
    }
    if (in.cells) {
        auto res = Encode(*in.cells, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cells", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentChangeEvent& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidChangeNotebookDocumentParams& lhs,
                const DidChangeNotebookDocumentParams& rhs) {
    if (lhs.notebook_document != rhs.notebook_document) {
        return false;
    }
    if (lhs.change != rhs.change) {
        return false;
    }
    return true;
}

bool operator!=(const DidChangeNotebookDocumentParams& lhs,
                const DidChangeNotebookDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidChangeNotebookDocumentParams& out) {
    {
        auto member = v.Get("notebookDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.notebook_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("change");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.change); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidChangeNotebookDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.notebook_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookDocument", res.Get()});
    }
    {
        auto res = Encode(in.change, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"change", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidChangeNotebookDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentIdentifier& lhs, const NotebookDocumentIdentifier& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentIdentifier& lhs, const NotebookDocumentIdentifier& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentIdentifier& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentIdentifier& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentIdentifier& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidSaveNotebookDocumentParams& lhs,
                const DidSaveNotebookDocumentParams& rhs) {
    if (lhs.notebook_document != rhs.notebook_document) {
        return false;
    }
    return true;
}

bool operator!=(const DidSaveNotebookDocumentParams& lhs,
                const DidSaveNotebookDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidSaveNotebookDocumentParams& out) {
    {
        auto member = v.Get("notebookDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.notebook_document); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidSaveNotebookDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.notebook_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidSaveNotebookDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidCloseNotebookDocumentParams& lhs,
                const DidCloseNotebookDocumentParams& rhs) {
    if (lhs.notebook_document != rhs.notebook_document) {
        return false;
    }
    if (lhs.cell_text_documents != rhs.cell_text_documents) {
        return false;
    }
    return true;
}

bool operator!=(const DidCloseNotebookDocumentParams& lhs,
                const DidCloseNotebookDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidCloseNotebookDocumentParams& out) {
    {
        auto member = v.Get("notebookDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.notebook_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("cellTextDocuments");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.cell_text_documents); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidCloseNotebookDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.notebook_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookDocument", res.Get()});
    }
    {
        auto res = Encode(in.cell_text_documents, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cellTextDocuments", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidCloseNotebookDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SelectedCompletionInfo& lhs, const SelectedCompletionInfo& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.text != rhs.text) {
        return false;
    }
    return true;
}

bool operator!=(const SelectedCompletionInfo& lhs, const SelectedCompletionInfo& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SelectedCompletionInfo& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("text");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SelectedCompletionInfo& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"text", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SelectedCompletionInfo& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineCompletionContext& lhs, const InlineCompletionContext& rhs) {
    if (lhs.trigger_kind != rhs.trigger_kind) {
        return false;
    }
    if (lhs.selected_completion_info != rhs.selected_completion_info) {
        return false;
    }
    return true;
}

bool operator!=(const InlineCompletionContext& lhs, const InlineCompletionContext& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineCompletionContext& out) {
    {
        auto member = v.Get("triggerKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.trigger_kind); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("selectedCompletionInfo")) {
        lsp::SelectedCompletionInfo val;
        auto member = v.Get("selectedCompletionInfo");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.selected_completion_info = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineCompletionContext& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.trigger_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"triggerKind", res.Get()});
    }
    if (in.selected_completion_info) {
        auto res = Encode(*in.selected_completion_info, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"selectedCompletionInfo", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineCompletionContext& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineCompletionParams& lhs, const InlineCompletionParams& rhs) {
    if (lhs.context != rhs.context) {
        return false;
    }
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const InlineCompletionParams& lhs, const InlineCompletionParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineCompletionParams& out) {
    {
        auto member = v.Get("context");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.context); res != Success) {
            return res.Failure();
        }
    }
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineCompletionParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.context, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"context", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineCompletionParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const StringValue& lhs, const StringValue& rhs) {
    if (lhs.value != rhs.value) {
        return false;
    }
    return true;
}

bool operator!=(const StringValue& lhs, const StringValue& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] StringValue& out) {
    if (auto res = MatchKind(v, "snippet"); res != Success) {
        return res.Failure();
    }
    {
        auto member = v.Get("value");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const StringValue& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    members.push_back(json::Builder::Member{"kind", b.String("snippet")});
    {
        auto res = Encode(in.value, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"value", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const StringValue& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineCompletionItem& lhs, const InlineCompletionItem& rhs) {
    if (lhs.insert_text != rhs.insert_text) {
        return false;
    }
    if (lhs.filter_text != rhs.filter_text) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.command != rhs.command) {
        return false;
    }
    return true;
}

bool operator!=(const InlineCompletionItem& lhs, const InlineCompletionItem& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineCompletionItem& out) {
    {
        auto member = v.Get("insertText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.insert_text); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("filterText")) {
        String val;
        auto member = v.Get("filterText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.filter_text = std::move(val);
    }
    if (v.Has("range")) {
        lsp::Range val;
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.range = std::move(val);
    }
    if (v.Has("command")) {
        lsp::Command val;
        auto member = v.Get("command");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.command = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineCompletionItem& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.insert_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertText", res.Get()});
    }
    if (in.filter_text) {
        auto res = Encode(*in.filter_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"filterText", res.Get()});
    }
    if (in.range) {
        auto res = Encode(*in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.command) {
        auto res = Encode(*in.command, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"command", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineCompletionItem& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineCompletionList& lhs, const InlineCompletionList& rhs) {
    if (lhs.items != rhs.items) {
        return false;
    }
    return true;
}

bool operator!=(const InlineCompletionList& lhs, const InlineCompletionList& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineCompletionList& out) {
    {
        auto member = v.Get("items");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.items); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineCompletionList& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.items, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"items", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineCompletionList& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineCompletionOptions& lhs, const InlineCompletionOptions& rhs) {
    return true;
}

bool operator!=(const InlineCompletionOptions& lhs, const InlineCompletionOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineCompletionOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineCompletionOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineCompletionOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineCompletionRegistrationOptions& lhs,
                const InlineCompletionRegistrationOptions& rhs) {
    if (static_cast<const InlineCompletionOptions&>(lhs) !=
        static_cast<const InlineCompletionOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const InlineCompletionRegistrationOptions& lhs,
                const InlineCompletionRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] InlineCompletionRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<InlineCompletionOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineCompletionRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const InlineCompletionOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineCompletionRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Registration& lhs, const Registration& rhs) {
    if (lhs.id != rhs.id) {
        return false;
    }
    if (lhs.method != rhs.method) {
        return false;
    }
    if (lhs.register_options != rhs.register_options) {
        return false;
    }
    return true;
}

bool operator!=(const Registration& lhs, const Registration& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Registration& out) {
    {
        auto member = v.Get("id");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.id); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("method");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.method); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("registerOptions")) {
        lsp::LSPAny val;
        auto member = v.Get("registerOptions");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.register_options = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Registration& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"id", res.Get()});
    }
    {
        auto res = Encode(in.method, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"method", res.Get()});
    }
    if (in.register_options) {
        auto res = Encode(*in.register_options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"registerOptions", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Registration& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RegistrationParams& lhs, const RegistrationParams& rhs) {
    if (lhs.registrations != rhs.registrations) {
        return false;
    }
    return true;
}

bool operator!=(const RegistrationParams& lhs, const RegistrationParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] RegistrationParams& out) {
    {
        auto member = v.Get("registrations");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.registrations); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RegistrationParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.registrations, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"registrations", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RegistrationParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Unregistration& lhs, const Unregistration& rhs) {
    if (lhs.id != rhs.id) {
        return false;
    }
    if (lhs.method != rhs.method) {
        return false;
    }
    return true;
}

bool operator!=(const Unregistration& lhs, const Unregistration& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Unregistration& out) {
    {
        auto member = v.Get("id");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.id); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("method");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.method); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Unregistration& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"id", res.Get()});
    }
    {
        auto res = Encode(in.method, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"method", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Unregistration& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const UnregistrationParams& lhs, const UnregistrationParams& rhs) {
    if (lhs.unregisterations != rhs.unregisterations) {
        return false;
    }
    return true;
}

bool operator!=(const UnregistrationParams& lhs, const UnregistrationParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] UnregistrationParams& out) {
    {
        auto member = v.Get("unregisterations");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.unregisterations); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const UnregistrationParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.unregisterations, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"unregisterations", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const UnregistrationParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientInfo& lhs, const ClientInfo& rhs) {
    if (lhs.name != rhs.name) {
        return false;
    }
    if (lhs.version != rhs.version) {
        return false;
    }
    return true;
}

bool operator!=(const ClientInfo& lhs, const ClientInfo& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ClientInfo& out) {
    {
        auto member = v.Get("name");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.name); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("version")) {
        String val;
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.version = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientInfo& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"name", res.Get()});
    }
    if (in.version) {
        auto res = Encode(*in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientInfo& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ChangeAnnotationsSupportOptions& lhs,
                const ChangeAnnotationsSupportOptions& rhs) {
    if (lhs.groups_on_label != rhs.groups_on_label) {
        return false;
    }
    return true;
}

bool operator!=(const ChangeAnnotationsSupportOptions& lhs,
                const ChangeAnnotationsSupportOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ChangeAnnotationsSupportOptions& out) {
    if (v.Has("groupsOnLabel")) {
        Boolean val;
        auto member = v.Get("groupsOnLabel");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.groups_on_label = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ChangeAnnotationsSupportOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.groups_on_label) {
        auto res = Encode(*in.groups_on_label, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"groupsOnLabel", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ChangeAnnotationsSupportOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceEditClientCapabilities& lhs,
                const WorkspaceEditClientCapabilities& rhs) {
    if (lhs.document_changes != rhs.document_changes) {
        return false;
    }
    if (lhs.resource_operations != rhs.resource_operations) {
        return false;
    }
    if (lhs.failure_handling != rhs.failure_handling) {
        return false;
    }
    if (lhs.normalizes_line_endings != rhs.normalizes_line_endings) {
        return false;
    }
    if (lhs.change_annotation_support != rhs.change_annotation_support) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceEditClientCapabilities& lhs,
                const WorkspaceEditClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceEditClientCapabilities& out) {
    if (v.Has("documentChanges")) {
        Boolean val;
        auto member = v.Get("documentChanges");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_changes = std::move(val);
    }
    if (v.Has("resourceOperations")) {
        std::vector<lsp::ResourceOperationKind> val;
        auto member = v.Get("resourceOperations");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resource_operations = std::move(val);
    }
    if (v.Has("failureHandling")) {
        lsp::FailureHandlingKind val;
        auto member = v.Get("failureHandling");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.failure_handling = std::move(val);
    }
    if (v.Has("normalizesLineEndings")) {
        Boolean val;
        auto member = v.Get("normalizesLineEndings");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.normalizes_line_endings = std::move(val);
    }
    if (v.Has("changeAnnotationSupport")) {
        lsp::ChangeAnnotationsSupportOptions val;
        auto member = v.Get("changeAnnotationSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.change_annotation_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceEditClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(5);
    if (in.document_changes) {
        auto res = Encode(*in.document_changes, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentChanges", res.Get()});
    }
    if (in.resource_operations) {
        auto res = Encode(*in.resource_operations, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resourceOperations", res.Get()});
    }
    if (in.failure_handling) {
        auto res = Encode(*in.failure_handling, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"failureHandling", res.Get()});
    }
    if (in.normalizes_line_endings) {
        auto res = Encode(*in.normalizes_line_endings, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"normalizesLineEndings", res.Get()});
    }
    if (in.change_annotation_support) {
        auto res = Encode(*in.change_annotation_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"changeAnnotationSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceEditClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidChangeConfigurationClientCapabilities& lhs,
                const DidChangeConfigurationClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const DidChangeConfigurationClientCapabilities& lhs,
                const DidChangeConfigurationClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidChangeConfigurationClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidChangeConfigurationClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const DidChangeConfigurationClientCapabilities& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidChangeWatchedFilesClientCapabilities& lhs,
                const DidChangeWatchedFilesClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.relative_pattern_support != rhs.relative_pattern_support) {
        return false;
    }
    return true;
}

bool operator!=(const DidChangeWatchedFilesClientCapabilities& lhs,
                const DidChangeWatchedFilesClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidChangeWatchedFilesClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("relativePatternSupport")) {
        Boolean val;
        auto member = v.Get("relativePatternSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.relative_pattern_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidChangeWatchedFilesClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.relative_pattern_support) {
        auto res = Encode(*in.relative_pattern_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"relativePatternSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const DidChangeWatchedFilesClientCapabilities& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientSymbolKindOptions& lhs, const ClientSymbolKindOptions& rhs) {
    if (lhs.value_set != rhs.value_set) {
        return false;
    }
    return true;
}

bool operator!=(const ClientSymbolKindOptions& lhs, const ClientSymbolKindOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ClientSymbolKindOptions& out) {
    if (v.Has("valueSet")) {
        std::vector<lsp::SymbolKind> val;
        auto member = v.Get("valueSet");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.value_set = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientSymbolKindOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.value_set) {
        auto res = Encode(*in.value_set, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"valueSet", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientSymbolKindOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientSymbolTagOptions& lhs, const ClientSymbolTagOptions& rhs) {
    if (lhs.value_set != rhs.value_set) {
        return false;
    }
    return true;
}

bool operator!=(const ClientSymbolTagOptions& lhs, const ClientSymbolTagOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ClientSymbolTagOptions& out) {
    {
        auto member = v.Get("valueSet");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value_set); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientSymbolTagOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.value_set, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"valueSet", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientSymbolTagOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientSymbolResolveOptions& lhs, const ClientSymbolResolveOptions& rhs) {
    if (lhs.properties != rhs.properties) {
        return false;
    }
    return true;
}

bool operator!=(const ClientSymbolResolveOptions& lhs, const ClientSymbolResolveOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientSymbolResolveOptions& out) {
    {
        auto member = v.Get("properties");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.properties); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientSymbolResolveOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.properties, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"properties", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientSymbolResolveOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceSymbolClientCapabilities& lhs,
                const WorkspaceSymbolClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.symbol_kind != rhs.symbol_kind) {
        return false;
    }
    if (lhs.tag_support != rhs.tag_support) {
        return false;
    }
    if (lhs.resolve_support != rhs.resolve_support) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceSymbolClientCapabilities& lhs,
                const WorkspaceSymbolClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceSymbolClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("symbolKind")) {
        lsp::ClientSymbolKindOptions val;
        auto member = v.Get("symbolKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.symbol_kind = std::move(val);
    }
    if (v.Has("tagSupport")) {
        lsp::ClientSymbolTagOptions val;
        auto member = v.Get("tagSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tag_support = std::move(val);
    }
    if (v.Has("resolveSupport")) {
        lsp::ClientSymbolResolveOptions val;
        auto member = v.Get("resolveSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceSymbolClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.symbol_kind) {
        auto res = Encode(*in.symbol_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"symbolKind", res.Get()});
    }
    if (in.tag_support) {
        auto res = Encode(*in.tag_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tagSupport", res.Get()});
    }
    if (in.resolve_support) {
        auto res = Encode(*in.resolve_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceSymbolClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ExecuteCommandClientCapabilities& lhs,
                const ExecuteCommandClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const ExecuteCommandClientCapabilities& lhs,
                const ExecuteCommandClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ExecuteCommandClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ExecuteCommandClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ExecuteCommandClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensWorkspaceClientCapabilities& lhs,
                const SemanticTokensWorkspaceClientCapabilities& rhs) {
    if (lhs.refresh_support != rhs.refresh_support) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensWorkspaceClientCapabilities& lhs,
                const SemanticTokensWorkspaceClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SemanticTokensWorkspaceClientCapabilities& out) {
    if (v.Has("refreshSupport")) {
        Boolean val;
        auto member = v.Get("refreshSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.refresh_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensWorkspaceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.refresh_support) {
        auto res = Encode(*in.refresh_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"refreshSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const SemanticTokensWorkspaceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeLensWorkspaceClientCapabilities& lhs,
                const CodeLensWorkspaceClientCapabilities& rhs) {
    if (lhs.refresh_support != rhs.refresh_support) {
        return false;
    }
    return true;
}

bool operator!=(const CodeLensWorkspaceClientCapabilities& lhs,
                const CodeLensWorkspaceClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CodeLensWorkspaceClientCapabilities& out) {
    if (v.Has("refreshSupport")) {
        Boolean val;
        auto member = v.Get("refreshSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.refresh_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeLensWorkspaceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.refresh_support) {
        auto res = Encode(*in.refresh_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"refreshSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeLensWorkspaceClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileOperationClientCapabilities& lhs,
                const FileOperationClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.did_create != rhs.did_create) {
        return false;
    }
    if (lhs.will_create != rhs.will_create) {
        return false;
    }
    if (lhs.did_rename != rhs.did_rename) {
        return false;
    }
    if (lhs.will_rename != rhs.will_rename) {
        return false;
    }
    if (lhs.did_delete != rhs.did_delete) {
        return false;
    }
    if (lhs.will_delete != rhs.will_delete) {
        return false;
    }
    return true;
}

bool operator!=(const FileOperationClientCapabilities& lhs,
                const FileOperationClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] FileOperationClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("didCreate")) {
        Boolean val;
        auto member = v.Get("didCreate");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_create = std::move(val);
    }
    if (v.Has("willCreate")) {
        Boolean val;
        auto member = v.Get("willCreate");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_create = std::move(val);
    }
    if (v.Has("didRename")) {
        Boolean val;
        auto member = v.Get("didRename");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_rename = std::move(val);
    }
    if (v.Has("willRename")) {
        Boolean val;
        auto member = v.Get("willRename");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_rename = std::move(val);
    }
    if (v.Has("didDelete")) {
        Boolean val;
        auto member = v.Get("didDelete");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_delete = std::move(val);
    }
    if (v.Has("willDelete")) {
        Boolean val;
        auto member = v.Get("willDelete");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_delete = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileOperationClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(7);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.did_create) {
        auto res = Encode(*in.did_create, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didCreate", res.Get()});
    }
    if (in.will_create) {
        auto res = Encode(*in.will_create, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willCreate", res.Get()});
    }
    if (in.did_rename) {
        auto res = Encode(*in.did_rename, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didRename", res.Get()});
    }
    if (in.will_rename) {
        auto res = Encode(*in.will_rename, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willRename", res.Get()});
    }
    if (in.did_delete) {
        auto res = Encode(*in.did_delete, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didDelete", res.Get()});
    }
    if (in.will_delete) {
        auto res = Encode(*in.will_delete, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willDelete", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileOperationClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineValueWorkspaceClientCapabilities& lhs,
                const InlineValueWorkspaceClientCapabilities& rhs) {
    if (lhs.refresh_support != rhs.refresh_support) {
        return false;
    }
    return true;
}

bool operator!=(const InlineValueWorkspaceClientCapabilities& lhs,
                const InlineValueWorkspaceClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] InlineValueWorkspaceClientCapabilities& out) {
    if (v.Has("refreshSupport")) {
        Boolean val;
        auto member = v.Get("refreshSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.refresh_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineValueWorkspaceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.refresh_support) {
        auto res = Encode(*in.refresh_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"refreshSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineValueWorkspaceClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlayHintWorkspaceClientCapabilities& lhs,
                const InlayHintWorkspaceClientCapabilities& rhs) {
    if (lhs.refresh_support != rhs.refresh_support) {
        return false;
    }
    return true;
}

bool operator!=(const InlayHintWorkspaceClientCapabilities& lhs,
                const InlayHintWorkspaceClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] InlayHintWorkspaceClientCapabilities& out) {
    if (v.Has("refreshSupport")) {
        Boolean val;
        auto member = v.Get("refreshSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.refresh_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlayHintWorkspaceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.refresh_support) {
        auto res = Encode(*in.refresh_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"refreshSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlayHintWorkspaceClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DiagnosticWorkspaceClientCapabilities& lhs,
                const DiagnosticWorkspaceClientCapabilities& rhs) {
    if (lhs.refresh_support != rhs.refresh_support) {
        return false;
    }
    return true;
}

bool operator!=(const DiagnosticWorkspaceClientCapabilities& lhs,
                const DiagnosticWorkspaceClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DiagnosticWorkspaceClientCapabilities& out) {
    if (v.Has("refreshSupport")) {
        Boolean val;
        auto member = v.Get("refreshSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.refresh_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DiagnosticWorkspaceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.refresh_support) {
        auto res = Encode(*in.refresh_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"refreshSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DiagnosticWorkspaceClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FoldingRangeWorkspaceClientCapabilities& lhs,
                const FoldingRangeWorkspaceClientCapabilities& rhs) {
    if (lhs.refresh_support != rhs.refresh_support) {
        return false;
    }
    return true;
}

bool operator!=(const FoldingRangeWorkspaceClientCapabilities& lhs,
                const FoldingRangeWorkspaceClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] FoldingRangeWorkspaceClientCapabilities& out) {
    if (v.Has("refreshSupport")) {
        Boolean val;
        auto member = v.Get("refreshSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.refresh_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FoldingRangeWorkspaceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.refresh_support) {
        auto res = Encode(*in.refresh_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"refreshSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const FoldingRangeWorkspaceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceClientCapabilities& lhs, const WorkspaceClientCapabilities& rhs) {
    if (lhs.apply_edit != rhs.apply_edit) {
        return false;
    }
    if (lhs.workspace_edit != rhs.workspace_edit) {
        return false;
    }
    if (lhs.did_change_configuration != rhs.did_change_configuration) {
        return false;
    }
    if (lhs.did_change_watched_files != rhs.did_change_watched_files) {
        return false;
    }
    if (lhs.symbol != rhs.symbol) {
        return false;
    }
    if (lhs.execute_command != rhs.execute_command) {
        return false;
    }
    if (lhs.workspace_folders != rhs.workspace_folders) {
        return false;
    }
    if (lhs.configuration != rhs.configuration) {
        return false;
    }
    if (lhs.semantic_tokens != rhs.semantic_tokens) {
        return false;
    }
    if (lhs.code_lens != rhs.code_lens) {
        return false;
    }
    if (lhs.file_operations != rhs.file_operations) {
        return false;
    }
    if (lhs.inline_value != rhs.inline_value) {
        return false;
    }
    if (lhs.inlay_hint != rhs.inlay_hint) {
        return false;
    }
    if (lhs.diagnostics != rhs.diagnostics) {
        return false;
    }
    if (lhs.folding_range != rhs.folding_range) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceClientCapabilities& lhs, const WorkspaceClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceClientCapabilities& out) {
    if (v.Has("applyEdit")) {
        Boolean val;
        auto member = v.Get("applyEdit");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.apply_edit = std::move(val);
    }
    if (v.Has("workspaceEdit")) {
        lsp::WorkspaceEditClientCapabilities val;
        auto member = v.Get("workspaceEdit");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.workspace_edit = std::move(val);
    }
    if (v.Has("didChangeConfiguration")) {
        lsp::DidChangeConfigurationClientCapabilities val;
        auto member = v.Get("didChangeConfiguration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_change_configuration = std::move(val);
    }
    if (v.Has("didChangeWatchedFiles")) {
        lsp::DidChangeWatchedFilesClientCapabilities val;
        auto member = v.Get("didChangeWatchedFiles");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_change_watched_files = std::move(val);
    }
    if (v.Has("symbol")) {
        lsp::WorkspaceSymbolClientCapabilities val;
        auto member = v.Get("symbol");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.symbol = std::move(val);
    }
    if (v.Has("executeCommand")) {
        lsp::ExecuteCommandClientCapabilities val;
        auto member = v.Get("executeCommand");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.execute_command = std::move(val);
    }
    if (v.Has("workspaceFolders")) {
        Boolean val;
        auto member = v.Get("workspaceFolders");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.workspace_folders = std::move(val);
    }
    if (v.Has("configuration")) {
        Boolean val;
        auto member = v.Get("configuration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.configuration = std::move(val);
    }
    if (v.Has("semanticTokens")) {
        lsp::SemanticTokensWorkspaceClientCapabilities val;
        auto member = v.Get("semanticTokens");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.semantic_tokens = std::move(val);
    }
    if (v.Has("codeLens")) {
        lsp::CodeLensWorkspaceClientCapabilities val;
        auto member = v.Get("codeLens");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code_lens = std::move(val);
    }
    if (v.Has("fileOperations")) {
        lsp::FileOperationClientCapabilities val;
        auto member = v.Get("fileOperations");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.file_operations = std::move(val);
    }
    if (v.Has("inlineValue")) {
        lsp::InlineValueWorkspaceClientCapabilities val;
        auto member = v.Get("inlineValue");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.inline_value = std::move(val);
    }
    if (v.Has("inlayHint")) {
        lsp::InlayHintWorkspaceClientCapabilities val;
        auto member = v.Get("inlayHint");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.inlay_hint = std::move(val);
    }
    if (v.Has("diagnostics")) {
        lsp::DiagnosticWorkspaceClientCapabilities val;
        auto member = v.Get("diagnostics");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.diagnostics = std::move(val);
    }
    if (v.Has("foldingRange")) {
        lsp::FoldingRangeWorkspaceClientCapabilities val;
        auto member = v.Get("foldingRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.folding_range = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(15);
    if (in.apply_edit) {
        auto res = Encode(*in.apply_edit, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"applyEdit", res.Get()});
    }
    if (in.workspace_edit) {
        auto res = Encode(*in.workspace_edit, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workspaceEdit", res.Get()});
    }
    if (in.did_change_configuration) {
        auto res = Encode(*in.did_change_configuration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didChangeConfiguration", res.Get()});
    }
    if (in.did_change_watched_files) {
        auto res = Encode(*in.did_change_watched_files, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didChangeWatchedFiles", res.Get()});
    }
    if (in.symbol) {
        auto res = Encode(*in.symbol, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"symbol", res.Get()});
    }
    if (in.execute_command) {
        auto res = Encode(*in.execute_command, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"executeCommand", res.Get()});
    }
    if (in.workspace_folders) {
        auto res = Encode(*in.workspace_folders, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workspaceFolders", res.Get()});
    }
    if (in.configuration) {
        auto res = Encode(*in.configuration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"configuration", res.Get()});
    }
    if (in.semantic_tokens) {
        auto res = Encode(*in.semantic_tokens, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"semanticTokens", res.Get()});
    }
    if (in.code_lens) {
        auto res = Encode(*in.code_lens, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeLens", res.Get()});
    }
    if (in.file_operations) {
        auto res = Encode(*in.file_operations, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"fileOperations", res.Get()});
    }
    if (in.inline_value) {
        auto res = Encode(*in.inline_value, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"inlineValue", res.Get()});
    }
    if (in.inlay_hint) {
        auto res = Encode(*in.inlay_hint, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"inlayHint", res.Get()});
    }
    if (in.diagnostics) {
        auto res = Encode(*in.diagnostics, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"diagnostics", res.Get()});
    }
    if (in.folding_range) {
        auto res = Encode(*in.folding_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"foldingRange", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentSyncClientCapabilities& lhs,
                const TextDocumentSyncClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.will_save != rhs.will_save) {
        return false;
    }
    if (lhs.will_save_wait_until != rhs.will_save_wait_until) {
        return false;
    }
    if (lhs.did_save != rhs.did_save) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentSyncClientCapabilities& lhs,
                const TextDocumentSyncClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TextDocumentSyncClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("willSave")) {
        Boolean val;
        auto member = v.Get("willSave");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_save = std::move(val);
    }
    if (v.Has("willSaveWaitUntil")) {
        Boolean val;
        auto member = v.Get("willSaveWaitUntil");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_save_wait_until = std::move(val);
    }
    if (v.Has("didSave")) {
        Boolean val;
        auto member = v.Get("didSave");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_save = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentSyncClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.will_save) {
        auto res = Encode(*in.will_save, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willSave", res.Get()});
    }
    if (in.will_save_wait_until) {
        auto res = Encode(*in.will_save_wait_until, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willSaveWaitUntil", res.Get()});
    }
    if (in.did_save) {
        auto res = Encode(*in.did_save, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didSave", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentSyncClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionItemTagOptions& lhs, const CompletionItemTagOptions& rhs) {
    if (lhs.value_set != rhs.value_set) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionItemTagOptions& lhs, const CompletionItemTagOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CompletionItemTagOptions& out) {
    {
        auto member = v.Get("valueSet");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value_set); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionItemTagOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.value_set, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"valueSet", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionItemTagOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientCompletionItemResolveOptions& lhs,
                const ClientCompletionItemResolveOptions& rhs) {
    if (lhs.properties != rhs.properties) {
        return false;
    }
    return true;
}

bool operator!=(const ClientCompletionItemResolveOptions& lhs,
                const ClientCompletionItemResolveOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientCompletionItemResolveOptions& out) {
    {
        auto member = v.Get("properties");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.properties); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientCompletionItemResolveOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.properties, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"properties", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientCompletionItemResolveOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientCompletionItemInsertTextModeOptions& lhs,
                const ClientCompletionItemInsertTextModeOptions& rhs) {
    if (lhs.value_set != rhs.value_set) {
        return false;
    }
    return true;
}

bool operator!=(const ClientCompletionItemInsertTextModeOptions& lhs,
                const ClientCompletionItemInsertTextModeOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientCompletionItemInsertTextModeOptions& out) {
    {
        auto member = v.Get("valueSet");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value_set); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientCompletionItemInsertTextModeOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.value_set, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"valueSet", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const ClientCompletionItemInsertTextModeOptions& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientCompletionItemOptions& lhs, const ClientCompletionItemOptions& rhs) {
    if (lhs.snippet_support != rhs.snippet_support) {
        return false;
    }
    if (lhs.commit_characters_support != rhs.commit_characters_support) {
        return false;
    }
    if (lhs.documentation_format != rhs.documentation_format) {
        return false;
    }
    if (lhs.deprecated_support != rhs.deprecated_support) {
        return false;
    }
    if (lhs.preselect_support != rhs.preselect_support) {
        return false;
    }
    if (lhs.tag_support != rhs.tag_support) {
        return false;
    }
    if (lhs.insert_replace_support != rhs.insert_replace_support) {
        return false;
    }
    if (lhs.resolve_support != rhs.resolve_support) {
        return false;
    }
    if (lhs.insert_text_mode_support != rhs.insert_text_mode_support) {
        return false;
    }
    if (lhs.label_details_support != rhs.label_details_support) {
        return false;
    }
    return true;
}

bool operator!=(const ClientCompletionItemOptions& lhs, const ClientCompletionItemOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientCompletionItemOptions& out) {
    if (v.Has("snippetSupport")) {
        Boolean val;
        auto member = v.Get("snippetSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.snippet_support = std::move(val);
    }
    if (v.Has("commitCharactersSupport")) {
        Boolean val;
        auto member = v.Get("commitCharactersSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.commit_characters_support = std::move(val);
    }
    if (v.Has("documentationFormat")) {
        std::vector<lsp::MarkupKind> val;
        auto member = v.Get("documentationFormat");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.documentation_format = std::move(val);
    }
    if (v.Has("deprecatedSupport")) {
        Boolean val;
        auto member = v.Get("deprecatedSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.deprecated_support = std::move(val);
    }
    if (v.Has("preselectSupport")) {
        Boolean val;
        auto member = v.Get("preselectSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.preselect_support = std::move(val);
    }
    if (v.Has("tagSupport")) {
        lsp::CompletionItemTagOptions val;
        auto member = v.Get("tagSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tag_support = std::move(val);
    }
    if (v.Has("insertReplaceSupport")) {
        Boolean val;
        auto member = v.Get("insertReplaceSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.insert_replace_support = std::move(val);
    }
    if (v.Has("resolveSupport")) {
        lsp::ClientCompletionItemResolveOptions val;
        auto member = v.Get("resolveSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_support = std::move(val);
    }
    if (v.Has("insertTextModeSupport")) {
        lsp::ClientCompletionItemInsertTextModeOptions val;
        auto member = v.Get("insertTextModeSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.insert_text_mode_support = std::move(val);
    }
    if (v.Has("labelDetailsSupport")) {
        Boolean val;
        auto member = v.Get("labelDetailsSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.label_details_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientCompletionItemOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(10);
    if (in.snippet_support) {
        auto res = Encode(*in.snippet_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"snippetSupport", res.Get()});
    }
    if (in.commit_characters_support) {
        auto res = Encode(*in.commit_characters_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"commitCharactersSupport", res.Get()});
    }
    if (in.documentation_format) {
        auto res = Encode(*in.documentation_format, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentationFormat", res.Get()});
    }
    if (in.deprecated_support) {
        auto res = Encode(*in.deprecated_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"deprecatedSupport", res.Get()});
    }
    if (in.preselect_support) {
        auto res = Encode(*in.preselect_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"preselectSupport", res.Get()});
    }
    if (in.tag_support) {
        auto res = Encode(*in.tag_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tagSupport", res.Get()});
    }
    if (in.insert_replace_support) {
        auto res = Encode(*in.insert_replace_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertReplaceSupport", res.Get()});
    }
    if (in.resolve_support) {
        auto res = Encode(*in.resolve_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveSupport", res.Get()});
    }
    if (in.insert_text_mode_support) {
        auto res = Encode(*in.insert_text_mode_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertTextModeSupport", res.Get()});
    }
    if (in.label_details_support) {
        auto res = Encode(*in.label_details_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"labelDetailsSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientCompletionItemOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientCompletionItemOptionsKind& lhs,
                const ClientCompletionItemOptionsKind& rhs) {
    if (lhs.value_set != rhs.value_set) {
        return false;
    }
    return true;
}

bool operator!=(const ClientCompletionItemOptionsKind& lhs,
                const ClientCompletionItemOptionsKind& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientCompletionItemOptionsKind& out) {
    if (v.Has("valueSet")) {
        std::vector<lsp::CompletionItemKind> val;
        auto member = v.Get("valueSet");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.value_set = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientCompletionItemOptionsKind& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.value_set) {
        auto res = Encode(*in.value_set, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"valueSet", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientCompletionItemOptionsKind& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionListCapabilities& lhs, const CompletionListCapabilities& rhs) {
    if (lhs.item_defaults != rhs.item_defaults) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionListCapabilities& lhs, const CompletionListCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CompletionListCapabilities& out) {
    if (v.Has("itemDefaults")) {
        std::vector<String> val;
        auto member = v.Get("itemDefaults");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.item_defaults = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionListCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.item_defaults) {
        auto res = Encode(*in.item_defaults, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"itemDefaults", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionListCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionClientCapabilities& lhs, const CompletionClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.completion_item != rhs.completion_item) {
        return false;
    }
    if (lhs.completion_item_kind != rhs.completion_item_kind) {
        return false;
    }
    if (lhs.insert_text_mode != rhs.insert_text_mode) {
        return false;
    }
    if (lhs.context_support != rhs.context_support) {
        return false;
    }
    if (lhs.completion_list != rhs.completion_list) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionClientCapabilities& lhs, const CompletionClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CompletionClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("completionItem")) {
        lsp::ClientCompletionItemOptions val;
        auto member = v.Get("completionItem");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.completion_item = std::move(val);
    }
    if (v.Has("completionItemKind")) {
        lsp::ClientCompletionItemOptionsKind val;
        auto member = v.Get("completionItemKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.completion_item_kind = std::move(val);
    }
    if (v.Has("insertTextMode")) {
        lsp::InsertTextMode val;
        auto member = v.Get("insertTextMode");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.insert_text_mode = std::move(val);
    }
    if (v.Has("contextSupport")) {
        Boolean val;
        auto member = v.Get("contextSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.context_support = std::move(val);
    }
    if (v.Has("completionList")) {
        lsp::CompletionListCapabilities val;
        auto member = v.Get("completionList");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.completion_list = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(6);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.completion_item) {
        auto res = Encode(*in.completion_item, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"completionItem", res.Get()});
    }
    if (in.completion_item_kind) {
        auto res = Encode(*in.completion_item_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"completionItemKind", res.Get()});
    }
    if (in.insert_text_mode) {
        auto res = Encode(*in.insert_text_mode, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertTextMode", res.Get()});
    }
    if (in.context_support) {
        auto res = Encode(*in.context_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"contextSupport", res.Get()});
    }
    if (in.completion_list) {
        auto res = Encode(*in.completion_list, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"completionList", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const HoverClientCapabilities& lhs, const HoverClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.content_format != rhs.content_format) {
        return false;
    }
    return true;
}

bool operator!=(const HoverClientCapabilities& lhs, const HoverClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] HoverClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("contentFormat")) {
        std::vector<lsp::MarkupKind> val;
        auto member = v.Get("contentFormat");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.content_format = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const HoverClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.content_format) {
        auto res = Encode(*in.content_format, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"contentFormat", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const HoverClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientSignatureParameterInformationOptions& lhs,
                const ClientSignatureParameterInformationOptions& rhs) {
    if (lhs.label_offset_support != rhs.label_offset_support) {
        return false;
    }
    return true;
}

bool operator!=(const ClientSignatureParameterInformationOptions& lhs,
                const ClientSignatureParameterInformationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientSignatureParameterInformationOptions& out) {
    if (v.Has("labelOffsetSupport")) {
        Boolean val;
        auto member = v.Get("labelOffsetSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.label_offset_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientSignatureParameterInformationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.label_offset_support) {
        auto res = Encode(*in.label_offset_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"labelOffsetSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const ClientSignatureParameterInformationOptions& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientSignatureInformationOptions& lhs,
                const ClientSignatureInformationOptions& rhs) {
    if (lhs.documentation_format != rhs.documentation_format) {
        return false;
    }
    if (lhs.parameter_information != rhs.parameter_information) {
        return false;
    }
    if (lhs.active_parameter_support != rhs.active_parameter_support) {
        return false;
    }
    return true;
}

bool operator!=(const ClientSignatureInformationOptions& lhs,
                const ClientSignatureInformationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientSignatureInformationOptions& out) {
    if (v.Has("documentationFormat")) {
        std::vector<lsp::MarkupKind> val;
        auto member = v.Get("documentationFormat");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.documentation_format = std::move(val);
    }
    if (v.Has("parameterInformation")) {
        lsp::ClientSignatureParameterInformationOptions val;
        auto member = v.Get("parameterInformation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.parameter_information = std::move(val);
    }
    if (v.Has("activeParameterSupport")) {
        Boolean val;
        auto member = v.Get("activeParameterSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.active_parameter_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientSignatureInformationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.documentation_format) {
        auto res = Encode(*in.documentation_format, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentationFormat", res.Get()});
    }
    if (in.parameter_information) {
        auto res = Encode(*in.parameter_information, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"parameterInformation", res.Get()});
    }
    if (in.active_parameter_support) {
        auto res = Encode(*in.active_parameter_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"activeParameterSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientSignatureInformationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SignatureHelpClientCapabilities& lhs,
                const SignatureHelpClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.signature_information != rhs.signature_information) {
        return false;
    }
    if (lhs.context_support != rhs.context_support) {
        return false;
    }
    return true;
}

bool operator!=(const SignatureHelpClientCapabilities& lhs,
                const SignatureHelpClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SignatureHelpClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("signatureInformation")) {
        lsp::ClientSignatureInformationOptions val;
        auto member = v.Get("signatureInformation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.signature_information = std::move(val);
    }
    if (v.Has("contextSupport")) {
        Boolean val;
        auto member = v.Get("contextSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.context_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SignatureHelpClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.signature_information) {
        auto res = Encode(*in.signature_information, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"signatureInformation", res.Get()});
    }
    if (in.context_support) {
        auto res = Encode(*in.context_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"contextSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SignatureHelpClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DeclarationClientCapabilities& lhs,
                const DeclarationClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.link_support != rhs.link_support) {
        return false;
    }
    return true;
}

bool operator!=(const DeclarationClientCapabilities& lhs,
                const DeclarationClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DeclarationClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("linkSupport")) {
        Boolean val;
        auto member = v.Get("linkSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.link_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DeclarationClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.link_support) {
        auto res = Encode(*in.link_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"linkSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DeclarationClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DefinitionClientCapabilities& lhs, const DefinitionClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.link_support != rhs.link_support) {
        return false;
    }
    return true;
}

bool operator!=(const DefinitionClientCapabilities& lhs, const DefinitionClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DefinitionClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("linkSupport")) {
        Boolean val;
        auto member = v.Get("linkSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.link_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DefinitionClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.link_support) {
        auto res = Encode(*in.link_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"linkSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DefinitionClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeDefinitionClientCapabilities& lhs,
                const TypeDefinitionClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.link_support != rhs.link_support) {
        return false;
    }
    return true;
}

bool operator!=(const TypeDefinitionClientCapabilities& lhs,
                const TypeDefinitionClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TypeDefinitionClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("linkSupport")) {
        Boolean val;
        auto member = v.Get("linkSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.link_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeDefinitionClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.link_support) {
        auto res = Encode(*in.link_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"linkSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeDefinitionClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ImplementationClientCapabilities& lhs,
                const ImplementationClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.link_support != rhs.link_support) {
        return false;
    }
    return true;
}

bool operator!=(const ImplementationClientCapabilities& lhs,
                const ImplementationClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ImplementationClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("linkSupport")) {
        Boolean val;
        auto member = v.Get("linkSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.link_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ImplementationClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.link_support) {
        auto res = Encode(*in.link_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"linkSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ImplementationClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ReferenceClientCapabilities& lhs, const ReferenceClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const ReferenceClientCapabilities& lhs, const ReferenceClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ReferenceClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ReferenceClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ReferenceClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentHighlightClientCapabilities& lhs,
                const DocumentHighlightClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentHighlightClientCapabilities& lhs,
                const DocumentHighlightClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentHighlightClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentHighlightClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentHighlightClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentSymbolClientCapabilities& lhs,
                const DocumentSymbolClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.symbol_kind != rhs.symbol_kind) {
        return false;
    }
    if (lhs.hierarchical_document_symbol_support != rhs.hierarchical_document_symbol_support) {
        return false;
    }
    if (lhs.tag_support != rhs.tag_support) {
        return false;
    }
    if (lhs.label_support != rhs.label_support) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentSymbolClientCapabilities& lhs,
                const DocumentSymbolClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentSymbolClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("symbolKind")) {
        lsp::ClientSymbolKindOptions val;
        auto member = v.Get("symbolKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.symbol_kind = std::move(val);
    }
    if (v.Has("hierarchicalDocumentSymbolSupport")) {
        Boolean val;
        auto member = v.Get("hierarchicalDocumentSymbolSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.hierarchical_document_symbol_support = std::move(val);
    }
    if (v.Has("tagSupport")) {
        lsp::ClientSymbolTagOptions val;
        auto member = v.Get("tagSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tag_support = std::move(val);
    }
    if (v.Has("labelSupport")) {
        Boolean val;
        auto member = v.Get("labelSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.label_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentSymbolClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(5);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.symbol_kind) {
        auto res = Encode(*in.symbol_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"symbolKind", res.Get()});
    }
    if (in.hierarchical_document_symbol_support) {
        auto res = Encode(*in.hierarchical_document_symbol_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"hierarchicalDocumentSymbolSupport", res.Get()});
    }
    if (in.tag_support) {
        auto res = Encode(*in.tag_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tagSupport", res.Get()});
    }
    if (in.label_support) {
        auto res = Encode(*in.label_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"labelSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentSymbolClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientCodeActionKindOptions& lhs, const ClientCodeActionKindOptions& rhs) {
    if (lhs.value_set != rhs.value_set) {
        return false;
    }
    return true;
}

bool operator!=(const ClientCodeActionKindOptions& lhs, const ClientCodeActionKindOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientCodeActionKindOptions& out) {
    {
        auto member = v.Get("valueSet");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value_set); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientCodeActionKindOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.value_set, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"valueSet", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientCodeActionKindOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientCodeActionLiteralOptions& lhs,
                const ClientCodeActionLiteralOptions& rhs) {
    if (lhs.code_action_kind != rhs.code_action_kind) {
        return false;
    }
    return true;
}

bool operator!=(const ClientCodeActionLiteralOptions& lhs,
                const ClientCodeActionLiteralOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientCodeActionLiteralOptions& out) {
    {
        auto member = v.Get("codeActionKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.code_action_kind); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientCodeActionLiteralOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.code_action_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeActionKind", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientCodeActionLiteralOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientCodeActionResolveOptions& lhs,
                const ClientCodeActionResolveOptions& rhs) {
    if (lhs.properties != rhs.properties) {
        return false;
    }
    return true;
}

bool operator!=(const ClientCodeActionResolveOptions& lhs,
                const ClientCodeActionResolveOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientCodeActionResolveOptions& out) {
    {
        auto member = v.Get("properties");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.properties); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientCodeActionResolveOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.properties, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"properties", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientCodeActionResolveOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeActionClientCapabilities& lhs, const CodeActionClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.code_action_literal_support != rhs.code_action_literal_support) {
        return false;
    }
    if (lhs.is_preferred_support != rhs.is_preferred_support) {
        return false;
    }
    if (lhs.disabled_support != rhs.disabled_support) {
        return false;
    }
    if (lhs.data_support != rhs.data_support) {
        return false;
    }
    if (lhs.resolve_support != rhs.resolve_support) {
        return false;
    }
    if (lhs.honors_change_annotations != rhs.honors_change_annotations) {
        return false;
    }
    return true;
}

bool operator!=(const CodeActionClientCapabilities& lhs, const CodeActionClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CodeActionClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("codeActionLiteralSupport")) {
        lsp::ClientCodeActionLiteralOptions val;
        auto member = v.Get("codeActionLiteralSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code_action_literal_support = std::move(val);
    }
    if (v.Has("isPreferredSupport")) {
        Boolean val;
        auto member = v.Get("isPreferredSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.is_preferred_support = std::move(val);
    }
    if (v.Has("disabledSupport")) {
        Boolean val;
        auto member = v.Get("disabledSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.disabled_support = std::move(val);
    }
    if (v.Has("dataSupport")) {
        Boolean val;
        auto member = v.Get("dataSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data_support = std::move(val);
    }
    if (v.Has("resolveSupport")) {
        lsp::ClientCodeActionResolveOptions val;
        auto member = v.Get("resolveSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_support = std::move(val);
    }
    if (v.Has("honorsChangeAnnotations")) {
        Boolean val;
        auto member = v.Get("honorsChangeAnnotations");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.honors_change_annotations = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeActionClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(7);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.code_action_literal_support) {
        auto res = Encode(*in.code_action_literal_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeActionLiteralSupport", res.Get()});
    }
    if (in.is_preferred_support) {
        auto res = Encode(*in.is_preferred_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"isPreferredSupport", res.Get()});
    }
    if (in.disabled_support) {
        auto res = Encode(*in.disabled_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"disabledSupport", res.Get()});
    }
    if (in.data_support) {
        auto res = Encode(*in.data_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dataSupport", res.Get()});
    }
    if (in.resolve_support) {
        auto res = Encode(*in.resolve_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveSupport", res.Get()});
    }
    if (in.honors_change_annotations) {
        auto res = Encode(*in.honors_change_annotations, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"honorsChangeAnnotations", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeActionClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeLensClientCapabilities& lhs, const CodeLensClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const CodeLensClientCapabilities& lhs, const CodeLensClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CodeLensClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeLensClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeLensClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentLinkClientCapabilities& lhs,
                const DocumentLinkClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.tooltip_support != rhs.tooltip_support) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentLinkClientCapabilities& lhs,
                const DocumentLinkClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentLinkClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("tooltipSupport")) {
        Boolean val;
        auto member = v.Get("tooltipSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tooltip_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentLinkClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.tooltip_support) {
        auto res = Encode(*in.tooltip_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tooltipSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentLinkClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentColorClientCapabilities& lhs,
                const DocumentColorClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentColorClientCapabilities& lhs,
                const DocumentColorClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentColorClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentColorClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentColorClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentFormattingClientCapabilities& lhs,
                const DocumentFormattingClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentFormattingClientCapabilities& lhs,
                const DocumentFormattingClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentFormattingClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentFormattingClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentFormattingClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentRangeFormattingClientCapabilities& lhs,
                const DocumentRangeFormattingClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.ranges_support != rhs.ranges_support) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentRangeFormattingClientCapabilities& lhs,
                const DocumentRangeFormattingClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentRangeFormattingClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("rangesSupport")) {
        Boolean val;
        auto member = v.Get("rangesSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.ranges_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentRangeFormattingClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.ranges_support) {
        auto res = Encode(*in.ranges_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"rangesSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const DocumentRangeFormattingClientCapabilities& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentOnTypeFormattingClientCapabilities& lhs,
                const DocumentOnTypeFormattingClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentOnTypeFormattingClientCapabilities& lhs,
                const DocumentOnTypeFormattingClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentOnTypeFormattingClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentOnTypeFormattingClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const DocumentOnTypeFormattingClientCapabilities& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RenameClientCapabilities& lhs, const RenameClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.prepare_support != rhs.prepare_support) {
        return false;
    }
    if (lhs.prepare_support_default_behavior != rhs.prepare_support_default_behavior) {
        return false;
    }
    if (lhs.honors_change_annotations != rhs.honors_change_annotations) {
        return false;
    }
    return true;
}

bool operator!=(const RenameClientCapabilities& lhs, const RenameClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] RenameClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("prepareSupport")) {
        Boolean val;
        auto member = v.Get("prepareSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.prepare_support = std::move(val);
    }
    if (v.Has("prepareSupportDefaultBehavior")) {
        lsp::PrepareSupportDefaultBehavior val;
        auto member = v.Get("prepareSupportDefaultBehavior");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.prepare_support_default_behavior = std::move(val);
    }
    if (v.Has("honorsChangeAnnotations")) {
        Boolean val;
        auto member = v.Get("honorsChangeAnnotations");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.honors_change_annotations = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RenameClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.prepare_support) {
        auto res = Encode(*in.prepare_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"prepareSupport", res.Get()});
    }
    if (in.prepare_support_default_behavior) {
        auto res = Encode(*in.prepare_support_default_behavior, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"prepareSupportDefaultBehavior", res.Get()});
    }
    if (in.honors_change_annotations) {
        auto res = Encode(*in.honors_change_annotations, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"honorsChangeAnnotations", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RenameClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientFoldingRangeKindOptions& lhs,
                const ClientFoldingRangeKindOptions& rhs) {
    if (lhs.value_set != rhs.value_set) {
        return false;
    }
    return true;
}

bool operator!=(const ClientFoldingRangeKindOptions& lhs,
                const ClientFoldingRangeKindOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientFoldingRangeKindOptions& out) {
    if (v.Has("valueSet")) {
        std::vector<lsp::FoldingRangeKind> val;
        auto member = v.Get("valueSet");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.value_set = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientFoldingRangeKindOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.value_set) {
        auto res = Encode(*in.value_set, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"valueSet", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientFoldingRangeKindOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientFoldingRangeOptions& lhs, const ClientFoldingRangeOptions& rhs) {
    if (lhs.collapsed_text != rhs.collapsed_text) {
        return false;
    }
    return true;
}

bool operator!=(const ClientFoldingRangeOptions& lhs, const ClientFoldingRangeOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ClientFoldingRangeOptions& out) {
    if (v.Has("collapsedText")) {
        Boolean val;
        auto member = v.Get("collapsedText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.collapsed_text = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientFoldingRangeOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.collapsed_text) {
        auto res = Encode(*in.collapsed_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"collapsedText", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientFoldingRangeOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FoldingRangeClientCapabilities& lhs,
                const FoldingRangeClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.range_limit != rhs.range_limit) {
        return false;
    }
    if (lhs.line_folding_only != rhs.line_folding_only) {
        return false;
    }
    if (lhs.folding_range_kind != rhs.folding_range_kind) {
        return false;
    }
    if (lhs.folding_range != rhs.folding_range) {
        return false;
    }
    return true;
}

bool operator!=(const FoldingRangeClientCapabilities& lhs,
                const FoldingRangeClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] FoldingRangeClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("rangeLimit")) {
        Uinteger val;
        auto member = v.Get("rangeLimit");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.range_limit = std::move(val);
    }
    if (v.Has("lineFoldingOnly")) {
        Boolean val;
        auto member = v.Get("lineFoldingOnly");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.line_folding_only = std::move(val);
    }
    if (v.Has("foldingRangeKind")) {
        lsp::ClientFoldingRangeKindOptions val;
        auto member = v.Get("foldingRangeKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.folding_range_kind = std::move(val);
    }
    if (v.Has("foldingRange")) {
        lsp::ClientFoldingRangeOptions val;
        auto member = v.Get("foldingRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.folding_range = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FoldingRangeClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(5);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.range_limit) {
        auto res = Encode(*in.range_limit, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"rangeLimit", res.Get()});
    }
    if (in.line_folding_only) {
        auto res = Encode(*in.line_folding_only, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"lineFoldingOnly", res.Get()});
    }
    if (in.folding_range_kind) {
        auto res = Encode(*in.folding_range_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"foldingRangeKind", res.Get()});
    }
    if (in.folding_range) {
        auto res = Encode(*in.folding_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"foldingRange", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FoldingRangeClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SelectionRangeClientCapabilities& lhs,
                const SelectionRangeClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const SelectionRangeClientCapabilities& lhs,
                const SelectionRangeClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SelectionRangeClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SelectionRangeClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SelectionRangeClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientDiagnosticsTagOptions& lhs, const ClientDiagnosticsTagOptions& rhs) {
    if (lhs.value_set != rhs.value_set) {
        return false;
    }
    return true;
}

bool operator!=(const ClientDiagnosticsTagOptions& lhs, const ClientDiagnosticsTagOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientDiagnosticsTagOptions& out) {
    {
        auto member = v.Get("valueSet");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value_set); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientDiagnosticsTagOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.value_set, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"valueSet", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientDiagnosticsTagOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const PublishDiagnosticsClientCapabilities& lhs,
                const PublishDiagnosticsClientCapabilities& rhs) {
    if (lhs.related_information != rhs.related_information) {
        return false;
    }
    if (lhs.tag_support != rhs.tag_support) {
        return false;
    }
    if (lhs.version_support != rhs.version_support) {
        return false;
    }
    if (lhs.code_description_support != rhs.code_description_support) {
        return false;
    }
    if (lhs.data_support != rhs.data_support) {
        return false;
    }
    return true;
}

bool operator!=(const PublishDiagnosticsClientCapabilities& lhs,
                const PublishDiagnosticsClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] PublishDiagnosticsClientCapabilities& out) {
    if (v.Has("relatedInformation")) {
        Boolean val;
        auto member = v.Get("relatedInformation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.related_information = std::move(val);
    }
    if (v.Has("tagSupport")) {
        lsp::ClientDiagnosticsTagOptions val;
        auto member = v.Get("tagSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tag_support = std::move(val);
    }
    if (v.Has("versionSupport")) {
        Boolean val;
        auto member = v.Get("versionSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.version_support = std::move(val);
    }
    if (v.Has("codeDescriptionSupport")) {
        Boolean val;
        auto member = v.Get("codeDescriptionSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code_description_support = std::move(val);
    }
    if (v.Has("dataSupport")) {
        Boolean val;
        auto member = v.Get("dataSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const PublishDiagnosticsClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(5);
    if (in.related_information) {
        auto res = Encode(*in.related_information, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"relatedInformation", res.Get()});
    }
    if (in.tag_support) {
        auto res = Encode(*in.tag_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tagSupport", res.Get()});
    }
    if (in.version_support) {
        auto res = Encode(*in.version_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"versionSupport", res.Get()});
    }
    if (in.code_description_support) {
        auto res = Encode(*in.code_description_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeDescriptionSupport", res.Get()});
    }
    if (in.data_support) {
        auto res = Encode(*in.data_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dataSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const PublishDiagnosticsClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CallHierarchyClientCapabilities& lhs,
                const CallHierarchyClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const CallHierarchyClientCapabilities& lhs,
                const CallHierarchyClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CallHierarchyClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CallHierarchyClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CallHierarchyClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientSemanticTokensRequestFullDelta& lhs,
                const ClientSemanticTokensRequestFullDelta& rhs) {
    if (lhs.delta != rhs.delta) {
        return false;
    }
    return true;
}

bool operator!=(const ClientSemanticTokensRequestFullDelta& lhs,
                const ClientSemanticTokensRequestFullDelta& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientSemanticTokensRequestFullDelta& out) {
    if (v.Has("delta")) {
        Boolean val;
        auto member = v.Get("delta");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.delta = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientSemanticTokensRequestFullDelta& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.delta) {
        auto res = Encode(*in.delta, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"delta", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientSemanticTokensRequestFullDelta& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientSemanticTokensRequestOptions& lhs,
                const ClientSemanticTokensRequestOptions& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.full != rhs.full) {
        return false;
    }
    return true;
}

bool operator!=(const ClientSemanticTokensRequestOptions& lhs,
                const ClientSemanticTokensRequestOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientSemanticTokensRequestOptions& out) {
    if (v.Has("range")) {
        OneOf<Boolean, lsp::ClientSemanticTokensRequestOptions::Range> val;
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.range = std::move(val);
    }
    if (v.Has("full")) {
        OneOf<Boolean, lsp::ClientSemanticTokensRequestFullDelta> val;
        auto member = v.Get("full");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.full = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientSemanticTokensRequestOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.range) {
        auto res = Encode(*in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.full) {
        auto res = Encode(*in.full, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"full", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientSemanticTokensRequestOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}
bool operator==(const ClientSemanticTokensRequestOptions::Range& lhs,
                const ClientSemanticTokensRequestOptions::Range& rhs) {
    return true;
}

bool operator!=(const ClientSemanticTokensRequestOptions::Range& lhs,
                const ClientSemanticTokensRequestOptions::Range& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientSemanticTokensRequestOptions::Range& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientSemanticTokensRequestOptions::Range& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const ClientSemanticTokensRequestOptions::Range& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SemanticTokensClientCapabilities& lhs,
                const SemanticTokensClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.requests != rhs.requests) {
        return false;
    }
    if (lhs.token_types != rhs.token_types) {
        return false;
    }
    if (lhs.token_modifiers != rhs.token_modifiers) {
        return false;
    }
    if (lhs.formats != rhs.formats) {
        return false;
    }
    if (lhs.overlapping_token_support != rhs.overlapping_token_support) {
        return false;
    }
    if (lhs.multiline_token_support != rhs.multiline_token_support) {
        return false;
    }
    if (lhs.server_cancel_support != rhs.server_cancel_support) {
        return false;
    }
    if (lhs.augments_syntax_tokens != rhs.augments_syntax_tokens) {
        return false;
    }
    return true;
}

bool operator!=(const SemanticTokensClientCapabilities& lhs,
                const SemanticTokensClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SemanticTokensClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    {
        auto member = v.Get("requests");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.requests); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("tokenTypes");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.token_types); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("tokenModifiers");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.token_modifiers); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("formats");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.formats); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("overlappingTokenSupport")) {
        Boolean val;
        auto member = v.Get("overlappingTokenSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.overlapping_token_support = std::move(val);
    }
    if (v.Has("multilineTokenSupport")) {
        Boolean val;
        auto member = v.Get("multilineTokenSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.multiline_token_support = std::move(val);
    }
    if (v.Has("serverCancelSupport")) {
        Boolean val;
        auto member = v.Get("serverCancelSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.server_cancel_support = std::move(val);
    }
    if (v.Has("augmentsSyntaxTokens")) {
        Boolean val;
        auto member = v.Get("augmentsSyntaxTokens");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.augments_syntax_tokens = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SemanticTokensClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(9);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    {
        auto res = Encode(in.requests, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"requests", res.Get()});
    }
    {
        auto res = Encode(in.token_types, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tokenTypes", res.Get()});
    }
    {
        auto res = Encode(in.token_modifiers, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tokenModifiers", res.Get()});
    }
    {
        auto res = Encode(in.formats, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"formats", res.Get()});
    }
    if (in.overlapping_token_support) {
        auto res = Encode(*in.overlapping_token_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"overlappingTokenSupport", res.Get()});
    }
    if (in.multiline_token_support) {
        auto res = Encode(*in.multiline_token_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"multilineTokenSupport", res.Get()});
    }
    if (in.server_cancel_support) {
        auto res = Encode(*in.server_cancel_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"serverCancelSupport", res.Get()});
    }
    if (in.augments_syntax_tokens) {
        auto res = Encode(*in.augments_syntax_tokens, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"augmentsSyntaxTokens", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SemanticTokensClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const LinkedEditingRangeClientCapabilities& lhs,
                const LinkedEditingRangeClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const LinkedEditingRangeClientCapabilities& lhs,
                const LinkedEditingRangeClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] LinkedEditingRangeClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const LinkedEditingRangeClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const LinkedEditingRangeClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const MonikerClientCapabilities& lhs, const MonikerClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const MonikerClientCapabilities& lhs, const MonikerClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] MonikerClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const MonikerClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const MonikerClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TypeHierarchyClientCapabilities& lhs,
                const TypeHierarchyClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const TypeHierarchyClientCapabilities& lhs,
                const TypeHierarchyClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TypeHierarchyClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TypeHierarchyClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TypeHierarchyClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineValueClientCapabilities& lhs,
                const InlineValueClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const InlineValueClientCapabilities& lhs,
                const InlineValueClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] InlineValueClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineValueClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineValueClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientInlayHintResolveOptions& lhs,
                const ClientInlayHintResolveOptions& rhs) {
    if (lhs.properties != rhs.properties) {
        return false;
    }
    return true;
}

bool operator!=(const ClientInlayHintResolveOptions& lhs,
                const ClientInlayHintResolveOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientInlayHintResolveOptions& out) {
    {
        auto member = v.Get("properties");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.properties); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientInlayHintResolveOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.properties, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"properties", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientInlayHintResolveOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlayHintClientCapabilities& lhs, const InlayHintClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.resolve_support != rhs.resolve_support) {
        return false;
    }
    return true;
}

bool operator!=(const InlayHintClientCapabilities& lhs, const InlayHintClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] InlayHintClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("resolveSupport")) {
        lsp::ClientInlayHintResolveOptions val;
        auto member = v.Get("resolveSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlayHintClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.resolve_support) {
        auto res = Encode(*in.resolve_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlayHintClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DiagnosticClientCapabilities& lhs, const DiagnosticClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.related_document_support != rhs.related_document_support) {
        return false;
    }
    return true;
}

bool operator!=(const DiagnosticClientCapabilities& lhs, const DiagnosticClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DiagnosticClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("relatedDocumentSupport")) {
        Boolean val;
        auto member = v.Get("relatedDocumentSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.related_document_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DiagnosticClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.related_document_support) {
        auto res = Encode(*in.related_document_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"relatedDocumentSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DiagnosticClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineCompletionClientCapabilities& lhs,
                const InlineCompletionClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    return true;
}

bool operator!=(const InlineCompletionClientCapabilities& lhs,
                const InlineCompletionClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] InlineCompletionClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineCompletionClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineCompletionClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentClientCapabilities& lhs,
                const TextDocumentClientCapabilities& rhs) {
    if (lhs.synchronization != rhs.synchronization) {
        return false;
    }
    if (lhs.completion != rhs.completion) {
        return false;
    }
    if (lhs.hover != rhs.hover) {
        return false;
    }
    if (lhs.signature_help != rhs.signature_help) {
        return false;
    }
    if (lhs.declaration != rhs.declaration) {
        return false;
    }
    if (lhs.definition != rhs.definition) {
        return false;
    }
    if (lhs.type_definition != rhs.type_definition) {
        return false;
    }
    if (lhs.implementation != rhs.implementation) {
        return false;
    }
    if (lhs.references != rhs.references) {
        return false;
    }
    if (lhs.document_highlight != rhs.document_highlight) {
        return false;
    }
    if (lhs.document_symbol != rhs.document_symbol) {
        return false;
    }
    if (lhs.code_action != rhs.code_action) {
        return false;
    }
    if (lhs.code_lens != rhs.code_lens) {
        return false;
    }
    if (lhs.document_link != rhs.document_link) {
        return false;
    }
    if (lhs.color_provider != rhs.color_provider) {
        return false;
    }
    if (lhs.formatting != rhs.formatting) {
        return false;
    }
    if (lhs.range_formatting != rhs.range_formatting) {
        return false;
    }
    if (lhs.on_type_formatting != rhs.on_type_formatting) {
        return false;
    }
    if (lhs.rename != rhs.rename) {
        return false;
    }
    if (lhs.folding_range != rhs.folding_range) {
        return false;
    }
    if (lhs.selection_range != rhs.selection_range) {
        return false;
    }
    if (lhs.publish_diagnostics != rhs.publish_diagnostics) {
        return false;
    }
    if (lhs.call_hierarchy != rhs.call_hierarchy) {
        return false;
    }
    if (lhs.semantic_tokens != rhs.semantic_tokens) {
        return false;
    }
    if (lhs.linked_editing_range != rhs.linked_editing_range) {
        return false;
    }
    if (lhs.moniker != rhs.moniker) {
        return false;
    }
    if (lhs.type_hierarchy != rhs.type_hierarchy) {
        return false;
    }
    if (lhs.inline_value != rhs.inline_value) {
        return false;
    }
    if (lhs.inlay_hint != rhs.inlay_hint) {
        return false;
    }
    if (lhs.diagnostic != rhs.diagnostic) {
        return false;
    }
    if (lhs.inline_completion != rhs.inline_completion) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentClientCapabilities& lhs,
                const TextDocumentClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TextDocumentClientCapabilities& out) {
    if (v.Has("synchronization")) {
        lsp::TextDocumentSyncClientCapabilities val;
        auto member = v.Get("synchronization");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.synchronization = std::move(val);
    }
    if (v.Has("completion")) {
        lsp::CompletionClientCapabilities val;
        auto member = v.Get("completion");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.completion = std::move(val);
    }
    if (v.Has("hover")) {
        lsp::HoverClientCapabilities val;
        auto member = v.Get("hover");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.hover = std::move(val);
    }
    if (v.Has("signatureHelp")) {
        lsp::SignatureHelpClientCapabilities val;
        auto member = v.Get("signatureHelp");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.signature_help = std::move(val);
    }
    if (v.Has("declaration")) {
        lsp::DeclarationClientCapabilities val;
        auto member = v.Get("declaration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.declaration = std::move(val);
    }
    if (v.Has("definition")) {
        lsp::DefinitionClientCapabilities val;
        auto member = v.Get("definition");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.definition = std::move(val);
    }
    if (v.Has("typeDefinition")) {
        lsp::TypeDefinitionClientCapabilities val;
        auto member = v.Get("typeDefinition");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.type_definition = std::move(val);
    }
    if (v.Has("implementation")) {
        lsp::ImplementationClientCapabilities val;
        auto member = v.Get("implementation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.implementation = std::move(val);
    }
    if (v.Has("references")) {
        lsp::ReferenceClientCapabilities val;
        auto member = v.Get("references");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.references = std::move(val);
    }
    if (v.Has("documentHighlight")) {
        lsp::DocumentHighlightClientCapabilities val;
        auto member = v.Get("documentHighlight");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_highlight = std::move(val);
    }
    if (v.Has("documentSymbol")) {
        lsp::DocumentSymbolClientCapabilities val;
        auto member = v.Get("documentSymbol");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_symbol = std::move(val);
    }
    if (v.Has("codeAction")) {
        lsp::CodeActionClientCapabilities val;
        auto member = v.Get("codeAction");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code_action = std::move(val);
    }
    if (v.Has("codeLens")) {
        lsp::CodeLensClientCapabilities val;
        auto member = v.Get("codeLens");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code_lens = std::move(val);
    }
    if (v.Has("documentLink")) {
        lsp::DocumentLinkClientCapabilities val;
        auto member = v.Get("documentLink");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_link = std::move(val);
    }
    if (v.Has("colorProvider")) {
        lsp::DocumentColorClientCapabilities val;
        auto member = v.Get("colorProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.color_provider = std::move(val);
    }
    if (v.Has("formatting")) {
        lsp::DocumentFormattingClientCapabilities val;
        auto member = v.Get("formatting");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.formatting = std::move(val);
    }
    if (v.Has("rangeFormatting")) {
        lsp::DocumentRangeFormattingClientCapabilities val;
        auto member = v.Get("rangeFormatting");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.range_formatting = std::move(val);
    }
    if (v.Has("onTypeFormatting")) {
        lsp::DocumentOnTypeFormattingClientCapabilities val;
        auto member = v.Get("onTypeFormatting");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.on_type_formatting = std::move(val);
    }
    if (v.Has("rename")) {
        lsp::RenameClientCapabilities val;
        auto member = v.Get("rename");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.rename = std::move(val);
    }
    if (v.Has("foldingRange")) {
        lsp::FoldingRangeClientCapabilities val;
        auto member = v.Get("foldingRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.folding_range = std::move(val);
    }
    if (v.Has("selectionRange")) {
        lsp::SelectionRangeClientCapabilities val;
        auto member = v.Get("selectionRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.selection_range = std::move(val);
    }
    if (v.Has("publishDiagnostics")) {
        lsp::PublishDiagnosticsClientCapabilities val;
        auto member = v.Get("publishDiagnostics");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.publish_diagnostics = std::move(val);
    }
    if (v.Has("callHierarchy")) {
        lsp::CallHierarchyClientCapabilities val;
        auto member = v.Get("callHierarchy");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.call_hierarchy = std::move(val);
    }
    if (v.Has("semanticTokens")) {
        lsp::SemanticTokensClientCapabilities val;
        auto member = v.Get("semanticTokens");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.semantic_tokens = std::move(val);
    }
    if (v.Has("linkedEditingRange")) {
        lsp::LinkedEditingRangeClientCapabilities val;
        auto member = v.Get("linkedEditingRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.linked_editing_range = std::move(val);
    }
    if (v.Has("moniker")) {
        lsp::MonikerClientCapabilities val;
        auto member = v.Get("moniker");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.moniker = std::move(val);
    }
    if (v.Has("typeHierarchy")) {
        lsp::TypeHierarchyClientCapabilities val;
        auto member = v.Get("typeHierarchy");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.type_hierarchy = std::move(val);
    }
    if (v.Has("inlineValue")) {
        lsp::InlineValueClientCapabilities val;
        auto member = v.Get("inlineValue");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.inline_value = std::move(val);
    }
    if (v.Has("inlayHint")) {
        lsp::InlayHintClientCapabilities val;
        auto member = v.Get("inlayHint");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.inlay_hint = std::move(val);
    }
    if (v.Has("diagnostic")) {
        lsp::DiagnosticClientCapabilities val;
        auto member = v.Get("diagnostic");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.diagnostic = std::move(val);
    }
    if (v.Has("inlineCompletion")) {
        lsp::InlineCompletionClientCapabilities val;
        auto member = v.Get("inlineCompletion");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.inline_completion = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(31);
    if (in.synchronization) {
        auto res = Encode(*in.synchronization, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"synchronization", res.Get()});
    }
    if (in.completion) {
        auto res = Encode(*in.completion, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"completion", res.Get()});
    }
    if (in.hover) {
        auto res = Encode(*in.hover, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"hover", res.Get()});
    }
    if (in.signature_help) {
        auto res = Encode(*in.signature_help, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"signatureHelp", res.Get()});
    }
    if (in.declaration) {
        auto res = Encode(*in.declaration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"declaration", res.Get()});
    }
    if (in.definition) {
        auto res = Encode(*in.definition, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"definition", res.Get()});
    }
    if (in.type_definition) {
        auto res = Encode(*in.type_definition, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"typeDefinition", res.Get()});
    }
    if (in.implementation) {
        auto res = Encode(*in.implementation, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"implementation", res.Get()});
    }
    if (in.references) {
        auto res = Encode(*in.references, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"references", res.Get()});
    }
    if (in.document_highlight) {
        auto res = Encode(*in.document_highlight, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentHighlight", res.Get()});
    }
    if (in.document_symbol) {
        auto res = Encode(*in.document_symbol, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentSymbol", res.Get()});
    }
    if (in.code_action) {
        auto res = Encode(*in.code_action, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeAction", res.Get()});
    }
    if (in.code_lens) {
        auto res = Encode(*in.code_lens, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeLens", res.Get()});
    }
    if (in.document_link) {
        auto res = Encode(*in.document_link, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentLink", res.Get()});
    }
    if (in.color_provider) {
        auto res = Encode(*in.color_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"colorProvider", res.Get()});
    }
    if (in.formatting) {
        auto res = Encode(*in.formatting, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"formatting", res.Get()});
    }
    if (in.range_formatting) {
        auto res = Encode(*in.range_formatting, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"rangeFormatting", res.Get()});
    }
    if (in.on_type_formatting) {
        auto res = Encode(*in.on_type_formatting, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"onTypeFormatting", res.Get()});
    }
    if (in.rename) {
        auto res = Encode(*in.rename, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"rename", res.Get()});
    }
    if (in.folding_range) {
        auto res = Encode(*in.folding_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"foldingRange", res.Get()});
    }
    if (in.selection_range) {
        auto res = Encode(*in.selection_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"selectionRange", res.Get()});
    }
    if (in.publish_diagnostics) {
        auto res = Encode(*in.publish_diagnostics, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"publishDiagnostics", res.Get()});
    }
    if (in.call_hierarchy) {
        auto res = Encode(*in.call_hierarchy, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"callHierarchy", res.Get()});
    }
    if (in.semantic_tokens) {
        auto res = Encode(*in.semantic_tokens, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"semanticTokens", res.Get()});
    }
    if (in.linked_editing_range) {
        auto res = Encode(*in.linked_editing_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"linkedEditingRange", res.Get()});
    }
    if (in.moniker) {
        auto res = Encode(*in.moniker, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"moniker", res.Get()});
    }
    if (in.type_hierarchy) {
        auto res = Encode(*in.type_hierarchy, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"typeHierarchy", res.Get()});
    }
    if (in.inline_value) {
        auto res = Encode(*in.inline_value, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"inlineValue", res.Get()});
    }
    if (in.inlay_hint) {
        auto res = Encode(*in.inlay_hint, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"inlayHint", res.Get()});
    }
    if (in.diagnostic) {
        auto res = Encode(*in.diagnostic, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"diagnostic", res.Get()});
    }
    if (in.inline_completion) {
        auto res = Encode(*in.inline_completion, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"inlineCompletion", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentSyncClientCapabilities& lhs,
                const NotebookDocumentSyncClientCapabilities& rhs) {
    if (lhs.dynamic_registration != rhs.dynamic_registration) {
        return false;
    }
    if (lhs.execution_summary_support != rhs.execution_summary_support) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentSyncClientCapabilities& lhs,
                const NotebookDocumentSyncClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentSyncClientCapabilities& out) {
    if (v.Has("dynamicRegistration")) {
        Boolean val;
        auto member = v.Get("dynamicRegistration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.dynamic_registration = std::move(val);
    }
    if (v.Has("executionSummarySupport")) {
        Boolean val;
        auto member = v.Get("executionSummarySupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.execution_summary_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentSyncClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.dynamic_registration) {
        auto res = Encode(*in.dynamic_registration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"dynamicRegistration", res.Get()});
    }
    if (in.execution_summary_support) {
        auto res = Encode(*in.execution_summary_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"executionSummarySupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentSyncClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentClientCapabilities& lhs,
                const NotebookDocumentClientCapabilities& rhs) {
    if (lhs.synchronization != rhs.synchronization) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentClientCapabilities& lhs,
                const NotebookDocumentClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentClientCapabilities& out) {
    {
        auto member = v.Get("synchronization");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.synchronization); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.synchronization, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"synchronization", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientShowMessageActionItemOptions& lhs,
                const ClientShowMessageActionItemOptions& rhs) {
    if (lhs.additional_properties_support != rhs.additional_properties_support) {
        return false;
    }
    return true;
}

bool operator!=(const ClientShowMessageActionItemOptions& lhs,
                const ClientShowMessageActionItemOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ClientShowMessageActionItemOptions& out) {
    if (v.Has("additionalPropertiesSupport")) {
        Boolean val;
        auto member = v.Get("additionalPropertiesSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.additional_properties_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientShowMessageActionItemOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.additional_properties_support) {
        auto res = Encode(*in.additional_properties_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"additionalPropertiesSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientShowMessageActionItemOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ShowMessageRequestClientCapabilities& lhs,
                const ShowMessageRequestClientCapabilities& rhs) {
    if (lhs.message_action_item != rhs.message_action_item) {
        return false;
    }
    return true;
}

bool operator!=(const ShowMessageRequestClientCapabilities& lhs,
                const ShowMessageRequestClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ShowMessageRequestClientCapabilities& out) {
    if (v.Has("messageActionItem")) {
        lsp::ClientShowMessageActionItemOptions val;
        auto member = v.Get("messageActionItem");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.message_action_item = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ShowMessageRequestClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.message_action_item) {
        auto res = Encode(*in.message_action_item, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"messageActionItem", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ShowMessageRequestClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ShowDocumentClientCapabilities& lhs,
                const ShowDocumentClientCapabilities& rhs) {
    if (lhs.support != rhs.support) {
        return false;
    }
    return true;
}

bool operator!=(const ShowDocumentClientCapabilities& lhs,
                const ShowDocumentClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ShowDocumentClientCapabilities& out) {
    {
        auto member = v.Get("support");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.support); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ShowDocumentClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"support", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ShowDocumentClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WindowClientCapabilities& lhs, const WindowClientCapabilities& rhs) {
    if (lhs.work_done_progress != rhs.work_done_progress) {
        return false;
    }
    if (lhs.show_message != rhs.show_message) {
        return false;
    }
    if (lhs.show_document != rhs.show_document) {
        return false;
    }
    return true;
}

bool operator!=(const WindowClientCapabilities& lhs, const WindowClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WindowClientCapabilities& out) {
    if (v.Has("workDoneProgress")) {
        Boolean val;
        auto member = v.Get("workDoneProgress");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.work_done_progress = std::move(val);
    }
    if (v.Has("showMessage")) {
        lsp::ShowMessageRequestClientCapabilities val;
        auto member = v.Get("showMessage");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.show_message = std::move(val);
    }
    if (v.Has("showDocument")) {
        lsp::ShowDocumentClientCapabilities val;
        auto member = v.Get("showDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.show_document = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WindowClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.work_done_progress) {
        auto res = Encode(*in.work_done_progress, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workDoneProgress", res.Get()});
    }
    if (in.show_message) {
        auto res = Encode(*in.show_message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"showMessage", res.Get()});
    }
    if (in.show_document) {
        auto res = Encode(*in.show_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"showDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WindowClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const StaleRequestSupportOptions& lhs, const StaleRequestSupportOptions& rhs) {
    if (lhs.cancel != rhs.cancel) {
        return false;
    }
    if (lhs.retry_on_content_modified != rhs.retry_on_content_modified) {
        return false;
    }
    return true;
}

bool operator!=(const StaleRequestSupportOptions& lhs, const StaleRequestSupportOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] StaleRequestSupportOptions& out) {
    {
        auto member = v.Get("cancel");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.cancel); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("retryOnContentModified");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.retry_on_content_modified); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const StaleRequestSupportOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.cancel, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cancel", res.Get()});
    }
    {
        auto res = Encode(in.retry_on_content_modified, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"retryOnContentModified", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const StaleRequestSupportOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RegularExpressionsClientCapabilities& lhs,
                const RegularExpressionsClientCapabilities& rhs) {
    if (lhs.engine != rhs.engine) {
        return false;
    }
    if (lhs.version != rhs.version) {
        return false;
    }
    return true;
}

bool operator!=(const RegularExpressionsClientCapabilities& lhs,
                const RegularExpressionsClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] RegularExpressionsClientCapabilities& out) {
    {
        auto member = v.Get("engine");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.engine); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("version")) {
        String val;
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.version = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RegularExpressionsClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.engine, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"engine", res.Get()});
    }
    if (in.version) {
        auto res = Encode(*in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RegularExpressionsClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const MarkdownClientCapabilities& lhs, const MarkdownClientCapabilities& rhs) {
    if (lhs.parser != rhs.parser) {
        return false;
    }
    if (lhs.version != rhs.version) {
        return false;
    }
    if (lhs.allowed_tags != rhs.allowed_tags) {
        return false;
    }
    return true;
}

bool operator!=(const MarkdownClientCapabilities& lhs, const MarkdownClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] MarkdownClientCapabilities& out) {
    {
        auto member = v.Get("parser");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.parser); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("version")) {
        String val;
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.version = std::move(val);
    }
    if (v.Has("allowedTags")) {
        std::vector<String> val;
        auto member = v.Get("allowedTags");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.allowed_tags = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const MarkdownClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.parser, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"parser", res.Get()});
    }
    if (in.version) {
        auto res = Encode(*in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    if (in.allowed_tags) {
        auto res = Encode(*in.allowed_tags, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"allowedTags", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const MarkdownClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const GeneralClientCapabilities& lhs, const GeneralClientCapabilities& rhs) {
    if (lhs.stale_request_support != rhs.stale_request_support) {
        return false;
    }
    if (lhs.regular_expressions != rhs.regular_expressions) {
        return false;
    }
    if (lhs.markdown != rhs.markdown) {
        return false;
    }
    if (lhs.position_encodings != rhs.position_encodings) {
        return false;
    }
    return true;
}

bool operator!=(const GeneralClientCapabilities& lhs, const GeneralClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] GeneralClientCapabilities& out) {
    if (v.Has("staleRequestSupport")) {
        lsp::StaleRequestSupportOptions val;
        auto member = v.Get("staleRequestSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.stale_request_support = std::move(val);
    }
    if (v.Has("regularExpressions")) {
        lsp::RegularExpressionsClientCapabilities val;
        auto member = v.Get("regularExpressions");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.regular_expressions = std::move(val);
    }
    if (v.Has("markdown")) {
        lsp::MarkdownClientCapabilities val;
        auto member = v.Get("markdown");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.markdown = std::move(val);
    }
    if (v.Has("positionEncodings")) {
        std::vector<lsp::PositionEncodingKind> val;
        auto member = v.Get("positionEncodings");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.position_encodings = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const GeneralClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    if (in.stale_request_support) {
        auto res = Encode(*in.stale_request_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"staleRequestSupport", res.Get()});
    }
    if (in.regular_expressions) {
        auto res = Encode(*in.regular_expressions, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"regularExpressions", res.Get()});
    }
    if (in.markdown) {
        auto res = Encode(*in.markdown, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"markdown", res.Get()});
    }
    if (in.position_encodings) {
        auto res = Encode(*in.position_encodings, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"positionEncodings", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const GeneralClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ClientCapabilities& lhs, const ClientCapabilities& rhs) {
    if (lhs.workspace != rhs.workspace) {
        return false;
    }
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.notebook_document != rhs.notebook_document) {
        return false;
    }
    if (lhs.window != rhs.window) {
        return false;
    }
    if (lhs.general != rhs.general) {
        return false;
    }
    if (lhs.experimental != rhs.experimental) {
        return false;
    }
    return true;
}

bool operator!=(const ClientCapabilities& lhs, const ClientCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ClientCapabilities& out) {
    if (v.Has("workspace")) {
        lsp::WorkspaceClientCapabilities val;
        auto member = v.Get("workspace");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.workspace = std::move(val);
    }
    if (v.Has("textDocument")) {
        lsp::TextDocumentClientCapabilities val;
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.text_document = std::move(val);
    }
    if (v.Has("notebookDocument")) {
        lsp::NotebookDocumentClientCapabilities val;
        auto member = v.Get("notebookDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.notebook_document = std::move(val);
    }
    if (v.Has("window")) {
        lsp::WindowClientCapabilities val;
        auto member = v.Get("window");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.window = std::move(val);
    }
    if (v.Has("general")) {
        lsp::GeneralClientCapabilities val;
        auto member = v.Get("general");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.general = std::move(val);
    }
    if (v.Has("experimental")) {
        lsp::LSPAny val;
        auto member = v.Get("experimental");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.experimental = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ClientCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(6);
    if (in.workspace) {
        auto res = Encode(*in.workspace, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workspace", res.Get()});
    }
    if (in.text_document) {
        auto res = Encode(*in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    if (in.notebook_document) {
        auto res = Encode(*in.notebook_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookDocument", res.Get()});
    }
    if (in.window) {
        auto res = Encode(*in.window, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"window", res.Get()});
    }
    if (in.general) {
        auto res = Encode(*in.general, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"general", res.Get()});
    }
    if (in.experimental) {
        auto res = Encode(*in.experimental, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"experimental", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ClientCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InitializeParamsBase& lhs, const InitializeParamsBase& rhs) {
    if (lhs.process_id != rhs.process_id) {
        return false;
    }
    if (lhs.client_info != rhs.client_info) {
        return false;
    }
    if (lhs.locale != rhs.locale) {
        return false;
    }
    if (lhs.root_path != rhs.root_path) {
        return false;
    }
    if (lhs.root_uri != rhs.root_uri) {
        return false;
    }
    if (lhs.capabilities != rhs.capabilities) {
        return false;
    }
    if (lhs.initialization_options != rhs.initialization_options) {
        return false;
    }
    if (lhs.trace != rhs.trace) {
        return false;
    }
    return true;
}

bool operator!=(const InitializeParamsBase& lhs, const InitializeParamsBase& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InitializeParamsBase& out) {
    {
        auto member = v.Get("processId");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.process_id); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("clientInfo")) {
        lsp::ClientInfo val;
        auto member = v.Get("clientInfo");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.client_info = std::move(val);
    }
    if (v.Has("locale")) {
        String val;
        auto member = v.Get("locale");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.locale = std::move(val);
    }
    if (v.Has("rootPath")) {
        OneOf<String, Null> val;
        auto member = v.Get("rootPath");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.root_path = std::move(val);
    }
    {
        auto member = v.Get("rootUri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.root_uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("capabilities");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.capabilities); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("initializationOptions")) {
        lsp::LSPAny val;
        auto member = v.Get("initializationOptions");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.initialization_options = std::move(val);
    }
    if (v.Has("trace")) {
        lsp::TraceValues val;
        auto member = v.Get("trace");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.trace = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InitializeParamsBase& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(8);
    {
        auto res = Encode(in.process_id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"processId", res.Get()});
    }
    if (in.client_info) {
        auto res = Encode(*in.client_info, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"clientInfo", res.Get()});
    }
    if (in.locale) {
        auto res = Encode(*in.locale, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"locale", res.Get()});
    }
    if (in.root_path) {
        auto res = Encode(*in.root_path, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"rootPath", res.Get()});
    }
    {
        auto res = Encode(in.root_uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"rootUri", res.Get()});
    }
    {
        auto res = Encode(in.capabilities, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"capabilities", res.Get()});
    }
    if (in.initialization_options) {
        auto res = Encode(*in.initialization_options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"initializationOptions", res.Get()});
    }
    if (in.trace) {
        auto res = Encode(*in.trace, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"trace", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InitializeParamsBase& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceFoldersInitializeParams& lhs,
                const WorkspaceFoldersInitializeParams& rhs) {
    if (lhs.workspace_folders != rhs.workspace_folders) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceFoldersInitializeParams& lhs,
                const WorkspaceFoldersInitializeParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceFoldersInitializeParams& out) {
    if (v.Has("workspaceFolders")) {
        OneOf<std::vector<lsp::WorkspaceFolder>, Null> val;
        auto member = v.Get("workspaceFolders");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.workspace_folders = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceFoldersInitializeParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.workspace_folders) {
        auto res = Encode(*in.workspace_folders, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workspaceFolders", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceFoldersInitializeParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InitializeParams& lhs, const InitializeParams& rhs) {
    if (static_cast<const InitializeParamsBase&>(lhs) !=
        static_cast<const InitializeParamsBase&>(rhs)) {
        return false;
    }
    if (static_cast<const WorkspaceFoldersInitializeParams&>(lhs) !=
        static_cast<const WorkspaceFoldersInitializeParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const InitializeParams& lhs, const InitializeParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InitializeParams& out) {
    if (auto res = Decode(v, static_cast<InitializeParamsBase&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<WorkspaceFoldersInitializeParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InitializeParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const InitializeParamsBase&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res =
            EncodeMembers(static_cast<const WorkspaceFoldersInitializeParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InitializeParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SaveOptions& lhs, const SaveOptions& rhs) {
    if (lhs.include_text != rhs.include_text) {
        return false;
    }
    return true;
}

bool operator!=(const SaveOptions& lhs, const SaveOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SaveOptions& out) {
    if (v.Has("includeText")) {
        Boolean val;
        auto member = v.Get("includeText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.include_text = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SaveOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.include_text) {
        auto res = Encode(*in.include_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"includeText", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SaveOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentSyncOptions& lhs, const TextDocumentSyncOptions& rhs) {
    if (lhs.open_close != rhs.open_close) {
        return false;
    }
    if (lhs.change != rhs.change) {
        return false;
    }
    if (lhs.will_save != rhs.will_save) {
        return false;
    }
    if (lhs.will_save_wait_until != rhs.will_save_wait_until) {
        return false;
    }
    if (lhs.save != rhs.save) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentSyncOptions& lhs, const TextDocumentSyncOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TextDocumentSyncOptions& out) {
    if (v.Has("openClose")) {
        Boolean val;
        auto member = v.Get("openClose");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.open_close = std::move(val);
    }
    if (v.Has("change")) {
        lsp::TextDocumentSyncKind val;
        auto member = v.Get("change");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.change = std::move(val);
    }
    if (v.Has("willSave")) {
        Boolean val;
        auto member = v.Get("willSave");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_save = std::move(val);
    }
    if (v.Has("willSaveWaitUntil")) {
        Boolean val;
        auto member = v.Get("willSaveWaitUntil");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_save_wait_until = std::move(val);
    }
    if (v.Has("save")) {
        OneOf<Boolean, lsp::SaveOptions> val;
        auto member = v.Get("save");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.save = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentSyncOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(5);
    if (in.open_close) {
        auto res = Encode(*in.open_close, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"openClose", res.Get()});
    }
    if (in.change) {
        auto res = Encode(*in.change, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"change", res.Get()});
    }
    if (in.will_save) {
        auto res = Encode(*in.will_save, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willSave", res.Get()});
    }
    if (in.will_save_wait_until) {
        auto res = Encode(*in.will_save_wait_until, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willSaveWaitUntil", res.Get()});
    }
    if (in.save) {
        auto res = Encode(*in.save, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"save", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentSyncOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookCellLanguage& lhs, const NotebookCellLanguage& rhs) {
    if (lhs.language != rhs.language) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookCellLanguage& lhs, const NotebookCellLanguage& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] NotebookCellLanguage& out) {
    {
        auto member = v.Get("language");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.language); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookCellLanguage& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.language, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"language", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookCellLanguage& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentFilterWithCells& lhs,
                const NotebookDocumentFilterWithCells& rhs) {
    if (lhs.notebook != rhs.notebook) {
        return false;
    }
    if (lhs.cells != rhs.cells) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentFilterWithCells& lhs,
                const NotebookDocumentFilterWithCells& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentFilterWithCells& out) {
    if (v.Has("notebook")) {
        OneOf<String, lsp::NotebookDocumentFilter> val;
        auto member = v.Get("notebook");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.notebook = std::move(val);
    }
    {
        auto member = v.Get("cells");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.cells); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentFilterWithCells& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.notebook) {
        auto res = Encode(*in.notebook, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebook", res.Get()});
    }
    {
        auto res = Encode(in.cells, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cells", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentFilterWithCells& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentFilterWithNotebook& lhs,
                const NotebookDocumentFilterWithNotebook& rhs) {
    if (lhs.notebook != rhs.notebook) {
        return false;
    }
    if (lhs.cells != rhs.cells) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentFilterWithNotebook& lhs,
                const NotebookDocumentFilterWithNotebook& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentFilterWithNotebook& out) {
    {
        auto member = v.Get("notebook");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.notebook); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("cells")) {
        std::vector<lsp::NotebookCellLanguage> val;
        auto member = v.Get("cells");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.cells = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentFilterWithNotebook& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.notebook, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebook", res.Get()});
    }
    if (in.cells) {
        auto res = Encode(*in.cells, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cells", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentFilterWithNotebook& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentSyncOptions& lhs, const NotebookDocumentSyncOptions& rhs) {
    if (lhs.notebook_selector != rhs.notebook_selector) {
        return false;
    }
    if (lhs.save != rhs.save) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentSyncOptions& lhs, const NotebookDocumentSyncOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentSyncOptions& out) {
    {
        auto member = v.Get("notebookSelector");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.notebook_selector); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("save")) {
        Boolean val;
        auto member = v.Get("save");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.save = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentSyncOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.notebook_selector, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookSelector", res.Get()});
    }
    if (in.save) {
        auto res = Encode(*in.save, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"save", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentSyncOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentSyncRegistrationOptions& lhs,
                const NotebookDocumentSyncRegistrationOptions& rhs) {
    if (static_cast<const NotebookDocumentSyncOptions&>(lhs) !=
        static_cast<const NotebookDocumentSyncOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentSyncRegistrationOptions& lhs,
                const NotebookDocumentSyncRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentSyncRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<NotebookDocumentSyncOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentSyncRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const NotebookDocumentSyncOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const NotebookDocumentSyncRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ServerCompletionItemOptions& lhs, const ServerCompletionItemOptions& rhs) {
    if (lhs.label_details_support != rhs.label_details_support) {
        return false;
    }
    return true;
}

bool operator!=(const ServerCompletionItemOptions& lhs, const ServerCompletionItemOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ServerCompletionItemOptions& out) {
    if (v.Has("labelDetailsSupport")) {
        Boolean val;
        auto member = v.Get("labelDetailsSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.label_details_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ServerCompletionItemOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.label_details_support) {
        auto res = Encode(*in.label_details_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"labelDetailsSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ServerCompletionItemOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionOptions& lhs, const CompletionOptions& rhs) {
    if (lhs.trigger_characters != rhs.trigger_characters) {
        return false;
    }
    if (lhs.all_commit_characters != rhs.all_commit_characters) {
        return false;
    }
    if (lhs.resolve_provider != rhs.resolve_provider) {
        return false;
    }
    if (lhs.completion_item != rhs.completion_item) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionOptions& lhs, const CompletionOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CompletionOptions& out) {
    if (v.Has("triggerCharacters")) {
        std::vector<String> val;
        auto member = v.Get("triggerCharacters");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.trigger_characters = std::move(val);
    }
    if (v.Has("allCommitCharacters")) {
        std::vector<String> val;
        auto member = v.Get("allCommitCharacters");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.all_commit_characters = std::move(val);
    }
    if (v.Has("resolveProvider")) {
        Boolean val;
        auto member = v.Get("resolveProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_provider = std::move(val);
    }
    if (v.Has("completionItem")) {
        lsp::ServerCompletionItemOptions val;
        auto member = v.Get("completionItem");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.completion_item = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    if (in.trigger_characters) {
        auto res = Encode(*in.trigger_characters, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"triggerCharacters", res.Get()});
    }
    if (in.all_commit_characters) {
        auto res = Encode(*in.all_commit_characters, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"allCommitCharacters", res.Get()});
    }
    if (in.resolve_provider) {
        auto res = Encode(*in.resolve_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveProvider", res.Get()});
    }
    if (in.completion_item) {
        auto res = Encode(*in.completion_item, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"completionItem", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const HoverOptions& lhs, const HoverOptions& rhs) {
    return true;
}

bool operator!=(const HoverOptions& lhs, const HoverOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] HoverOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const HoverOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const HoverOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SignatureHelpOptions& lhs, const SignatureHelpOptions& rhs) {
    if (lhs.trigger_characters != rhs.trigger_characters) {
        return false;
    }
    if (lhs.retrigger_characters != rhs.retrigger_characters) {
        return false;
    }
    return true;
}

bool operator!=(const SignatureHelpOptions& lhs, const SignatureHelpOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SignatureHelpOptions& out) {
    if (v.Has("triggerCharacters")) {
        std::vector<String> val;
        auto member = v.Get("triggerCharacters");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.trigger_characters = std::move(val);
    }
    if (v.Has("retriggerCharacters")) {
        std::vector<String> val;
        auto member = v.Get("retriggerCharacters");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.retrigger_characters = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SignatureHelpOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.trigger_characters) {
        auto res = Encode(*in.trigger_characters, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"triggerCharacters", res.Get()});
    }
    if (in.retrigger_characters) {
        auto res = Encode(*in.retrigger_characters, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"retriggerCharacters", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SignatureHelpOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DefinitionOptions& lhs, const DefinitionOptions& rhs) {
    return true;
}

bool operator!=(const DefinitionOptions& lhs, const DefinitionOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DefinitionOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DefinitionOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DefinitionOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ReferenceOptions& lhs, const ReferenceOptions& rhs) {
    return true;
}

bool operator!=(const ReferenceOptions& lhs, const ReferenceOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ReferenceOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ReferenceOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ReferenceOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentHighlightOptions& lhs, const DocumentHighlightOptions& rhs) {
    return true;
}

bool operator!=(const DocumentHighlightOptions& lhs, const DocumentHighlightOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentHighlightOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentHighlightOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentHighlightOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentSymbolOptions& lhs, const DocumentSymbolOptions& rhs) {
    if (lhs.label != rhs.label) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentSymbolOptions& lhs, const DocumentSymbolOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentSymbolOptions& out) {
    if (v.Has("label")) {
        String val;
        auto member = v.Get("label");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.label = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentSymbolOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.label) {
        auto res = Encode(*in.label, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"label", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentSymbolOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeActionOptions& lhs, const CodeActionOptions& rhs) {
    if (lhs.code_action_kinds != rhs.code_action_kinds) {
        return false;
    }
    if (lhs.resolve_provider != rhs.resolve_provider) {
        return false;
    }
    return true;
}

bool operator!=(const CodeActionOptions& lhs, const CodeActionOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CodeActionOptions& out) {
    if (v.Has("codeActionKinds")) {
        std::vector<lsp::CodeActionKind> val;
        auto member = v.Get("codeActionKinds");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code_action_kinds = std::move(val);
    }
    if (v.Has("resolveProvider")) {
        Boolean val;
        auto member = v.Get("resolveProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_provider = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeActionOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.code_action_kinds) {
        auto res = Encode(*in.code_action_kinds, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeActionKinds", res.Get()});
    }
    if (in.resolve_provider) {
        auto res = Encode(*in.resolve_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveProvider", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeActionOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeLensOptions& lhs, const CodeLensOptions& rhs) {
    if (lhs.resolve_provider != rhs.resolve_provider) {
        return false;
    }
    return true;
}

bool operator!=(const CodeLensOptions& lhs, const CodeLensOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CodeLensOptions& out) {
    if (v.Has("resolveProvider")) {
        Boolean val;
        auto member = v.Get("resolveProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_provider = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeLensOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.resolve_provider) {
        auto res = Encode(*in.resolve_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveProvider", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeLensOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentLinkOptions& lhs, const DocumentLinkOptions& rhs) {
    if (lhs.resolve_provider != rhs.resolve_provider) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentLinkOptions& lhs, const DocumentLinkOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentLinkOptions& out) {
    if (v.Has("resolveProvider")) {
        Boolean val;
        auto member = v.Get("resolveProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_provider = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentLinkOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.resolve_provider) {
        auto res = Encode(*in.resolve_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveProvider", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentLinkOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceSymbolOptions& lhs, const WorkspaceSymbolOptions& rhs) {
    if (lhs.resolve_provider != rhs.resolve_provider) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceSymbolOptions& lhs, const WorkspaceSymbolOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkspaceSymbolOptions& out) {
    if (v.Has("resolveProvider")) {
        Boolean val;
        auto member = v.Get("resolveProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.resolve_provider = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceSymbolOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.resolve_provider) {
        auto res = Encode(*in.resolve_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"resolveProvider", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceSymbolOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentFormattingOptions& lhs, const DocumentFormattingOptions& rhs) {
    return true;
}

bool operator!=(const DocumentFormattingOptions& lhs, const DocumentFormattingOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentFormattingOptions& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentFormattingOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentFormattingOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentRangeFormattingOptions& lhs,
                const DocumentRangeFormattingOptions& rhs) {
    if (lhs.ranges_support != rhs.ranges_support) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentRangeFormattingOptions& lhs,
                const DocumentRangeFormattingOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentRangeFormattingOptions& out) {
    if (v.Has("rangesSupport")) {
        Boolean val;
        auto member = v.Get("rangesSupport");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.ranges_support = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentRangeFormattingOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.ranges_support) {
        auto res = Encode(*in.ranges_support, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"rangesSupport", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentRangeFormattingOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentOnTypeFormattingOptions& lhs,
                const DocumentOnTypeFormattingOptions& rhs) {
    if (lhs.first_trigger_character != rhs.first_trigger_character) {
        return false;
    }
    if (lhs.more_trigger_character != rhs.more_trigger_character) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentOnTypeFormattingOptions& lhs,
                const DocumentOnTypeFormattingOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentOnTypeFormattingOptions& out) {
    {
        auto member = v.Get("firstTriggerCharacter");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.first_trigger_character); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("moreTriggerCharacter")) {
        std::vector<String> val;
        auto member = v.Get("moreTriggerCharacter");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.more_trigger_character = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentOnTypeFormattingOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.first_trigger_character, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"firstTriggerCharacter", res.Get()});
    }
    if (in.more_trigger_character) {
        auto res = Encode(*in.more_trigger_character, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"moreTriggerCharacter", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentOnTypeFormattingOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RenameOptions& lhs, const RenameOptions& rhs) {
    if (lhs.prepare_provider != rhs.prepare_provider) {
        return false;
    }
    return true;
}

bool operator!=(const RenameOptions& lhs, const RenameOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] RenameOptions& out) {
    if (v.Has("prepareProvider")) {
        Boolean val;
        auto member = v.Get("prepareProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.prepare_provider = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RenameOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.prepare_provider) {
        auto res = Encode(*in.prepare_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"prepareProvider", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RenameOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ExecuteCommandOptions& lhs, const ExecuteCommandOptions& rhs) {
    if (lhs.commands != rhs.commands) {
        return false;
    }
    return true;
}

bool operator!=(const ExecuteCommandOptions& lhs, const ExecuteCommandOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ExecuteCommandOptions& out) {
    {
        auto member = v.Get("commands");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.commands); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ExecuteCommandOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.commands, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"commands", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ExecuteCommandOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceFoldersServerCapabilities& lhs,
                const WorkspaceFoldersServerCapabilities& rhs) {
    if (lhs.supported != rhs.supported) {
        return false;
    }
    if (lhs.change_notifications != rhs.change_notifications) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceFoldersServerCapabilities& lhs,
                const WorkspaceFoldersServerCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceFoldersServerCapabilities& out) {
    if (v.Has("supported")) {
        Boolean val;
        auto member = v.Get("supported");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.supported = std::move(val);
    }
    if (v.Has("changeNotifications")) {
        OneOf<String, Boolean> val;
        auto member = v.Get("changeNotifications");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.change_notifications = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceFoldersServerCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.supported) {
        auto res = Encode(*in.supported, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"supported", res.Get()});
    }
    if (in.change_notifications) {
        auto res = Encode(*in.change_notifications, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"changeNotifications", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceFoldersServerCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileOperationOptions& lhs, const FileOperationOptions& rhs) {
    if (lhs.did_create != rhs.did_create) {
        return false;
    }
    if (lhs.will_create != rhs.will_create) {
        return false;
    }
    if (lhs.did_rename != rhs.did_rename) {
        return false;
    }
    if (lhs.will_rename != rhs.will_rename) {
        return false;
    }
    if (lhs.did_delete != rhs.did_delete) {
        return false;
    }
    if (lhs.will_delete != rhs.will_delete) {
        return false;
    }
    return true;
}

bool operator!=(const FileOperationOptions& lhs, const FileOperationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FileOperationOptions& out) {
    if (v.Has("didCreate")) {
        lsp::FileOperationRegistrationOptions val;
        auto member = v.Get("didCreate");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_create = std::move(val);
    }
    if (v.Has("willCreate")) {
        lsp::FileOperationRegistrationOptions val;
        auto member = v.Get("willCreate");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_create = std::move(val);
    }
    if (v.Has("didRename")) {
        lsp::FileOperationRegistrationOptions val;
        auto member = v.Get("didRename");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_rename = std::move(val);
    }
    if (v.Has("willRename")) {
        lsp::FileOperationRegistrationOptions val;
        auto member = v.Get("willRename");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_rename = std::move(val);
    }
    if (v.Has("didDelete")) {
        lsp::FileOperationRegistrationOptions val;
        auto member = v.Get("didDelete");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.did_delete = std::move(val);
    }
    if (v.Has("willDelete")) {
        lsp::FileOperationRegistrationOptions val;
        auto member = v.Get("willDelete");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.will_delete = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileOperationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(6);
    if (in.did_create) {
        auto res = Encode(*in.did_create, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didCreate", res.Get()});
    }
    if (in.will_create) {
        auto res = Encode(*in.will_create, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willCreate", res.Get()});
    }
    if (in.did_rename) {
        auto res = Encode(*in.did_rename, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didRename", res.Get()});
    }
    if (in.will_rename) {
        auto res = Encode(*in.will_rename, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willRename", res.Get()});
    }
    if (in.did_delete) {
        auto res = Encode(*in.did_delete, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"didDelete", res.Get()});
    }
    if (in.will_delete) {
        auto res = Encode(*in.will_delete, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"willDelete", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileOperationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceOptions& lhs, const WorkspaceOptions& rhs) {
    if (lhs.workspace_folders != rhs.workspace_folders) {
        return false;
    }
    if (lhs.file_operations != rhs.file_operations) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceOptions& lhs, const WorkspaceOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkspaceOptions& out) {
    if (v.Has("workspaceFolders")) {
        lsp::WorkspaceFoldersServerCapabilities val;
        auto member = v.Get("workspaceFolders");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.workspace_folders = std::move(val);
    }
    if (v.Has("fileOperations")) {
        lsp::FileOperationOptions val;
        auto member = v.Get("fileOperations");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.file_operations = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.workspace_folders) {
        auto res = Encode(*in.workspace_folders, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workspaceFolders", res.Get()});
    }
    if (in.file_operations) {
        auto res = Encode(*in.file_operations, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"fileOperations", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ServerCapabilities& lhs, const ServerCapabilities& rhs) {
    if (lhs.position_encoding != rhs.position_encoding) {
        return false;
    }
    if (lhs.text_document_sync != rhs.text_document_sync) {
        return false;
    }
    if (lhs.notebook_document_sync != rhs.notebook_document_sync) {
        return false;
    }
    if (lhs.completion_provider != rhs.completion_provider) {
        return false;
    }
    if (lhs.hover_provider != rhs.hover_provider) {
        return false;
    }
    if (lhs.signature_help_provider != rhs.signature_help_provider) {
        return false;
    }
    if (lhs.declaration_provider != rhs.declaration_provider) {
        return false;
    }
    if (lhs.definition_provider != rhs.definition_provider) {
        return false;
    }
    if (lhs.type_definition_provider != rhs.type_definition_provider) {
        return false;
    }
    if (lhs.implementation_provider != rhs.implementation_provider) {
        return false;
    }
    if (lhs.references_provider != rhs.references_provider) {
        return false;
    }
    if (lhs.document_highlight_provider != rhs.document_highlight_provider) {
        return false;
    }
    if (lhs.document_symbol_provider != rhs.document_symbol_provider) {
        return false;
    }
    if (lhs.code_action_provider != rhs.code_action_provider) {
        return false;
    }
    if (lhs.code_lens_provider != rhs.code_lens_provider) {
        return false;
    }
    if (lhs.document_link_provider != rhs.document_link_provider) {
        return false;
    }
    if (lhs.color_provider != rhs.color_provider) {
        return false;
    }
    if (lhs.workspace_symbol_provider != rhs.workspace_symbol_provider) {
        return false;
    }
    if (lhs.document_formatting_provider != rhs.document_formatting_provider) {
        return false;
    }
    if (lhs.document_range_formatting_provider != rhs.document_range_formatting_provider) {
        return false;
    }
    if (lhs.document_on_type_formatting_provider != rhs.document_on_type_formatting_provider) {
        return false;
    }
    if (lhs.rename_provider != rhs.rename_provider) {
        return false;
    }
    if (lhs.folding_range_provider != rhs.folding_range_provider) {
        return false;
    }
    if (lhs.selection_range_provider != rhs.selection_range_provider) {
        return false;
    }
    if (lhs.execute_command_provider != rhs.execute_command_provider) {
        return false;
    }
    if (lhs.call_hierarchy_provider != rhs.call_hierarchy_provider) {
        return false;
    }
    if (lhs.linked_editing_range_provider != rhs.linked_editing_range_provider) {
        return false;
    }
    if (lhs.semantic_tokens_provider != rhs.semantic_tokens_provider) {
        return false;
    }
    if (lhs.moniker_provider != rhs.moniker_provider) {
        return false;
    }
    if (lhs.type_hierarchy_provider != rhs.type_hierarchy_provider) {
        return false;
    }
    if (lhs.inline_value_provider != rhs.inline_value_provider) {
        return false;
    }
    if (lhs.inlay_hint_provider != rhs.inlay_hint_provider) {
        return false;
    }
    if (lhs.diagnostic_provider != rhs.diagnostic_provider) {
        return false;
    }
    if (lhs.inline_completion_provider != rhs.inline_completion_provider) {
        return false;
    }
    if (lhs.workspace != rhs.workspace) {
        return false;
    }
    if (lhs.experimental != rhs.experimental) {
        return false;
    }
    return true;
}

bool operator!=(const ServerCapabilities& lhs, const ServerCapabilities& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ServerCapabilities& out) {
    if (v.Has("positionEncoding")) {
        lsp::PositionEncodingKind val;
        auto member = v.Get("positionEncoding");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.position_encoding = std::move(val);
    }
    if (v.Has("textDocumentSync")) {
        OneOf<lsp::TextDocumentSyncOptions, lsp::TextDocumentSyncKind> val;
        auto member = v.Get("textDocumentSync");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.text_document_sync = std::move(val);
    }
    if (v.Has("notebookDocumentSync")) {
        OneOf<lsp::NotebookDocumentSyncOptions, lsp::NotebookDocumentSyncRegistrationOptions> val;
        auto member = v.Get("notebookDocumentSync");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.notebook_document_sync = std::move(val);
    }
    if (v.Has("completionProvider")) {
        lsp::CompletionOptions val;
        auto member = v.Get("completionProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.completion_provider = std::move(val);
    }
    if (v.Has("hoverProvider")) {
        OneOf<Boolean, lsp::HoverOptions> val;
        auto member = v.Get("hoverProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.hover_provider = std::move(val);
    }
    if (v.Has("signatureHelpProvider")) {
        lsp::SignatureHelpOptions val;
        auto member = v.Get("signatureHelpProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.signature_help_provider = std::move(val);
    }
    if (v.Has("declarationProvider")) {
        OneOf<Boolean, lsp::DeclarationOptions, lsp::DeclarationRegistrationOptions> val;
        auto member = v.Get("declarationProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.declaration_provider = std::move(val);
    }
    if (v.Has("definitionProvider")) {
        OneOf<Boolean, lsp::DefinitionOptions> val;
        auto member = v.Get("definitionProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.definition_provider = std::move(val);
    }
    if (v.Has("typeDefinitionProvider")) {
        OneOf<Boolean, lsp::TypeDefinitionOptions, lsp::TypeDefinitionRegistrationOptions> val;
        auto member = v.Get("typeDefinitionProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.type_definition_provider = std::move(val);
    }
    if (v.Has("implementationProvider")) {
        OneOf<Boolean, lsp::ImplementationOptions, lsp::ImplementationRegistrationOptions> val;
        auto member = v.Get("implementationProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.implementation_provider = std::move(val);
    }
    if (v.Has("referencesProvider")) {
        OneOf<Boolean, lsp::ReferenceOptions> val;
        auto member = v.Get("referencesProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.references_provider = std::move(val);
    }
    if (v.Has("documentHighlightProvider")) {
        OneOf<Boolean, lsp::DocumentHighlightOptions> val;
        auto member = v.Get("documentHighlightProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_highlight_provider = std::move(val);
    }
    if (v.Has("documentSymbolProvider")) {
        OneOf<Boolean, lsp::DocumentSymbolOptions> val;
        auto member = v.Get("documentSymbolProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_symbol_provider = std::move(val);
    }
    if (v.Has("codeActionProvider")) {
        OneOf<Boolean, lsp::CodeActionOptions> val;
        auto member = v.Get("codeActionProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code_action_provider = std::move(val);
    }
    if (v.Has("codeLensProvider")) {
        lsp::CodeLensOptions val;
        auto member = v.Get("codeLensProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.code_lens_provider = std::move(val);
    }
    if (v.Has("documentLinkProvider")) {
        lsp::DocumentLinkOptions val;
        auto member = v.Get("documentLinkProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_link_provider = std::move(val);
    }
    if (v.Has("colorProvider")) {
        OneOf<Boolean, lsp::DocumentColorOptions, lsp::DocumentColorRegistrationOptions> val;
        auto member = v.Get("colorProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.color_provider = std::move(val);
    }
    if (v.Has("workspaceSymbolProvider")) {
        OneOf<Boolean, lsp::WorkspaceSymbolOptions> val;
        auto member = v.Get("workspaceSymbolProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.workspace_symbol_provider = std::move(val);
    }
    if (v.Has("documentFormattingProvider")) {
        OneOf<Boolean, lsp::DocumentFormattingOptions> val;
        auto member = v.Get("documentFormattingProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_formatting_provider = std::move(val);
    }
    if (v.Has("documentRangeFormattingProvider")) {
        OneOf<Boolean, lsp::DocumentRangeFormattingOptions> val;
        auto member = v.Get("documentRangeFormattingProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_range_formatting_provider = std::move(val);
    }
    if (v.Has("documentOnTypeFormattingProvider")) {
        lsp::DocumentOnTypeFormattingOptions val;
        auto member = v.Get("documentOnTypeFormattingProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.document_on_type_formatting_provider = std::move(val);
    }
    if (v.Has("renameProvider")) {
        OneOf<Boolean, lsp::RenameOptions> val;
        auto member = v.Get("renameProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.rename_provider = std::move(val);
    }
    if (v.Has("foldingRangeProvider")) {
        OneOf<Boolean, lsp::FoldingRangeOptions, lsp::FoldingRangeRegistrationOptions> val;
        auto member = v.Get("foldingRangeProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.folding_range_provider = std::move(val);
    }
    if (v.Has("selectionRangeProvider")) {
        OneOf<Boolean, lsp::SelectionRangeOptions, lsp::SelectionRangeRegistrationOptions> val;
        auto member = v.Get("selectionRangeProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.selection_range_provider = std::move(val);
    }
    if (v.Has("executeCommandProvider")) {
        lsp::ExecuteCommandOptions val;
        auto member = v.Get("executeCommandProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.execute_command_provider = std::move(val);
    }
    if (v.Has("callHierarchyProvider")) {
        OneOf<Boolean, lsp::CallHierarchyOptions, lsp::CallHierarchyRegistrationOptions> val;
        auto member = v.Get("callHierarchyProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.call_hierarchy_provider = std::move(val);
    }
    if (v.Has("linkedEditingRangeProvider")) {
        OneOf<Boolean, lsp::LinkedEditingRangeOptions, lsp::LinkedEditingRangeRegistrationOptions>
            val;
        auto member = v.Get("linkedEditingRangeProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.linked_editing_range_provider = std::move(val);
    }
    if (v.Has("semanticTokensProvider")) {
        OneOf<lsp::SemanticTokensOptions, lsp::SemanticTokensRegistrationOptions> val;
        auto member = v.Get("semanticTokensProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.semantic_tokens_provider = std::move(val);
    }
    if (v.Has("monikerProvider")) {
        OneOf<Boolean, lsp::MonikerOptions, lsp::MonikerRegistrationOptions> val;
        auto member = v.Get("monikerProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.moniker_provider = std::move(val);
    }
    if (v.Has("typeHierarchyProvider")) {
        OneOf<Boolean, lsp::TypeHierarchyOptions, lsp::TypeHierarchyRegistrationOptions> val;
        auto member = v.Get("typeHierarchyProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.type_hierarchy_provider = std::move(val);
    }
    if (v.Has("inlineValueProvider")) {
        OneOf<Boolean, lsp::InlineValueOptions, lsp::InlineValueRegistrationOptions> val;
        auto member = v.Get("inlineValueProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.inline_value_provider = std::move(val);
    }
    if (v.Has("inlayHintProvider")) {
        OneOf<Boolean, lsp::InlayHintOptions, lsp::InlayHintRegistrationOptions> val;
        auto member = v.Get("inlayHintProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.inlay_hint_provider = std::move(val);
    }
    if (v.Has("diagnosticProvider")) {
        OneOf<lsp::DiagnosticOptions, lsp::DiagnosticRegistrationOptions> val;
        auto member = v.Get("diagnosticProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.diagnostic_provider = std::move(val);
    }
    if (v.Has("inlineCompletionProvider")) {
        OneOf<Boolean, lsp::InlineCompletionOptions> val;
        auto member = v.Get("inlineCompletionProvider");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.inline_completion_provider = std::move(val);
    }
    if (v.Has("workspace")) {
        lsp::WorkspaceOptions val;
        auto member = v.Get("workspace");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.workspace = std::move(val);
    }
    if (v.Has("experimental")) {
        lsp::LSPAny val;
        auto member = v.Get("experimental");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.experimental = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ServerCapabilities& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(36);
    if (in.position_encoding) {
        auto res = Encode(*in.position_encoding, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"positionEncoding", res.Get()});
    }
    if (in.text_document_sync) {
        auto res = Encode(*in.text_document_sync, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocumentSync", res.Get()});
    }
    if (in.notebook_document_sync) {
        auto res = Encode(*in.notebook_document_sync, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookDocumentSync", res.Get()});
    }
    if (in.completion_provider) {
        auto res = Encode(*in.completion_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"completionProvider", res.Get()});
    }
    if (in.hover_provider) {
        auto res = Encode(*in.hover_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"hoverProvider", res.Get()});
    }
    if (in.signature_help_provider) {
        auto res = Encode(*in.signature_help_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"signatureHelpProvider", res.Get()});
    }
    if (in.declaration_provider) {
        auto res = Encode(*in.declaration_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"declarationProvider", res.Get()});
    }
    if (in.definition_provider) {
        auto res = Encode(*in.definition_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"definitionProvider", res.Get()});
    }
    if (in.type_definition_provider) {
        auto res = Encode(*in.type_definition_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"typeDefinitionProvider", res.Get()});
    }
    if (in.implementation_provider) {
        auto res = Encode(*in.implementation_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"implementationProvider", res.Get()});
    }
    if (in.references_provider) {
        auto res = Encode(*in.references_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"referencesProvider", res.Get()});
    }
    if (in.document_highlight_provider) {
        auto res = Encode(*in.document_highlight_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentHighlightProvider", res.Get()});
    }
    if (in.document_symbol_provider) {
        auto res = Encode(*in.document_symbol_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentSymbolProvider", res.Get()});
    }
    if (in.code_action_provider) {
        auto res = Encode(*in.code_action_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeActionProvider", res.Get()});
    }
    if (in.code_lens_provider) {
        auto res = Encode(*in.code_lens_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"codeLensProvider", res.Get()});
    }
    if (in.document_link_provider) {
        auto res = Encode(*in.document_link_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentLinkProvider", res.Get()});
    }
    if (in.color_provider) {
        auto res = Encode(*in.color_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"colorProvider", res.Get()});
    }
    if (in.workspace_symbol_provider) {
        auto res = Encode(*in.workspace_symbol_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workspaceSymbolProvider", res.Get()});
    }
    if (in.document_formatting_provider) {
        auto res = Encode(*in.document_formatting_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentFormattingProvider", res.Get()});
    }
    if (in.document_range_formatting_provider) {
        auto res = Encode(*in.document_range_formatting_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentRangeFormattingProvider", res.Get()});
    }
    if (in.document_on_type_formatting_provider) {
        auto res = Encode(*in.document_on_type_formatting_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentOnTypeFormattingProvider", res.Get()});
    }
    if (in.rename_provider) {
        auto res = Encode(*in.rename_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"renameProvider", res.Get()});
    }
    if (in.folding_range_provider) {
        auto res = Encode(*in.folding_range_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"foldingRangeProvider", res.Get()});
    }
    if (in.selection_range_provider) {
        auto res = Encode(*in.selection_range_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"selectionRangeProvider", res.Get()});
    }
    if (in.execute_command_provider) {
        auto res = Encode(*in.execute_command_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"executeCommandProvider", res.Get()});
    }
    if (in.call_hierarchy_provider) {
        auto res = Encode(*in.call_hierarchy_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"callHierarchyProvider", res.Get()});
    }
    if (in.linked_editing_range_provider) {
        auto res = Encode(*in.linked_editing_range_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"linkedEditingRangeProvider", res.Get()});
    }
    if (in.semantic_tokens_provider) {
        auto res = Encode(*in.semantic_tokens_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"semanticTokensProvider", res.Get()});
    }
    if (in.moniker_provider) {
        auto res = Encode(*in.moniker_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"monikerProvider", res.Get()});
    }
    if (in.type_hierarchy_provider) {
        auto res = Encode(*in.type_hierarchy_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"typeHierarchyProvider", res.Get()});
    }
    if (in.inline_value_provider) {
        auto res = Encode(*in.inline_value_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"inlineValueProvider", res.Get()});
    }
    if (in.inlay_hint_provider) {
        auto res = Encode(*in.inlay_hint_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"inlayHintProvider", res.Get()});
    }
    if (in.diagnostic_provider) {
        auto res = Encode(*in.diagnostic_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"diagnosticProvider", res.Get()});
    }
    if (in.inline_completion_provider) {
        auto res = Encode(*in.inline_completion_provider, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"inlineCompletionProvider", res.Get()});
    }
    if (in.workspace) {
        auto res = Encode(*in.workspace, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workspace", res.Get()});
    }
    if (in.experimental) {
        auto res = Encode(*in.experimental, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"experimental", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ServerCapabilities& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ServerInfo& lhs, const ServerInfo& rhs) {
    if (lhs.name != rhs.name) {
        return false;
    }
    if (lhs.version != rhs.version) {
        return false;
    }
    return true;
}

bool operator!=(const ServerInfo& lhs, const ServerInfo& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ServerInfo& out) {
    {
        auto member = v.Get("name");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.name); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("version")) {
        String val;
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.version = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ServerInfo& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"name", res.Get()});
    }
    if (in.version) {
        auto res = Encode(*in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ServerInfo& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InitializeResult& lhs, const InitializeResult& rhs) {
    if (lhs.capabilities != rhs.capabilities) {
        return false;
    }
    if (lhs.server_info != rhs.server_info) {
        return false;
    }
    return true;
}

bool operator!=(const InitializeResult& lhs, const InitializeResult& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InitializeResult& out) {
    {
        auto member = v.Get("capabilities");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.capabilities); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("serverInfo")) {
        lsp::ServerInfo val;
        auto member = v.Get("serverInfo");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.server_info = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InitializeResult& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.capabilities, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"capabilities", res.Get()});
    }
    if (in.server_info) {
        auto res = Encode(*in.server_info, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"serverInfo", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InitializeResult& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InitializeError& lhs, const InitializeError& rhs) {
    if (lhs.retry != rhs.retry) {
        return false;
    }
    return true;
}

bool operator!=(const InitializeError& lhs, const InitializeError& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InitializeError& out) {
    {
        auto member = v.Get("retry");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.retry); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InitializeError& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.retry, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"retry", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InitializeError& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InitializedParams& lhs, const InitializedParams& rhs) {
    return true;
}

bool operator!=(const InitializedParams& lhs, const InitializedParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InitializedParams& out) {
    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InitializedParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InitializedParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidChangeConfigurationParams& lhs, const DidChangeConfigurationParams& rhs) {
    if (lhs.settings != rhs.settings) {
        return false;
    }
    return true;
}

bool operator!=(const DidChangeConfigurationParams& lhs, const DidChangeConfigurationParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidChangeConfigurationParams& out) {
    {
        auto member = v.Get("settings");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.settings); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidChangeConfigurationParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.settings, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"settings", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidChangeConfigurationParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidChangeConfigurationRegistrationOptions& lhs,
                const DidChangeConfigurationRegistrationOptions& rhs) {
    if (lhs.section != rhs.section) {
        return false;
    }
    return true;
}

bool operator!=(const DidChangeConfigurationRegistrationOptions& lhs,
                const DidChangeConfigurationRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidChangeConfigurationRegistrationOptions& out) {
    if (v.Has("section")) {
        OneOf<String, std::vector<String>> val;
        auto member = v.Get("section");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.section = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidChangeConfigurationRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.section) {
        auto res = Encode(*in.section, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"section", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const DidChangeConfigurationRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ShowMessageParams& lhs, const ShowMessageParams& rhs) {
    if (lhs.type != rhs.type) {
        return false;
    }
    if (lhs.message != rhs.message) {
        return false;
    }
    return true;
}

bool operator!=(const ShowMessageParams& lhs, const ShowMessageParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ShowMessageParams& out) {
    {
        auto member = v.Get("type");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.type); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("message");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.message); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ShowMessageParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.type, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"type", res.Get()});
    }
    {
        auto res = Encode(in.message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"message", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ShowMessageParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const MessageActionItem& lhs, const MessageActionItem& rhs) {
    if (lhs.title != rhs.title) {
        return false;
    }
    return true;
}

bool operator!=(const MessageActionItem& lhs, const MessageActionItem& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] MessageActionItem& out) {
    {
        auto member = v.Get("title");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.title); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const MessageActionItem& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.title, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"title", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const MessageActionItem& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ShowMessageRequestParams& lhs, const ShowMessageRequestParams& rhs) {
    if (lhs.type != rhs.type) {
        return false;
    }
    if (lhs.message != rhs.message) {
        return false;
    }
    if (lhs.actions != rhs.actions) {
        return false;
    }
    return true;
}

bool operator!=(const ShowMessageRequestParams& lhs, const ShowMessageRequestParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ShowMessageRequestParams& out) {
    {
        auto member = v.Get("type");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.type); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("message");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.message); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("actions")) {
        std::vector<lsp::MessageActionItem> val;
        auto member = v.Get("actions");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.actions = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ShowMessageRequestParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.type, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"type", res.Get()});
    }
    {
        auto res = Encode(in.message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"message", res.Get()});
    }
    if (in.actions) {
        auto res = Encode(*in.actions, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"actions", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ShowMessageRequestParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const LogMessageParams& lhs, const LogMessageParams& rhs) {
    if (lhs.type != rhs.type) {
        return false;
    }
    if (lhs.message != rhs.message) {
        return false;
    }
    return true;
}

bool operator!=(const LogMessageParams& lhs, const LogMessageParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] LogMessageParams& out) {
    {
        auto member = v.Get("type");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.type); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("message");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.message); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const LogMessageParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.type, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"type", res.Get()});
    }
    {
        auto res = Encode(in.message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"message", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const LogMessageParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidOpenTextDocumentParams& lhs, const DidOpenTextDocumentParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    return true;
}

bool operator!=(const DidOpenTextDocumentParams& lhs, const DidOpenTextDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DidOpenTextDocumentParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidOpenTextDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidOpenTextDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidChangeTextDocumentParams& lhs, const DidChangeTextDocumentParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.content_changes != rhs.content_changes) {
        return false;
    }
    return true;
}

bool operator!=(const DidChangeTextDocumentParams& lhs, const DidChangeTextDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidChangeTextDocumentParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("contentChanges");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.content_changes); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidChangeTextDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.content_changes, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"contentChanges", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidChangeTextDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentChangeRegistrationOptions& lhs,
                const TextDocumentChangeRegistrationOptions& rhs) {
    if (lhs.sync_kind != rhs.sync_kind) {
        return false;
    }
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentChangeRegistrationOptions& lhs,
                const TextDocumentChangeRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TextDocumentChangeRegistrationOptions& out) {
    {
        auto member = v.Get("syncKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.sync_kind); res != Success) {
            return res.Failure();
        }
    }
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentChangeRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.sync_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"syncKind", res.Get()});
    }
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentChangeRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidCloseTextDocumentParams& lhs, const DidCloseTextDocumentParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    return true;
}

bool operator!=(const DidCloseTextDocumentParams& lhs, const DidCloseTextDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidCloseTextDocumentParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidCloseTextDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidCloseTextDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidSaveTextDocumentParams& lhs, const DidSaveTextDocumentParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.text != rhs.text) {
        return false;
    }
    return true;
}

bool operator!=(const DidSaveTextDocumentParams& lhs, const DidSaveTextDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DidSaveTextDocumentParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("text")) {
        String val;
        auto member = v.Get("text");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.text = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidSaveTextDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    if (in.text) {
        auto res = Encode(*in.text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"text", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidSaveTextDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentSaveRegistrationOptions& lhs,
                const TextDocumentSaveRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const SaveOptions&>(lhs) != static_cast<const SaveOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentSaveRegistrationOptions& lhs,
                const TextDocumentSaveRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TextDocumentSaveRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<SaveOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentSaveRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const SaveOptions&>(in), b, members); res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentSaveRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WillSaveTextDocumentParams& lhs, const WillSaveTextDocumentParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.reason != rhs.reason) {
        return false;
    }
    return true;
}

bool operator!=(const WillSaveTextDocumentParams& lhs, const WillSaveTextDocumentParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WillSaveTextDocumentParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("reason");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.reason); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WillSaveTextDocumentParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.reason, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"reason", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WillSaveTextDocumentParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileEvent& lhs, const FileEvent& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.type != rhs.type) {
        return false;
    }
    return true;
}

bool operator!=(const FileEvent& lhs, const FileEvent& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FileEvent& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("type");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.type); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileEvent& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.type, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"type", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileEvent& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidChangeWatchedFilesParams& lhs, const DidChangeWatchedFilesParams& rhs) {
    if (lhs.changes != rhs.changes) {
        return false;
    }
    return true;
}

bool operator!=(const DidChangeWatchedFilesParams& lhs, const DidChangeWatchedFilesParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidChangeWatchedFilesParams& out) {
    {
        auto member = v.Get("changes");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.changes); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidChangeWatchedFilesParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.changes, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"changes", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DidChangeWatchedFilesParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FileSystemWatcher& lhs, const FileSystemWatcher& rhs) {
    if (lhs.glob_pattern != rhs.glob_pattern) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    return true;
}

bool operator!=(const FileSystemWatcher& lhs, const FileSystemWatcher& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FileSystemWatcher& out) {
    {
        auto member = v.Get("globPattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.glob_pattern); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("kind")) {
        lsp::WatchKind val;
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.kind = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FileSystemWatcher& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.glob_pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"globPattern", res.Get()});
    }
    if (in.kind) {
        auto res = Encode(*in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FileSystemWatcher& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DidChangeWatchedFilesRegistrationOptions& lhs,
                const DidChangeWatchedFilesRegistrationOptions& rhs) {
    if (lhs.watchers != rhs.watchers) {
        return false;
    }
    return true;
}

bool operator!=(const DidChangeWatchedFilesRegistrationOptions& lhs,
                const DidChangeWatchedFilesRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DidChangeWatchedFilesRegistrationOptions& out) {
    {
        auto member = v.Get("watchers");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.watchers); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DidChangeWatchedFilesRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.watchers, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"watchers", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const DidChangeWatchedFilesRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const PublishDiagnosticsParams& lhs, const PublishDiagnosticsParams& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.version != rhs.version) {
        return false;
    }
    if (lhs.diagnostics != rhs.diagnostics) {
        return false;
    }
    return true;
}

bool operator!=(const PublishDiagnosticsParams& lhs, const PublishDiagnosticsParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] PublishDiagnosticsParams& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("version")) {
        Integer val;
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.version = std::move(val);
    }
    {
        auto member = v.Get("diagnostics");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.diagnostics); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const PublishDiagnosticsParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    if (in.version) {
        auto res = Encode(*in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    {
        auto res = Encode(in.diagnostics, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"diagnostics", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const PublishDiagnosticsParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionContext& lhs, const CompletionContext& rhs) {
    if (lhs.trigger_kind != rhs.trigger_kind) {
        return false;
    }
    if (lhs.trigger_character != rhs.trigger_character) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionContext& lhs, const CompletionContext& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CompletionContext& out) {
    {
        auto member = v.Get("triggerKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.trigger_kind); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("triggerCharacter")) {
        String val;
        auto member = v.Get("triggerCharacter");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.trigger_character = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionContext& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.trigger_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"triggerKind", res.Get()});
    }
    if (in.trigger_character) {
        auto res = Encode(*in.trigger_character, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"triggerCharacter", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionContext& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionParams& lhs, const CompletionParams& rhs) {
    if (lhs.context != rhs.context) {
        return false;
    }
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionParams& lhs, const CompletionParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CompletionParams& out) {
    if (v.Has("context")) {
        lsp::CompletionContext val;
        auto member = v.Get("context");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.context = std::move(val);
    }
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.context) {
        auto res = Encode(*in.context, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"context", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionItemLabelDetails& lhs, const CompletionItemLabelDetails& rhs) {
    if (lhs.detail != rhs.detail) {
        return false;
    }
    if (lhs.description != rhs.description) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionItemLabelDetails& lhs, const CompletionItemLabelDetails& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CompletionItemLabelDetails& out) {
    if (v.Has("detail")) {
        String val;
        auto member = v.Get("detail");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.detail = std::move(val);
    }
    if (v.Has("description")) {
        String val;
        auto member = v.Get("description");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.description = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionItemLabelDetails& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.detail) {
        auto res = Encode(*in.detail, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"detail", res.Get()});
    }
    if (in.description) {
        auto res = Encode(*in.description, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"description", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionItemLabelDetails& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InsertReplaceEdit& lhs, const InsertReplaceEdit& rhs) {
    if (lhs.new_text != rhs.new_text) {
        return false;
    }
    if (lhs.insert != rhs.insert) {
        return false;
    }
    if (lhs.replace != rhs.replace) {
        return false;
    }
    return true;
}

bool operator!=(const InsertReplaceEdit& lhs, const InsertReplaceEdit& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InsertReplaceEdit& out) {
    {
        auto member = v.Get("newText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.new_text); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("insert");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.insert); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("replace");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.replace); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InsertReplaceEdit& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.new_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"newText", res.Get()});
    }
    {
        auto res = Encode(in.insert, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insert", res.Get()});
    }
    {
        auto res = Encode(in.replace, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"replace", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InsertReplaceEdit& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionItem& lhs, const CompletionItem& rhs) {
    if (lhs.label != rhs.label) {
        return false;
    }
    if (lhs.label_details != rhs.label_details) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.tags != rhs.tags) {
        return false;
    }
    if (lhs.detail != rhs.detail) {
        return false;
    }
    if (lhs.documentation != rhs.documentation) {
        return false;
    }
    if (lhs.deprecated != rhs.deprecated) {
        return false;
    }
    if (lhs.preselect != rhs.preselect) {
        return false;
    }
    if (lhs.sort_text != rhs.sort_text) {
        return false;
    }
    if (lhs.filter_text != rhs.filter_text) {
        return false;
    }
    if (lhs.insert_text != rhs.insert_text) {
        return false;
    }
    if (lhs.insert_text_format != rhs.insert_text_format) {
        return false;
    }
    if (lhs.insert_text_mode != rhs.insert_text_mode) {
        return false;
    }
    if (lhs.text_edit != rhs.text_edit) {
        return false;
    }
    if (lhs.text_edit_text != rhs.text_edit_text) {
        return false;
    }
    if (lhs.additional_text_edits != rhs.additional_text_edits) {
        return false;
    }
    if (lhs.commit_characters != rhs.commit_characters) {
        return false;
    }
    if (lhs.command != rhs.command) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionItem& lhs, const CompletionItem& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CompletionItem& out) {
    {
        auto member = v.Get("label");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.label); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("labelDetails")) {
        lsp::CompletionItemLabelDetails val;
        auto member = v.Get("labelDetails");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.label_details = std::move(val);
    }
    if (v.Has("kind")) {
        lsp::CompletionItemKind val;
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.kind = std::move(val);
    }
    if (v.Has("tags")) {
        std::vector<lsp::CompletionItemTag> val;
        auto member = v.Get("tags");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tags = std::move(val);
    }
    if (v.Has("detail")) {
        String val;
        auto member = v.Get("detail");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.detail = std::move(val);
    }
    if (v.Has("documentation")) {
        OneOf<String, lsp::MarkupContent> val;
        auto member = v.Get("documentation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.documentation = std::move(val);
    }
    if (v.Has("deprecated")) {
        Boolean val;
        auto member = v.Get("deprecated");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.deprecated = std::move(val);
    }
    if (v.Has("preselect")) {
        Boolean val;
        auto member = v.Get("preselect");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.preselect = std::move(val);
    }
    if (v.Has("sortText")) {
        String val;
        auto member = v.Get("sortText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.sort_text = std::move(val);
    }
    if (v.Has("filterText")) {
        String val;
        auto member = v.Get("filterText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.filter_text = std::move(val);
    }
    if (v.Has("insertText")) {
        String val;
        auto member = v.Get("insertText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.insert_text = std::move(val);
    }
    if (v.Has("insertTextFormat")) {
        lsp::InsertTextFormat val;
        auto member = v.Get("insertTextFormat");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.insert_text_format = std::move(val);
    }
    if (v.Has("insertTextMode")) {
        lsp::InsertTextMode val;
        auto member = v.Get("insertTextMode");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.insert_text_mode = std::move(val);
    }
    if (v.Has("textEdit")) {
        OneOf<lsp::TextEdit, lsp::InsertReplaceEdit> val;
        auto member = v.Get("textEdit");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.text_edit = std::move(val);
    }
    if (v.Has("textEditText")) {
        String val;
        auto member = v.Get("textEditText");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.text_edit_text = std::move(val);
    }
    if (v.Has("additionalTextEdits")) {
        std::vector<lsp::TextEdit> val;
        auto member = v.Get("additionalTextEdits");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.additional_text_edits = std::move(val);
    }
    if (v.Has("commitCharacters")) {
        std::vector<String> val;
        auto member = v.Get("commitCharacters");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.commit_characters = std::move(val);
    }
    if (v.Has("command")) {
        lsp::Command val;
        auto member = v.Get("command");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.command = std::move(val);
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionItem& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(19);
    {
        auto res = Encode(in.label, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"label", res.Get()});
    }
    if (in.label_details) {
        auto res = Encode(*in.label_details, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"labelDetails", res.Get()});
    }
    if (in.kind) {
        auto res = Encode(*in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    if (in.tags) {
        auto res = Encode(*in.tags, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tags", res.Get()});
    }
    if (in.detail) {
        auto res = Encode(*in.detail, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"detail", res.Get()});
    }
    if (in.documentation) {
        auto res = Encode(*in.documentation, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentation", res.Get()});
    }
    if (in.deprecated) {
        auto res = Encode(*in.deprecated, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"deprecated", res.Get()});
    }
    if (in.preselect) {
        auto res = Encode(*in.preselect, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"preselect", res.Get()});
    }
    if (in.sort_text) {
        auto res = Encode(*in.sort_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"sortText", res.Get()});
    }
    if (in.filter_text) {
        auto res = Encode(*in.filter_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"filterText", res.Get()});
    }
    if (in.insert_text) {
        auto res = Encode(*in.insert_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertText", res.Get()});
    }
    if (in.insert_text_format) {
        auto res = Encode(*in.insert_text_format, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertTextFormat", res.Get()});
    }
    if (in.insert_text_mode) {
        auto res = Encode(*in.insert_text_mode, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertTextMode", res.Get()});
    }
    if (in.text_edit) {
        auto res = Encode(*in.text_edit, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textEdit", res.Get()});
    }
    if (in.text_edit_text) {
        auto res = Encode(*in.text_edit_text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textEditText", res.Get()});
    }
    if (in.additional_text_edits) {
        auto res = Encode(*in.additional_text_edits, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"additionalTextEdits", res.Get()});
    }
    if (in.commit_characters) {
        auto res = Encode(*in.commit_characters, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"commitCharacters", res.Get()});
    }
    if (in.command) {
        auto res = Encode(*in.command, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"command", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionItem& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const EditRangeWithInsertReplace& lhs, const EditRangeWithInsertReplace& rhs) {
    if (lhs.insert != rhs.insert) {
        return false;
    }
    if (lhs.replace != rhs.replace) {
        return false;
    }
    return true;
}

bool operator!=(const EditRangeWithInsertReplace& lhs, const EditRangeWithInsertReplace& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] EditRangeWithInsertReplace& out) {
    {
        auto member = v.Get("insert");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.insert); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("replace");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.replace); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const EditRangeWithInsertReplace& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.insert, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insert", res.Get()});
    }
    {
        auto res = Encode(in.replace, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"replace", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const EditRangeWithInsertReplace& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionItemDefaults& lhs, const CompletionItemDefaults& rhs) {
    if (lhs.commit_characters != rhs.commit_characters) {
        return false;
    }
    if (lhs.edit_range != rhs.edit_range) {
        return false;
    }
    if (lhs.insert_text_format != rhs.insert_text_format) {
        return false;
    }
    if (lhs.insert_text_mode != rhs.insert_text_mode) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionItemDefaults& lhs, const CompletionItemDefaults& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CompletionItemDefaults& out) {
    if (v.Has("commitCharacters")) {
        std::vector<String> val;
        auto member = v.Get("commitCharacters");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.commit_characters = std::move(val);
    }
    if (v.Has("editRange")) {
        OneOf<lsp::Range, lsp::EditRangeWithInsertReplace> val;
        auto member = v.Get("editRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.edit_range = std::move(val);
    }
    if (v.Has("insertTextFormat")) {
        lsp::InsertTextFormat val;
        auto member = v.Get("insertTextFormat");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.insert_text_format = std::move(val);
    }
    if (v.Has("insertTextMode")) {
        lsp::InsertTextMode val;
        auto member = v.Get("insertTextMode");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.insert_text_mode = std::move(val);
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionItemDefaults& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(5);
    if (in.commit_characters) {
        auto res = Encode(*in.commit_characters, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"commitCharacters", res.Get()});
    }
    if (in.edit_range) {
        auto res = Encode(*in.edit_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"editRange", res.Get()});
    }
    if (in.insert_text_format) {
        auto res = Encode(*in.insert_text_format, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertTextFormat", res.Get()});
    }
    if (in.insert_text_mode) {
        auto res = Encode(*in.insert_text_mode, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertTextMode", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionItemDefaults& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionList& lhs, const CompletionList& rhs) {
    if (lhs.is_incomplete != rhs.is_incomplete) {
        return false;
    }
    if (lhs.item_defaults != rhs.item_defaults) {
        return false;
    }
    if (lhs.items != rhs.items) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionList& lhs, const CompletionList& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CompletionList& out) {
    {
        auto member = v.Get("isIncomplete");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.is_incomplete); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("itemDefaults")) {
        lsp::CompletionItemDefaults val;
        auto member = v.Get("itemDefaults");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.item_defaults = std::move(val);
    }
    {
        auto member = v.Get("items");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.items); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionList& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.is_incomplete, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"isIncomplete", res.Get()});
    }
    if (in.item_defaults) {
        auto res = Encode(*in.item_defaults, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"itemDefaults", res.Get()});
    }
    {
        auto res = Encode(in.items, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"items", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionList& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CompletionRegistrationOptions& lhs,
                const CompletionRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const CompletionOptions&>(lhs) != static_cast<const CompletionOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const CompletionRegistrationOptions& lhs,
                const CompletionRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CompletionRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<CompletionOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CompletionRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const CompletionOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CompletionRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const HoverParams& lhs, const HoverParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const HoverParams& lhs, const HoverParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] HoverParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const HoverParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const HoverParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const Hover& lhs, const Hover& rhs) {
    if (lhs.contents != rhs.contents) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    return true;
}

bool operator!=(const Hover& lhs, const Hover& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] Hover& out) {
    {
        auto member = v.Get("contents");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.contents); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("range")) {
        lsp::Range val;
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.range = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const Hover& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.contents, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"contents", res.Get()});
    }
    if (in.range) {
        auto res = Encode(*in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const Hover& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const HoverRegistrationOptions& lhs, const HoverRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const HoverOptions&>(lhs) != static_cast<const HoverOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const HoverRegistrationOptions& lhs, const HoverRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] HoverRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<HoverOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const HoverRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const HoverOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const HoverRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ParameterInformation& lhs, const ParameterInformation& rhs) {
    if (lhs.label != rhs.label) {
        return false;
    }
    if (lhs.documentation != rhs.documentation) {
        return false;
    }
    return true;
}

bool operator!=(const ParameterInformation& lhs, const ParameterInformation& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ParameterInformation& out) {
    {
        auto member = v.Get("label");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.label); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("documentation")) {
        OneOf<String, lsp::MarkupContent> val;
        auto member = v.Get("documentation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.documentation = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ParameterInformation& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.label, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"label", res.Get()});
    }
    if (in.documentation) {
        auto res = Encode(*in.documentation, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentation", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ParameterInformation& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SignatureInformation& lhs, const SignatureInformation& rhs) {
    if (lhs.label != rhs.label) {
        return false;
    }
    if (lhs.documentation != rhs.documentation) {
        return false;
    }
    if (lhs.parameters != rhs.parameters) {
        return false;
    }
    if (lhs.active_parameter != rhs.active_parameter) {
        return false;
    }
    return true;
}

bool operator!=(const SignatureInformation& lhs, const SignatureInformation& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SignatureInformation& out) {
    {
        auto member = v.Get("label");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.label); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("documentation")) {
        OneOf<String, lsp::MarkupContent> val;
        auto member = v.Get("documentation");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.documentation = std::move(val);
    }
    if (v.Has("parameters")) {
        std::vector<lsp::ParameterInformation> val;
        auto member = v.Get("parameters");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.parameters = std::move(val);
    }
    if (v.Has("activeParameter")) {
        Uinteger val;
        auto member = v.Get("activeParameter");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.active_parameter = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SignatureInformation& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.label, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"label", res.Get()});
    }
    if (in.documentation) {
        auto res = Encode(*in.documentation, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"documentation", res.Get()});
    }
    if (in.parameters) {
        auto res = Encode(*in.parameters, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"parameters", res.Get()});
    }
    if (in.active_parameter) {
        auto res = Encode(*in.active_parameter, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"activeParameter", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SignatureInformation& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SignatureHelp& lhs, const SignatureHelp& rhs) {
    if (lhs.signatures != rhs.signatures) {
        return false;
    }
    if (lhs.active_signature != rhs.active_signature) {
        return false;
    }
    if (lhs.active_parameter != rhs.active_parameter) {
        return false;
    }
    return true;
}

bool operator!=(const SignatureHelp& lhs, const SignatureHelp& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SignatureHelp& out) {
    {
        auto member = v.Get("signatures");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.signatures); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("activeSignature")) {
        Uinteger val;
        auto member = v.Get("activeSignature");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.active_signature = std::move(val);
    }
    if (v.Has("activeParameter")) {
        Uinteger val;
        auto member = v.Get("activeParameter");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.active_parameter = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SignatureHelp& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.signatures, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"signatures", res.Get()});
    }
    if (in.active_signature) {
        auto res = Encode(*in.active_signature, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"activeSignature", res.Get()});
    }
    if (in.active_parameter) {
        auto res = Encode(*in.active_parameter, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"activeParameter", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SignatureHelp& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SignatureHelpContext& lhs, const SignatureHelpContext& rhs) {
    if (lhs.trigger_kind != rhs.trigger_kind) {
        return false;
    }
    if (lhs.trigger_character != rhs.trigger_character) {
        return false;
    }
    if (lhs.is_retrigger != rhs.is_retrigger) {
        return false;
    }
    if (lhs.active_signature_help != rhs.active_signature_help) {
        return false;
    }
    return true;
}

bool operator!=(const SignatureHelpContext& lhs, const SignatureHelpContext& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SignatureHelpContext& out) {
    {
        auto member = v.Get("triggerKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.trigger_kind); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("triggerCharacter")) {
        String val;
        auto member = v.Get("triggerCharacter");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.trigger_character = std::move(val);
    }
    {
        auto member = v.Get("isRetrigger");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.is_retrigger); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("activeSignatureHelp")) {
        lsp::SignatureHelp val;
        auto member = v.Get("activeSignatureHelp");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.active_signature_help = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SignatureHelpContext& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.trigger_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"triggerKind", res.Get()});
    }
    if (in.trigger_character) {
        auto res = Encode(*in.trigger_character, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"triggerCharacter", res.Get()});
    }
    {
        auto res = Encode(in.is_retrigger, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"isRetrigger", res.Get()});
    }
    if (in.active_signature_help) {
        auto res = Encode(*in.active_signature_help, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"activeSignatureHelp", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SignatureHelpContext& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SignatureHelpParams& lhs, const SignatureHelpParams& rhs) {
    if (lhs.context != rhs.context) {
        return false;
    }
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const SignatureHelpParams& lhs, const SignatureHelpParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SignatureHelpParams& out) {
    if (v.Has("context")) {
        lsp::SignatureHelpContext val;
        auto member = v.Get("context");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.context = std::move(val);
    }
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SignatureHelpParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.context) {
        auto res = Encode(*in.context, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"context", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SignatureHelpParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SignatureHelpRegistrationOptions& lhs,
                const SignatureHelpRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const SignatureHelpOptions&>(lhs) !=
        static_cast<const SignatureHelpOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const SignatureHelpRegistrationOptions& lhs,
                const SignatureHelpRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] SignatureHelpRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<SignatureHelpOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SignatureHelpRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const SignatureHelpOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SignatureHelpRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DefinitionParams& lhs, const DefinitionParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DefinitionParams& lhs, const DefinitionParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DefinitionParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DefinitionParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DefinitionParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DefinitionRegistrationOptions& lhs,
                const DefinitionRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const DefinitionOptions&>(lhs) != static_cast<const DefinitionOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DefinitionRegistrationOptions& lhs,
                const DefinitionRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DefinitionRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<DefinitionOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DefinitionRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const DefinitionOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DefinitionRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ReferenceContext& lhs, const ReferenceContext& rhs) {
    if (lhs.include_declaration != rhs.include_declaration) {
        return false;
    }
    return true;
}

bool operator!=(const ReferenceContext& lhs, const ReferenceContext& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ReferenceContext& out) {
    {
        auto member = v.Get("includeDeclaration");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.include_declaration); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ReferenceContext& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.include_declaration, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"includeDeclaration", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ReferenceContext& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ReferenceParams& lhs, const ReferenceParams& rhs) {
    if (lhs.context != rhs.context) {
        return false;
    }
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const ReferenceParams& lhs, const ReferenceParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ReferenceParams& out) {
    {
        auto member = v.Get("context");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.context); res != Success) {
            return res.Failure();
        }
    }
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ReferenceParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.context, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"context", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ReferenceParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ReferenceRegistrationOptions& lhs, const ReferenceRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const ReferenceOptions&>(lhs) != static_cast<const ReferenceOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const ReferenceRegistrationOptions& lhs, const ReferenceRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ReferenceRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<ReferenceOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ReferenceRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const ReferenceOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ReferenceRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentHighlightParams& lhs, const DocumentHighlightParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentHighlightParams& lhs, const DocumentHighlightParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentHighlightParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentHighlightParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentHighlightParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentHighlight& lhs, const DocumentHighlight& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentHighlight& lhs, const DocumentHighlight& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentHighlight& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("kind")) {
        lsp::DocumentHighlightKind val;
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.kind = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentHighlight& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.kind) {
        auto res = Encode(*in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentHighlight& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentHighlightRegistrationOptions& lhs,
                const DocumentHighlightRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const DocumentHighlightOptions&>(lhs) !=
        static_cast<const DocumentHighlightOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentHighlightRegistrationOptions& lhs,
                const DocumentHighlightRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentHighlightRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<DocumentHighlightOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentHighlightRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const DocumentHighlightOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentHighlightRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentSymbolParams& lhs, const DocumentSymbolParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentSymbolParams& lhs, const DocumentSymbolParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentSymbolParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentSymbolParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentSymbolParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const BaseSymbolInformation& lhs, const BaseSymbolInformation& rhs) {
    if (lhs.name != rhs.name) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.tags != rhs.tags) {
        return false;
    }
    if (lhs.container_name != rhs.container_name) {
        return false;
    }
    return true;
}

bool operator!=(const BaseSymbolInformation& lhs, const BaseSymbolInformation& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] BaseSymbolInformation& out) {
    {
        auto member = v.Get("name");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.name); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.kind); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("tags")) {
        std::vector<lsp::SymbolTag> val;
        auto member = v.Get("tags");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tags = std::move(val);
    }
    if (v.Has("containerName")) {
        String val;
        auto member = v.Get("containerName");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.container_name = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const BaseSymbolInformation& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"name", res.Get()});
    }
    {
        auto res = Encode(in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    if (in.tags) {
        auto res = Encode(*in.tags, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tags", res.Get()});
    }
    if (in.container_name) {
        auto res = Encode(*in.container_name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"containerName", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const BaseSymbolInformation& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SymbolInformation& lhs, const SymbolInformation& rhs) {
    if (lhs.deprecated != rhs.deprecated) {
        return false;
    }
    if (lhs.location != rhs.location) {
        return false;
    }
    if (static_cast<const BaseSymbolInformation&>(lhs) !=
        static_cast<const BaseSymbolInformation&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const SymbolInformation& lhs, const SymbolInformation& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SymbolInformation& out) {
    if (v.Has("deprecated")) {
        Boolean val;
        auto member = v.Get("deprecated");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.deprecated = std::move(val);
    }
    {
        auto member = v.Get("location");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.location); res != Success) {
            return res.Failure();
        }
    }
    if (auto res = Decode(v, static_cast<BaseSymbolInformation&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SymbolInformation& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.deprecated) {
        auto res = Encode(*in.deprecated, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"deprecated", res.Get()});
    }
    {
        auto res = Encode(in.location, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"location", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const BaseSymbolInformation&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SymbolInformation& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentSymbol& lhs, const DocumentSymbol& rhs) {
    if (lhs.name != rhs.name) {
        return false;
    }
    if (lhs.detail != rhs.detail) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.tags != rhs.tags) {
        return false;
    }
    if (lhs.deprecated != rhs.deprecated) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.selection_range != rhs.selection_range) {
        return false;
    }
    if (lhs.children != rhs.children) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentSymbol& lhs, const DocumentSymbol& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentSymbol& out) {
    {
        auto member = v.Get("name");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.name); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("detail")) {
        String val;
        auto member = v.Get("detail");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.detail = std::move(val);
    }
    {
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.kind); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("tags")) {
        std::vector<lsp::SymbolTag> val;
        auto member = v.Get("tags");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tags = std::move(val);
    }
    if (v.Has("deprecated")) {
        Boolean val;
        auto member = v.Get("deprecated");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.deprecated = std::move(val);
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("selectionRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.selection_range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("children")) {
        std::vector<lsp::DocumentSymbol> val;
        auto member = v.Get("children");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.children = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentSymbol& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(8);
    {
        auto res = Encode(in.name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"name", res.Get()});
    }
    if (in.detail) {
        auto res = Encode(*in.detail, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"detail", res.Get()});
    }
    {
        auto res = Encode(in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    if (in.tags) {
        auto res = Encode(*in.tags, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tags", res.Get()});
    }
    if (in.deprecated) {
        auto res = Encode(*in.deprecated, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"deprecated", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.selection_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"selectionRange", res.Get()});
    }
    if (in.children) {
        auto res = Encode(*in.children, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"children", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentSymbol& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentSymbolRegistrationOptions& lhs,
                const DocumentSymbolRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const DocumentSymbolOptions&>(lhs) !=
        static_cast<const DocumentSymbolOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentSymbolRegistrationOptions& lhs,
                const DocumentSymbolRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentSymbolRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<DocumentSymbolOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentSymbolRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const DocumentSymbolOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentSymbolRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeActionContext& lhs, const CodeActionContext& rhs) {
    if (lhs.diagnostics != rhs.diagnostics) {
        return false;
    }
    if (lhs.only != rhs.only) {
        return false;
    }
    if (lhs.trigger_kind != rhs.trigger_kind) {
        return false;
    }
    return true;
}

bool operator!=(const CodeActionContext& lhs, const CodeActionContext& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CodeActionContext& out) {
    {
        auto member = v.Get("diagnostics");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.diagnostics); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("only")) {
        std::vector<lsp::CodeActionKind> val;
        auto member = v.Get("only");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.only = std::move(val);
    }
    if (v.Has("triggerKind")) {
        lsp::CodeActionTriggerKind val;
        auto member = v.Get("triggerKind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.trigger_kind = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeActionContext& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.diagnostics, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"diagnostics", res.Get()});
    }
    if (in.only) {
        auto res = Encode(*in.only, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"only", res.Get()});
    }
    if (in.trigger_kind) {
        auto res = Encode(*in.trigger_kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"triggerKind", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeActionContext& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeActionParams& lhs, const CodeActionParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.context != rhs.context) {
        return false;
    }
    return true;
}

bool operator!=(const CodeActionParams& lhs, const CodeActionParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CodeActionParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("context");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.context); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeActionParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.context, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"context", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeActionParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeActionDisabled& lhs, const CodeActionDisabled& rhs) {
    if (lhs.reason != rhs.reason) {
        return false;
    }
    return true;
}

bool operator!=(const CodeActionDisabled& lhs, const CodeActionDisabled& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CodeActionDisabled& out) {
    {
        auto member = v.Get("reason");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.reason); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeActionDisabled& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.reason, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"reason", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeActionDisabled& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeAction& lhs, const CodeAction& rhs) {
    if (lhs.title != rhs.title) {
        return false;
    }
    if (lhs.kind != rhs.kind) {
        return false;
    }
    if (lhs.diagnostics != rhs.diagnostics) {
        return false;
    }
    if (lhs.is_preferred != rhs.is_preferred) {
        return false;
    }
    if (lhs.disabled != rhs.disabled) {
        return false;
    }
    if (lhs.edit != rhs.edit) {
        return false;
    }
    if (lhs.command != rhs.command) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const CodeAction& lhs, const CodeAction& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CodeAction& out) {
    {
        auto member = v.Get("title");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.title); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("kind")) {
        lsp::CodeActionKind val;
        auto member = v.Get("kind");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.kind = std::move(val);
    }
    if (v.Has("diagnostics")) {
        std::vector<lsp::Diagnostic> val;
        auto member = v.Get("diagnostics");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.diagnostics = std::move(val);
    }
    if (v.Has("isPreferred")) {
        Boolean val;
        auto member = v.Get("isPreferred");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.is_preferred = std::move(val);
    }
    if (v.Has("disabled")) {
        lsp::CodeActionDisabled val;
        auto member = v.Get("disabled");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.disabled = std::move(val);
    }
    if (v.Has("edit")) {
        lsp::WorkspaceEdit val;
        auto member = v.Get("edit");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.edit = std::move(val);
    }
    if (v.Has("command")) {
        lsp::Command val;
        auto member = v.Get("command");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.command = std::move(val);
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeAction& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(8);
    {
        auto res = Encode(in.title, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"title", res.Get()});
    }
    if (in.kind) {
        auto res = Encode(*in.kind, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"kind", res.Get()});
    }
    if (in.diagnostics) {
        auto res = Encode(*in.diagnostics, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"diagnostics", res.Get()});
    }
    if (in.is_preferred) {
        auto res = Encode(*in.is_preferred, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"isPreferred", res.Get()});
    }
    if (in.disabled) {
        auto res = Encode(*in.disabled, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"disabled", res.Get()});
    }
    if (in.edit) {
        auto res = Encode(*in.edit, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"edit", res.Get()});
    }
    if (in.command) {
        auto res = Encode(*in.command, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"command", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeAction& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeActionRegistrationOptions& lhs,
                const CodeActionRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const CodeActionOptions&>(lhs) != static_cast<const CodeActionOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const CodeActionRegistrationOptions& lhs,
                const CodeActionRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CodeActionRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<CodeActionOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeActionRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const CodeActionOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeActionRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceSymbolParams& lhs, const WorkspaceSymbolParams& rhs) {
    if (lhs.query != rhs.query) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceSymbolParams& lhs, const WorkspaceSymbolParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkspaceSymbolParams& out) {
    {
        auto member = v.Get("query");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.query); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceSymbolParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.query, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"query", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceSymbolParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const LocationUriOnly& lhs, const LocationUriOnly& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    return true;
}

bool operator!=(const LocationUriOnly& lhs, const LocationUriOnly& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] LocationUriOnly& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const LocationUriOnly& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const LocationUriOnly& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceSymbol& lhs, const WorkspaceSymbol& rhs) {
    if (lhs.location != rhs.location) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    if (static_cast<const BaseSymbolInformation&>(lhs) !=
        static_cast<const BaseSymbolInformation&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceSymbol& lhs, const WorkspaceSymbol& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkspaceSymbol& out) {
    {
        auto member = v.Get("location");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.location); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }
    if (auto res = Decode(v, static_cast<BaseSymbolInformation&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceSymbol& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.location, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"location", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const BaseSymbolInformation&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceSymbol& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceSymbolRegistrationOptions& lhs,
                const WorkspaceSymbolRegistrationOptions& rhs) {
    if (static_cast<const WorkspaceSymbolOptions&>(lhs) !=
        static_cast<const WorkspaceSymbolOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceSymbolRegistrationOptions& lhs,
                const WorkspaceSymbolRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceSymbolRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<WorkspaceSymbolOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceSymbolRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const WorkspaceSymbolOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceSymbolRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeLensParams& lhs, const CodeLensParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    return true;
}

bool operator!=(const CodeLensParams& lhs, const CodeLensParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CodeLensParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeLensParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeLensParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeLens& lhs, const CodeLens& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.command != rhs.command) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const CodeLens& lhs, const CodeLens& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CodeLens& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("command")) {
        lsp::Command val;
        auto member = v.Get("command");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.command = std::move(val);
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeLens& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.command) {
        auto res = Encode(*in.command, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"command", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeLens& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CodeLensRegistrationOptions& lhs, const CodeLensRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const CodeLensOptions&>(lhs) != static_cast<const CodeLensOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const CodeLensRegistrationOptions& lhs, const CodeLensRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] CodeLensRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<CodeLensOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CodeLensRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const CodeLensOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CodeLensRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentLinkParams& lhs, const DocumentLinkParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentLinkParams& lhs, const DocumentLinkParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentLinkParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentLinkParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentLinkParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentLink& lhs, const DocumentLink& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.target != rhs.target) {
        return false;
    }
    if (lhs.tooltip != rhs.tooltip) {
        return false;
    }
    if (lhs.data != rhs.data) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentLink& lhs, const DocumentLink& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentLink& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("target")) {
        Uri val;
        auto member = v.Get("target");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.target = std::move(val);
    }
    if (v.Has("tooltip")) {
        String val;
        auto member = v.Get("tooltip");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.tooltip = std::move(val);
    }
    if (v.Has("data")) {
        lsp::LSPAny val;
        auto member = v.Get("data");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.data = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentLink& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.target) {
        auto res = Encode(*in.target, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"target", res.Get()});
    }
    if (in.tooltip) {
        auto res = Encode(*in.tooltip, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tooltip", res.Get()});
    }
    if (in.data) {
        auto res = Encode(*in.data, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"data", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentLink& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentLinkRegistrationOptions& lhs,
                const DocumentLinkRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const DocumentLinkOptions&>(lhs) !=
        static_cast<const DocumentLinkOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentLinkRegistrationOptions& lhs,
                const DocumentLinkRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentLinkRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<DocumentLinkOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentLinkRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const DocumentLinkOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentLinkRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const FormattingOptions& lhs, const FormattingOptions& rhs) {
    if (lhs.tab_size != rhs.tab_size) {
        return false;
    }
    if (lhs.insert_spaces != rhs.insert_spaces) {
        return false;
    }
    if (lhs.trim_trailing_whitespace != rhs.trim_trailing_whitespace) {
        return false;
    }
    if (lhs.insert_final_newline != rhs.insert_final_newline) {
        return false;
    }
    if (lhs.trim_final_newlines != rhs.trim_final_newlines) {
        return false;
    }
    return true;
}

bool operator!=(const FormattingOptions& lhs, const FormattingOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] FormattingOptions& out) {
    {
        auto member = v.Get("tabSize");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.tab_size); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("insertSpaces");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.insert_spaces); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("trimTrailingWhitespace")) {
        Boolean val;
        auto member = v.Get("trimTrailingWhitespace");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.trim_trailing_whitespace = std::move(val);
    }
    if (v.Has("insertFinalNewline")) {
        Boolean val;
        auto member = v.Get("insertFinalNewline");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.insert_final_newline = std::move(val);
    }
    if (v.Has("trimFinalNewlines")) {
        Boolean val;
        auto member = v.Get("trimFinalNewlines");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.trim_final_newlines = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const FormattingOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(5);
    {
        auto res = Encode(in.tab_size, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"tabSize", res.Get()});
    }
    {
        auto res = Encode(in.insert_spaces, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertSpaces", res.Get()});
    }
    if (in.trim_trailing_whitespace) {
        auto res = Encode(*in.trim_trailing_whitespace, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"trimTrailingWhitespace", res.Get()});
    }
    if (in.insert_final_newline) {
        auto res = Encode(*in.insert_final_newline, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"insertFinalNewline", res.Get()});
    }
    if (in.trim_final_newlines) {
        auto res = Encode(*in.trim_final_newlines, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"trimFinalNewlines", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const FormattingOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentFormattingParams& lhs, const DocumentFormattingParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.options != rhs.options) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentFormattingParams& lhs, const DocumentFormattingParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] DocumentFormattingParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("options");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.options); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentFormattingParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"options", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentFormattingParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentFormattingRegistrationOptions& lhs,
                const DocumentFormattingRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const DocumentFormattingOptions&>(lhs) !=
        static_cast<const DocumentFormattingOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentFormattingRegistrationOptions& lhs,
                const DocumentFormattingRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentFormattingRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<DocumentFormattingOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentFormattingRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const DocumentFormattingOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentFormattingRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentRangeFormattingParams& lhs,
                const DocumentRangeFormattingParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.options != rhs.options) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentRangeFormattingParams& lhs,
                const DocumentRangeFormattingParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentRangeFormattingParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("options");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.options); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentRangeFormattingParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"options", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentRangeFormattingParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentRangeFormattingRegistrationOptions& lhs,
                const DocumentRangeFormattingRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const DocumentRangeFormattingOptions&>(lhs) !=
        static_cast<const DocumentRangeFormattingOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentRangeFormattingRegistrationOptions& lhs,
                const DocumentRangeFormattingRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentRangeFormattingRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<DocumentRangeFormattingOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentRangeFormattingRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res =
            EncodeMembers(static_cast<const DocumentRangeFormattingOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const DocumentRangeFormattingRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentRangesFormattingParams& lhs,
                const DocumentRangesFormattingParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.ranges != rhs.ranges) {
        return false;
    }
    if (lhs.options != rhs.options) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentRangesFormattingParams& lhs,
                const DocumentRangesFormattingParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentRangesFormattingParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("ranges");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.ranges); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("options");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.options); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentRangesFormattingParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.ranges, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"ranges", res.Get()});
    }
    {
        auto res = Encode(in.options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"options", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentRangesFormattingParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentOnTypeFormattingParams& lhs,
                const DocumentOnTypeFormattingParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.position != rhs.position) {
        return false;
    }
    if (lhs.ch != rhs.ch) {
        return false;
    }
    if (lhs.options != rhs.options) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentOnTypeFormattingParams& lhs,
                const DocumentOnTypeFormattingParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentOnTypeFormattingParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("position");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.position); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("ch");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.ch); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("options");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.options); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentOnTypeFormattingParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.position, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"position", res.Get()});
    }
    {
        auto res = Encode(in.ch, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"ch", res.Get()});
    }
    {
        auto res = Encode(in.options, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"options", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const DocumentOnTypeFormattingParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const DocumentOnTypeFormattingRegistrationOptions& lhs,
                const DocumentOnTypeFormattingRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const DocumentOnTypeFormattingOptions&>(lhs) !=
        static_cast<const DocumentOnTypeFormattingOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const DocumentOnTypeFormattingRegistrationOptions& lhs,
                const DocumentOnTypeFormattingRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] DocumentOnTypeFormattingRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<DocumentOnTypeFormattingOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const DocumentOnTypeFormattingRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res =
            EncodeMembers(static_cast<const DocumentOnTypeFormattingOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const DocumentOnTypeFormattingRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RenameParams& lhs, const RenameParams& rhs) {
    if (lhs.text_document != rhs.text_document) {
        return false;
    }
    if (lhs.position != rhs.position) {
        return false;
    }
    if (lhs.new_name != rhs.new_name) {
        return false;
    }
    return true;
}

bool operator!=(const RenameParams& lhs, const RenameParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] RenameParams& out) {
    {
        auto member = v.Get("textDocument");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text_document); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("position");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.position); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("newName");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.new_name); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RenameParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.text_document, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"textDocument", res.Get()});
    }
    {
        auto res = Encode(in.position, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"position", res.Get()});
    }
    {
        auto res = Encode(in.new_name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"newName", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RenameParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RenameRegistrationOptions& lhs, const RenameRegistrationOptions& rhs) {
    if (static_cast<const TextDocumentRegistrationOptions&>(lhs) !=
        static_cast<const TextDocumentRegistrationOptions&>(rhs)) {
        return false;
    }
    if (static_cast<const RenameOptions&>(lhs) != static_cast<const RenameOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const RenameRegistrationOptions& lhs, const RenameRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] RenameRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<TextDocumentRegistrationOptions&>(out)); res != Success) {
        return res.Failure();
    }
    if (auto res = Decode(v, static_cast<RenameOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RenameRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res =
            EncodeMembers(static_cast<const TextDocumentRegistrationOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    if (auto res = EncodeMembers(static_cast<const RenameOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RenameRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const PrepareRenameParams& lhs, const PrepareRenameParams& rhs) {
    if (static_cast<const TextDocumentPositionParams&>(lhs) !=
        static_cast<const TextDocumentPositionParams&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const PrepareRenameParams& lhs, const PrepareRenameParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] PrepareRenameParams& out) {
    if (auto res = Decode(v, static_cast<TextDocumentPositionParams&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const PrepareRenameParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const TextDocumentPositionParams&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const PrepareRenameParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ExecuteCommandParams& lhs, const ExecuteCommandParams& rhs) {
    if (lhs.command != rhs.command) {
        return false;
    }
    if (lhs.arguments != rhs.arguments) {
        return false;
    }
    return true;
}

bool operator!=(const ExecuteCommandParams& lhs, const ExecuteCommandParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ExecuteCommandParams& out) {
    {
        auto member = v.Get("command");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.command); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("arguments")) {
        std::vector<lsp::LSPAny> val;
        auto member = v.Get("arguments");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.arguments = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ExecuteCommandParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.command, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"command", res.Get()});
    }
    if (in.arguments) {
        auto res = Encode(*in.arguments, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"arguments", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ExecuteCommandParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ExecuteCommandRegistrationOptions& lhs,
                const ExecuteCommandRegistrationOptions& rhs) {
    if (static_cast<const ExecuteCommandOptions&>(lhs) !=
        static_cast<const ExecuteCommandOptions&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const ExecuteCommandRegistrationOptions& lhs,
                const ExecuteCommandRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] ExecuteCommandRegistrationOptions& out) {
    if (auto res = Decode(v, static_cast<ExecuteCommandOptions&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ExecuteCommandRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(0);
    if (auto res = EncodeMembers(static_cast<const ExecuteCommandOptions&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ExecuteCommandRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ApplyWorkspaceEditParams& lhs, const ApplyWorkspaceEditParams& rhs) {
    if (lhs.label != rhs.label) {
        return false;
    }
    if (lhs.edit != rhs.edit) {
        return false;
    }
    return true;
}

bool operator!=(const ApplyWorkspaceEditParams& lhs, const ApplyWorkspaceEditParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ApplyWorkspaceEditParams& out) {
    if (v.Has("label")) {
        String val;
        auto member = v.Get("label");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.label = std::move(val);
    }
    {
        auto member = v.Get("edit");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.edit); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ApplyWorkspaceEditParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    if (in.label) {
        auto res = Encode(*in.label, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"label", res.Get()});
    }
    {
        auto res = Encode(in.edit, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"edit", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ApplyWorkspaceEditParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ApplyWorkspaceEditResult& lhs, const ApplyWorkspaceEditResult& rhs) {
    if (lhs.applied != rhs.applied) {
        return false;
    }
    if (lhs.failure_reason != rhs.failure_reason) {
        return false;
    }
    if (lhs.failed_change != rhs.failed_change) {
        return false;
    }
    return true;
}

bool operator!=(const ApplyWorkspaceEditResult& lhs, const ApplyWorkspaceEditResult& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ApplyWorkspaceEditResult& out) {
    {
        auto member = v.Get("applied");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.applied); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("failureReason")) {
        String val;
        auto member = v.Get("failureReason");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.failure_reason = std::move(val);
    }
    if (v.Has("failedChange")) {
        Uinteger val;
        auto member = v.Get("failedChange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.failed_change = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ApplyWorkspaceEditResult& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.applied, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"applied", res.Get()});
    }
    if (in.failure_reason) {
        auto res = Encode(*in.failure_reason, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"failureReason", res.Get()});
    }
    if (in.failed_change) {
        auto res = Encode(*in.failed_change, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"failedChange", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ApplyWorkspaceEditResult& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkDoneProgressBegin& lhs, const WorkDoneProgressBegin& rhs) {
    if (lhs.title != rhs.title) {
        return false;
    }
    if (lhs.cancellable != rhs.cancellable) {
        return false;
    }
    if (lhs.message != rhs.message) {
        return false;
    }
    if (lhs.percentage != rhs.percentage) {
        return false;
    }
    return true;
}

bool operator!=(const WorkDoneProgressBegin& lhs, const WorkDoneProgressBegin& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkDoneProgressBegin& out) {
    if (auto res = MatchKind(v, "begin"); res != Success) {
        return res.Failure();
    }
    {
        auto member = v.Get("title");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.title); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("cancellable")) {
        Boolean val;
        auto member = v.Get("cancellable");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.cancellable = std::move(val);
    }
    if (v.Has("message")) {
        String val;
        auto member = v.Get("message");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.message = std::move(val);
    }
    if (v.Has("percentage")) {
        Uinteger val;
        auto member = v.Get("percentage");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.percentage = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkDoneProgressBegin& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(5);
    members.push_back(json::Builder::Member{"kind", b.String("begin")});
    {
        auto res = Encode(in.title, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"title", res.Get()});
    }
    if (in.cancellable) {
        auto res = Encode(*in.cancellable, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cancellable", res.Get()});
    }
    if (in.message) {
        auto res = Encode(*in.message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"message", res.Get()});
    }
    if (in.percentage) {
        auto res = Encode(*in.percentage, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"percentage", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkDoneProgressBegin& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkDoneProgressReport& lhs, const WorkDoneProgressReport& rhs) {
    if (lhs.cancellable != rhs.cancellable) {
        return false;
    }
    if (lhs.message != rhs.message) {
        return false;
    }
    if (lhs.percentage != rhs.percentage) {
        return false;
    }
    return true;
}

bool operator!=(const WorkDoneProgressReport& lhs, const WorkDoneProgressReport& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkDoneProgressReport& out) {
    if (auto res = MatchKind(v, "report"); res != Success) {
        return res.Failure();
    }
    if (v.Has("cancellable")) {
        Boolean val;
        auto member = v.Get("cancellable");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.cancellable = std::move(val);
    }
    if (v.Has("message")) {
        String val;
        auto member = v.Get("message");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.message = std::move(val);
    }
    if (v.Has("percentage")) {
        Uinteger val;
        auto member = v.Get("percentage");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.percentage = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkDoneProgressReport& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    members.push_back(json::Builder::Member{"kind", b.String("report")});
    if (in.cancellable) {
        auto res = Encode(*in.cancellable, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"cancellable", res.Get()});
    }
    if (in.message) {
        auto res = Encode(*in.message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"message", res.Get()});
    }
    if (in.percentage) {
        auto res = Encode(*in.percentage, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"percentage", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkDoneProgressReport& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkDoneProgressEnd& lhs, const WorkDoneProgressEnd& rhs) {
    if (lhs.message != rhs.message) {
        return false;
    }
    return true;
}

bool operator!=(const WorkDoneProgressEnd& lhs, const WorkDoneProgressEnd& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkDoneProgressEnd& out) {
    if (auto res = MatchKind(v, "end"); res != Success) {
        return res.Failure();
    }
    if (v.Has("message")) {
        String val;
        auto member = v.Get("message");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.message = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkDoneProgressEnd& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    members.push_back(json::Builder::Member{"kind", b.String("end")});
    if (in.message) {
        auto res = Encode(*in.message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"message", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkDoneProgressEnd& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const SetTraceParams& lhs, const SetTraceParams& rhs) {
    if (lhs.value != rhs.value) {
        return false;
    }
    return true;
}

bool operator!=(const SetTraceParams& lhs, const SetTraceParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] SetTraceParams& out) {
    {
        auto member = v.Get("value");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const SetTraceParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.value, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"value", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const SetTraceParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const LogTraceParams& lhs, const LogTraceParams& rhs) {
    if (lhs.message != rhs.message) {
        return false;
    }
    if (lhs.verbose != rhs.verbose) {
        return false;
    }
    return true;
}

bool operator!=(const LogTraceParams& lhs, const LogTraceParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] LogTraceParams& out) {
    {
        auto member = v.Get("message");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.message); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("verbose")) {
        String val;
        auto member = v.Get("verbose");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.verbose = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const LogTraceParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.message, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"message", res.Get()});
    }
    if (in.verbose) {
        auto res = Encode(*in.verbose, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"verbose", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const LogTraceParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const CancelParams& lhs, const CancelParams& rhs) {
    if (lhs.id != rhs.id) {
        return false;
    }
    return true;
}

bool operator!=(const CancelParams& lhs, const CancelParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] CancelParams& out) {
    {
        auto member = v.Get("id");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.id); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const CancelParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"id", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const CancelParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const ProgressParams& lhs, const ProgressParams& rhs) {
    if (lhs.token != rhs.token) {
        return false;
    }
    if (lhs.value != rhs.value) {
        return false;
    }
    return true;
}

bool operator!=(const ProgressParams& lhs, const ProgressParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] ProgressParams& out) {
    {
        auto member = v.Get("token");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.token); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("value");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const ProgressParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.token, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"token", res.Get()});
    }
    {
        auto res = Encode(in.value, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"value", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const ProgressParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkDoneProgressParams& lhs, const WorkDoneProgressParams& rhs) {
    if (lhs.work_done_token != rhs.work_done_token) {
        return false;
    }
    return true;
}

bool operator!=(const WorkDoneProgressParams& lhs, const WorkDoneProgressParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] WorkDoneProgressParams& out) {
    if (v.Has("workDoneToken")) {
        lsp::ProgressToken val;
        auto member = v.Get("workDoneToken");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.work_done_token = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkDoneProgressParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.work_done_token) {
        auto res = Encode(*in.work_done_token, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"workDoneToken", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkDoneProgressParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const PartialResultParams& lhs, const PartialResultParams& rhs) {
    if (lhs.partial_result_token != rhs.partial_result_token) {
        return false;
    }
    return true;
}

bool operator!=(const PartialResultParams& lhs, const PartialResultParams& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] PartialResultParams& out) {
    if (v.Has("partialResultToken")) {
        lsp::ProgressToken val;
        auto member = v.Get("partialResultToken");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.partial_result_token = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const PartialResultParams& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.partial_result_token) {
        auto res = Encode(*in.partial_result_token, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"partialResultToken", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const PartialResultParams& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const LocationLink& lhs, const LocationLink& rhs) {
    if (lhs.origin_selection_range != rhs.origin_selection_range) {
        return false;
    }
    if (lhs.target_uri != rhs.target_uri) {
        return false;
    }
    if (lhs.target_range != rhs.target_range) {
        return false;
    }
    if (lhs.target_selection_range != rhs.target_selection_range) {
        return false;
    }
    return true;
}

bool operator!=(const LocationLink& lhs, const LocationLink& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] LocationLink& out) {
    if (v.Has("originSelectionRange")) {
        lsp::Range val;
        auto member = v.Get("originSelectionRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.origin_selection_range = std::move(val);
    }
    {
        auto member = v.Get("targetUri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.target_uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("targetRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.target_range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("targetSelectionRange");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.target_selection_range); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const LocationLink& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(4);
    if (in.origin_selection_range) {
        auto res = Encode(*in.origin_selection_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"originSelectionRange", res.Get()});
    }
    {
        auto res = Encode(in.target_uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"targetUri", res.Get()});
    }
    {
        auto res = Encode(in.target_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"targetRange", res.Get()});
    }
    {
        auto res = Encode(in.target_selection_range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"targetSelectionRange", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const LocationLink& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const StaticRegistrationOptions& lhs, const StaticRegistrationOptions& rhs) {
    if (lhs.id != rhs.id) {
        return false;
    }
    return true;
}

bool operator!=(const StaticRegistrationOptions& lhs, const StaticRegistrationOptions& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] StaticRegistrationOptions& out) {
    if (v.Has("id")) {
        String val;
        auto member = v.Get("id");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.id = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const StaticRegistrationOptions& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.id) {
        auto res = Encode(*in.id, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"id", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const StaticRegistrationOptions& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineValueText& lhs, const InlineValueText& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.text != rhs.text) {
        return false;
    }
    return true;
}

bool operator!=(const InlineValueText& lhs, const InlineValueText& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineValueText& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("text");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineValueText& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"text", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineValueText& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineValueVariableLookup& lhs, const InlineValueVariableLookup& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.variable_name != rhs.variable_name) {
        return false;
    }
    if (lhs.case_sensitive_lookup != rhs.case_sensitive_lookup) {
        return false;
    }
    return true;
}

bool operator!=(const InlineValueVariableLookup& lhs, const InlineValueVariableLookup& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] InlineValueVariableLookup& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("variableName")) {
        String val;
        auto member = v.Get("variableName");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.variable_name = std::move(val);
    }
    {
        auto member = v.Get("caseSensitiveLookup");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.case_sensitive_lookup); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineValueVariableLookup& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.variable_name) {
        auto res = Encode(*in.variable_name, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"variableName", res.Get()});
    }
    {
        auto res = Encode(in.case_sensitive_lookup, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"caseSensitiveLookup", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineValueVariableLookup& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const InlineValueEvaluatableExpression& lhs,
                const InlineValueEvaluatableExpression& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.expression != rhs.expression) {
        return false;
    }
    return true;
}

bool operator!=(const InlineValueEvaluatableExpression& lhs,
                const InlineValueEvaluatableExpression& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] InlineValueEvaluatableExpression& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("expression")) {
        String val;
        auto member = v.Get("expression");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.expression = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const InlineValueEvaluatableExpression& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.expression) {
        auto res = Encode(*in.expression, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"expression", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const InlineValueEvaluatableExpression& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RelatedFullDocumentDiagnosticReport& lhs,
                const RelatedFullDocumentDiagnosticReport& rhs) {
    if (lhs.related_documents != rhs.related_documents) {
        return false;
    }
    if (static_cast<const FullDocumentDiagnosticReport&>(lhs) !=
        static_cast<const FullDocumentDiagnosticReport&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const RelatedFullDocumentDiagnosticReport& lhs,
                const RelatedFullDocumentDiagnosticReport& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] RelatedFullDocumentDiagnosticReport& out) {
    if (v.Has("relatedDocuments")) {
        std::unordered_map<DocumentUri, OneOf<lsp::FullDocumentDiagnosticReport,
                                              lsp::UnchangedDocumentDiagnosticReport>>
            val;
        auto member = v.Get("relatedDocuments");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.related_documents = std::move(val);
    }
    if (auto res = Decode(v, static_cast<FullDocumentDiagnosticReport&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RelatedFullDocumentDiagnosticReport& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.related_documents) {
        auto res = Encode(*in.related_documents, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"relatedDocuments", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const FullDocumentDiagnosticReport&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RelatedFullDocumentDiagnosticReport& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RelatedUnchangedDocumentDiagnosticReport& lhs,
                const RelatedUnchangedDocumentDiagnosticReport& rhs) {
    if (lhs.related_documents != rhs.related_documents) {
        return false;
    }
    if (static_cast<const UnchangedDocumentDiagnosticReport&>(lhs) !=
        static_cast<const UnchangedDocumentDiagnosticReport&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const RelatedUnchangedDocumentDiagnosticReport& lhs,
                const RelatedUnchangedDocumentDiagnosticReport& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] RelatedUnchangedDocumentDiagnosticReport& out) {
    if (v.Has("relatedDocuments")) {
        std::unordered_map<DocumentUri, OneOf<lsp::FullDocumentDiagnosticReport,
                                              lsp::UnchangedDocumentDiagnosticReport>>
            val;
        auto member = v.Get("relatedDocuments");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.related_documents = std::move(val);
    }
    if (auto res = Decode(v, static_cast<UnchangedDocumentDiagnosticReport&>(out));
        res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RelatedUnchangedDocumentDiagnosticReport& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    if (in.related_documents) {
        auto res = Encode(*in.related_documents, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"relatedDocuments", res.Get()});
    }
    if (auto res =
            EncodeMembers(static_cast<const UnchangedDocumentDiagnosticReport&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const RelatedUnchangedDocumentDiagnosticReport& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const PrepareRenamePlaceholder& lhs, const PrepareRenamePlaceholder& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.placeholder != rhs.placeholder) {
        return false;
    }
    return true;
}

bool operator!=(const PrepareRenamePlaceholder& lhs, const PrepareRenamePlaceholder& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] PrepareRenamePlaceholder& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("placeholder");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.placeholder); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const PrepareRenamePlaceholder& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    {
        auto res = Encode(in.placeholder, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"placeholder", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const PrepareRenamePlaceholder& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const PrepareRenameDefaultBehavior& lhs, const PrepareRenameDefaultBehavior& rhs) {
    if (lhs.default_behavior != rhs.default_behavior) {
        return false;
    }
    return true;
}

bool operator!=(const PrepareRenameDefaultBehavior& lhs, const PrepareRenameDefaultBehavior& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] PrepareRenameDefaultBehavior& out) {
    {
        auto member = v.Get("defaultBehavior");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.default_behavior); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const PrepareRenameDefaultBehavior& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.default_behavior, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"defaultBehavior", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const PrepareRenameDefaultBehavior& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceFullDocumentDiagnosticReport& lhs,
                const WorkspaceFullDocumentDiagnosticReport& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.version != rhs.version) {
        return false;
    }
    if (static_cast<const FullDocumentDiagnosticReport&>(lhs) !=
        static_cast<const FullDocumentDiagnosticReport&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceFullDocumentDiagnosticReport& lhs,
                const WorkspaceFullDocumentDiagnosticReport& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceFullDocumentDiagnosticReport& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.version); res != Success) {
            return res.Failure();
        }
    }
    if (auto res = Decode(v, static_cast<FullDocumentDiagnosticReport&>(out)); res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceFullDocumentDiagnosticReport& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    if (auto res = EncodeMembers(static_cast<const FullDocumentDiagnosticReport&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const WorkspaceFullDocumentDiagnosticReport& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const WorkspaceUnchangedDocumentDiagnosticReport& lhs,
                const WorkspaceUnchangedDocumentDiagnosticReport& rhs) {
    if (lhs.uri != rhs.uri) {
        return false;
    }
    if (lhs.version != rhs.version) {
        return false;
    }
    if (static_cast<const UnchangedDocumentDiagnosticReport&>(lhs) !=
        static_cast<const UnchangedDocumentDiagnosticReport&>(rhs)) {
        return false;
    }
    return true;
}

bool operator!=(const WorkspaceUnchangedDocumentDiagnosticReport& lhs,
                const WorkspaceUnchangedDocumentDiagnosticReport& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] WorkspaceUnchangedDocumentDiagnosticReport& out) {
    {
        auto member = v.Get("uri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("version");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.version); res != Success) {
            return res.Failure();
        }
    }
    if (auto res = Decode(v, static_cast<UnchangedDocumentDiagnosticReport&>(out));
        res != Success) {
        return res.Failure();
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const WorkspaceUnchangedDocumentDiagnosticReport& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"uri", res.Get()});
    }
    {
        auto res = Encode(in.version, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"version", res.Get()});
    }
    if (auto res =
            EncodeMembers(static_cast<const UnchangedDocumentDiagnosticReport&>(in), b, members);
        res != Success) {
        return res.Failure();
    }
    return Success;
}

Result<const json::Value*> Encode(
    [[maybe_unused]] const WorkspaceUnchangedDocumentDiagnosticReport& in,
    [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentContentChangePartial& lhs,
                const TextDocumentContentChangePartial& rhs) {
    if (lhs.range != rhs.range) {
        return false;
    }
    if (lhs.range_length != rhs.range_length) {
        return false;
    }
    if (lhs.text != rhs.text) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentContentChangePartial& lhs,
                const TextDocumentContentChangePartial& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TextDocumentContentChangePartial& out) {
    {
        auto member = v.Get("range");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.range); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("rangeLength")) {
        Uinteger val;
        auto member = v.Get("rangeLength");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.range_length = std::move(val);
    }
    {
        auto member = v.Get("text");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentContentChangePartial& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.range, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"range", res.Get()});
    }
    if (in.range_length) {
        auto res = Encode(*in.range_length, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"rangeLength", res.Get()});
    }
    {
        auto res = Encode(in.text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"text", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentContentChangePartial& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentContentChangeWholeDocument& lhs,
                const TextDocumentContentChangeWholeDocument& rhs) {
    if (lhs.text != rhs.text) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentContentChangeWholeDocument& lhs,
                const TextDocumentContentChangeWholeDocument& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TextDocumentContentChangeWholeDocument& out) {
    {
        auto member = v.Get("text");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.text); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentContentChangeWholeDocument& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(1);
    {
        auto res = Encode(in.text, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"text", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentContentChangeWholeDocument& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const MarkedStringWithLanguage& lhs, const MarkedStringWithLanguage& rhs) {
    if (lhs.language != rhs.language) {
        return false;
    }
    if (lhs.value != rhs.value) {
        return false;
    }
    return true;
}

bool operator!=(const MarkedStringWithLanguage& lhs, const MarkedStringWithLanguage& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] MarkedStringWithLanguage& out) {
    {
        auto member = v.Get("language");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.language); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("value");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.value); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const MarkedStringWithLanguage& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.language, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"language", res.Get()});
    }
    {
        auto res = Encode(in.value, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"value", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const MarkedStringWithLanguage& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookCellTextDocumentFilter& lhs,
                const NotebookCellTextDocumentFilter& rhs) {
    if (lhs.notebook != rhs.notebook) {
        return false;
    }
    if (lhs.language != rhs.language) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookCellTextDocumentFilter& lhs,
                const NotebookCellTextDocumentFilter& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookCellTextDocumentFilter& out) {
    {
        auto member = v.Get("notebook");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.notebook); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("language")) {
        String val;
        auto member = v.Get("language");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.language = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookCellTextDocumentFilter& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.notebook, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebook", res.Get()});
    }
    if (in.language) {
        auto res = Encode(*in.language, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"language", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookCellTextDocumentFilter& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const RelativePattern& lhs, const RelativePattern& rhs) {
    if (lhs.base_uri != rhs.base_uri) {
        return false;
    }
    if (lhs.pattern != rhs.pattern) {
        return false;
    }
    return true;
}

bool operator!=(const RelativePattern& lhs, const RelativePattern& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] RelativePattern& out) {
    {
        auto member = v.Get("baseUri");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.base_uri); res != Success) {
            return res.Failure();
        }
    }
    {
        auto member = v.Get("pattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.pattern); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const RelativePattern& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(2);
    {
        auto res = Encode(in.base_uri, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"baseUri", res.Get()});
    }
    {
        auto res = Encode(in.pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"pattern", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const RelativePattern& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentFilterLanguage& lhs, const TextDocumentFilterLanguage& rhs) {
    if (lhs.language != rhs.language) {
        return false;
    }
    if (lhs.scheme != rhs.scheme) {
        return false;
    }
    if (lhs.pattern != rhs.pattern) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentFilterLanguage& lhs, const TextDocumentFilterLanguage& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] TextDocumentFilterLanguage& out) {
    {
        auto member = v.Get("language");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.language); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("scheme")) {
        String val;
        auto member = v.Get("scheme");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.scheme = std::move(val);
    }
    if (v.Has("pattern")) {
        String val;
        auto member = v.Get("pattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.pattern = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentFilterLanguage& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.language, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"language", res.Get()});
    }
    if (in.scheme) {
        auto res = Encode(*in.scheme, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"scheme", res.Get()});
    }
    if (in.pattern) {
        auto res = Encode(*in.pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"pattern", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentFilterLanguage& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentFilterScheme& lhs, const TextDocumentFilterScheme& rhs) {
    if (lhs.language != rhs.language) {
        return false;
    }
    if (lhs.scheme != rhs.scheme) {
        return false;
    }
    if (lhs.pattern != rhs.pattern) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentFilterScheme& lhs, const TextDocumentFilterScheme& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TextDocumentFilterScheme& out) {
    if (v.Has("language")) {
        String val;
        auto member = v.Get("language");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.language = std::move(val);
    }
    {
        auto member = v.Get("scheme");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.scheme); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("pattern")) {
        String val;
        auto member = v.Get("pattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.pattern = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentFilterScheme& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.language) {
        auto res = Encode(*in.language, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"language", res.Get()});
    }
    {
        auto res = Encode(in.scheme, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"scheme", res.Get()});
    }
    if (in.pattern) {
        auto res = Encode(*in.pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"pattern", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentFilterScheme& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const TextDocumentFilterPattern& lhs, const TextDocumentFilterPattern& rhs) {
    if (lhs.language != rhs.language) {
        return false;
    }
    if (lhs.scheme != rhs.scheme) {
        return false;
    }
    if (lhs.pattern != rhs.pattern) {
        return false;
    }
    return true;
}

bool operator!=(const TextDocumentFilterPattern& lhs, const TextDocumentFilterPattern& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v, [[maybe_unused]] TextDocumentFilterPattern& out) {
    if (v.Has("language")) {
        String val;
        auto member = v.Get("language");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.language = std::move(val);
    }
    if (v.Has("scheme")) {
        String val;
        auto member = v.Get("scheme");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.scheme = std::move(val);
    }
    {
        auto member = v.Get("pattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.pattern); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const TextDocumentFilterPattern& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.language) {
        auto res = Encode(*in.language, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"language", res.Get()});
    }
    if (in.scheme) {
        auto res = Encode(*in.scheme, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"scheme", res.Get()});
    }
    {
        auto res = Encode(in.pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"pattern", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const TextDocumentFilterPattern& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentFilterNotebookType& lhs,
                const NotebookDocumentFilterNotebookType& rhs) {
    if (lhs.notebook_type != rhs.notebook_type) {
        return false;
    }
    if (lhs.scheme != rhs.scheme) {
        return false;
    }
    if (lhs.pattern != rhs.pattern) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentFilterNotebookType& lhs,
                const NotebookDocumentFilterNotebookType& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentFilterNotebookType& out) {
    {
        auto member = v.Get("notebookType");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.notebook_type); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("scheme")) {
        String val;
        auto member = v.Get("scheme");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.scheme = std::move(val);
    }
    if (v.Has("pattern")) {
        String val;
        auto member = v.Get("pattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.pattern = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentFilterNotebookType& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    {
        auto res = Encode(in.notebook_type, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookType", res.Get()});
    }
    if (in.scheme) {
        auto res = Encode(*in.scheme, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"scheme", res.Get()});
    }
    if (in.pattern) {
        auto res = Encode(*in.pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"pattern", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentFilterNotebookType& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentFilterScheme& lhs, const NotebookDocumentFilterScheme& rhs) {
    if (lhs.notebook_type != rhs.notebook_type) {
        return false;
    }
    if (lhs.scheme != rhs.scheme) {
        return false;
    }
    if (lhs.pattern != rhs.pattern) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentFilterScheme& lhs, const NotebookDocumentFilterScheme& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentFilterScheme& out) {
    if (v.Has("notebookType")) {
        String val;
        auto member = v.Get("notebookType");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.notebook_type = std::move(val);
    }
    {
        auto member = v.Get("scheme");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.scheme); res != Success) {
            return res.Failure();
        }
    }
    if (v.Has("pattern")) {
        String val;
        auto member = v.Get("pattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.pattern = std::move(val);
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentFilterScheme& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.notebook_type) {
        auto res = Encode(*in.notebook_type, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookType", res.Get()});
    }
    {
        auto res = Encode(in.scheme, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"scheme", res.Get()});
    }
    if (in.pattern) {
        auto res = Encode(*in.pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"pattern", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentFilterScheme& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

bool operator==(const NotebookDocumentFilterPattern& lhs,
                const NotebookDocumentFilterPattern& rhs) {
    if (lhs.notebook_type != rhs.notebook_type) {
        return false;
    }
    if (lhs.scheme != rhs.scheme) {
        return false;
    }
    if (lhs.pattern != rhs.pattern) {
        return false;
    }
    return true;
}

bool operator!=(const NotebookDocumentFilterPattern& lhs,
                const NotebookDocumentFilterPattern& rhs) {
    return !(lhs == rhs);
}

Result<SuccessType> Decode([[maybe_unused]] V& v,
                           [[maybe_unused]] NotebookDocumentFilterPattern& out) {
    if (v.Has("notebookType")) {
        String val;
        auto member = v.Get("notebookType");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.notebook_type = std::move(val);
    }
    if (v.Has("scheme")) {
        String val;
        auto member = v.Get("scheme");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), val); res != Success) {
            return res.Failure();
        }
        out.scheme = std::move(val);
    }
    {
        auto member = v.Get("pattern");
        if (member != Success) {
            return member.Failure();
        }
        if (auto res = Decode(*member.Get(), out.pattern); res != Success) {
            return res.Failure();
        }
    }

    return Success;
}

static Result<SuccessType> EncodeMembers(
    [[maybe_unused]] const NotebookDocumentFilterPattern& in,
    [[maybe_unused]] json::Builder& b,
    [[maybe_unused]] std::vector<json::Builder::Member>& members) {
    members.reserve(3);
    if (in.notebook_type) {
        auto res = Encode(*in.notebook_type, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"notebookType", res.Get()});
    }
    if (in.scheme) {
        auto res = Encode(*in.scheme, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"scheme", res.Get()});
    }
    {
        auto res = Encode(in.pattern, b);
        if (res != Success) {
            return res.Failure();
        }
        members.push_back(json::Builder::Member{"pattern", res.Get()});
    }
    return Success;
}

Result<const json::Value*> Encode([[maybe_unused]] const NotebookDocumentFilterPattern& in,
                                  [[maybe_unused]] json::Builder& b) {
    std::vector<json::Builder::Member> members;
    if (auto res = EncodeMembers(in, b, members); res != Success) {
        return res.Failure();
    }
    return b.Object(members);
}

}  // namespace langsvr::lsp
